/*! For license information please see main.2356d563.js.LICENSE.txt */
(function () {
  const __webpack_modules__ = {
    6297(e, t, r) {
      for (var n = r(6690).default, i = r(9728).default, a = r(1655).default, o = r(6389).default, s = r(1352).IOBuffer, u = r(7886), l = [], c = 0; c <= 8; c++)l.push(255 << c); const h = (function (e) {
        a(r, e); const t = o(r); function r(e) { let i; if (n(this, r), e.bitDepth !== 1) throw new Error('Only bitDepth of 1 is supported'); if (!e.height || !e.width) throw new Error('ImageData width and height are required'); return (i = t.call(this, e.data)).width = e.width, i.height = e.height, i.bitDepth = e.bitDepth, i.channels = e.channels, i.components = e.components, i; } return i(r, [{ key: 'encode', value() { this.encoded = new s(), this.encoded.skip(14), this.writeBitmapV5Header(), this.writeColorTable(); const e = this.encoded.offset; return this.writePixelArray(), this.encoded.rewind(), this.writeBitmapFileHeader(e), this.encoded.toArray(); } }, { key: 'writePixelArray', value() { let e; let t; const r = this.encoded; const n = 4 * Math.floor((this.bitDepth * this.width + 31) / 32); const i = Math.ceil(this.bitDepth * this.width / 8); const a = n - i; const o = this.bitDepth * this.width % 8; const s = o === 0 ? 0 : 8 - o; const u = n * this.height; let c = 0; let h = 0; let f = 8; r.mark(), t = this.readUint8(); for (let d = this.height - 1; d >= 0; d--) { const p = d === 0; r.reset(), r.skip(d * n); for (let m = 0; m < i; m++) { const v = m === i - 1; h <= s && v ? (r.writeByte(t << h), s !== 0 && s !== h || p || (e = t, t = this.readByte())) : h === 0 ? (e = t, t = this.readUint8(), r.writeByte(e)) : (e = t, t = this.readUint8(), r.writeByte(e << h & l[h] | t >> f)), v && (c += o || 0, r.skip(a), f = 8 - (h = c % 8)); } }n > i && (r.reset(), r.skip(u - 1), r.writeUint8(0)); } }, { key: 'writeColorTable', value() { this.encoded.writeUint32(0).writeUint32(16777215); } }, {
          key: 'writeBitmapFileHeader',
          value(e) {
            this.encoded.writeChars('BM').writeInt32(this.encoded.lastWrittenByte).writeUint16(0).writeUint16(0)
              .writeUint32(e);
          },
        }, {
          key: 'writeBitmapV5Header',
          value() {
            const e = 4 * Math.floor((this.bitDepth * this.width + 31) / 32) * this.height; this.encoded.writeUint32(124).writeInt32(this.width).writeInt32(this.height).writeUint16(1)
              .writeUint16(this.bitDepth)
              .writeUint32(u.BITMAPV5HEADER.Compression.BI_RGB)
              .writeUint32(e)
              .writeInt32(0)
              .writeInt32(0)
              .writeUint32(2 ** this.bitDepth)
              .writeUint32(2 ** this.bitDepth)
              .writeUint32(4278190080)
              .writeUint32(16711680)
              .writeUint32(65280)
              .writeUint32(255)
              .writeUint32(u.BITMAPV5HEADER.LogicalColorSpace.LCS_sRGB)
              .skip(36)
              .skip(12)
              .writeUint32(u.BITMAPV5HEADER.GamutMappingIntent.LCS_GM_IMAGES)
              .skip(12);
          },
        }]), r;
      }(s)); e.exports = h;
    },
    7886(e) {
      e.exports = {
        BITMAPV5HEADER: {
          LogicalColorSpace: { LCS_CALIBRATED_RGB: 0, LCS_sRGB: 1934772034, LCS_WINDOWS_COLOR_SPACE: 1466527264 },
          Compression: {
            BI_RGB: 0, BI_RLE8: 1, BI_RLE4: 2, BI_BITFIELDS: 3, BI_JPEG: 4, BI_PNG: 5, BI_CMYK: 11, BI_CMYKRLE8: 12, BI_CMYKRLE4: 13,
          },
          GamutMappingIntent: {
            LCS_GM_ABS_COLORIMETRIC: 8, LCS_GM_BUSINESS: 1, LCS_GM_GRAPHICS: 2, LCS_GM_IMAGES: 4,
          },
        },
      };
    },
    8545(e, t, r) {
      const n = r(6297); t.c = function (e) { return new n(e).encode(); };
    },
    9823(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = []; const o = (function () { function e(t, r) { n(this, e), r = r || {}, void 0 === t && (t = 8192), typeof t === 'number' && (t = new ArrayBuffer(t)); let i = t.byteLength; const a = r.offset ? r.offset >>> 0 : 0; t.buffer && (i = t.byteLength - a, t = t.byteLength !== t.buffer.byteLength ? t.buffer.slice(t.byteOffset + a, t.byteOffset + t.byteLength) : a ? t.buffer.slice(a) : t.buffer), this.buffer = t, this.length = i, this.byteLength = i, this.byteOffset = 0, this.offset = 0, this.littleEndian = !0, this._data = new DataView(this.buffer), this._increment = i || 8192, this._mark = 0; } return i(e, [{ key: 'available', value(e) { return void 0 === e && (e = 1), this.offset + e <= this.length; } }, { key: 'isLittleEndian', value() { return this.littleEndian; } }, { key: 'setLittleEndian', value() { this.littleEndian = !0; } }, { key: 'isBigEndian', value() { return !this.littleEndian; } }, { key: 'setBigEndian', value() { this.littleEndian = !1; } }, { key: 'skip', value(e) { void 0 === e && (e = 1), this.offset += e; } }, { key: 'seek', value(e) { this.offset = e; } }, { key: 'mark', value() { this._mark = this.offset; } }, { key: 'reset', value() { this.offset = this._mark; } }, { key: 'rewind', value() { this.offset = 0; } }, { key: 'ensureAvailable', value(e) { if (void 0 === e && (e = 1), !this.available(e)) { const t = this._increment + this._increment; this._increment = t; const r = this.length + t; const n = new Uint8Array(r); n.set(new Uint8Array(this.buffer)), this.buffer = n.buffer, this.length = r, this._data = new DataView(this.buffer); } } }, { key: 'readBoolean', value() { return this.readUint8() !== 0; } }, { key: 'readInt8', value() { return this._data.getInt8(this.offset++); } }, { key: 'readUint8', value() { return this._data.getUint8(this.offset++); } }, { key: 'readByte', value() { return this.readUint8(); } }, { key: 'readBytes', value(e) { void 0 === e && (e = 1); for (var t = new Uint8Array(e), r = 0; r < e; r++)t[r] = this.readByte(); return t; } }, { key: 'readInt16', value() { const e = this._data.getInt16(this.offset, this.littleEndian); return this.offset += 2, e; } }, { key: 'readUint16', value() { const e = this._data.getUint16(this.offset, this.littleEndian); return this.offset += 2, e; } }, { key: 'readInt32', value() { const e = this._data.getInt32(this.offset, this.littleEndian); return this.offset += 4, e; } }, { key: 'readUint32', value() { const e = this._data.getUint32(this.offset, this.littleEndian); return this.offset += 4, e; } }, { key: 'readFloat32', value() { const e = this._data.getFloat32(this.offset, this.littleEndian); return this.offset += 4, e; } }, { key: 'readFloat64', value() { const e = this._data.getFloat64(this.offset, this.littleEndian); return this.offset += 8, e; } }, { key: 'readChar', value() { return String.fromCharCode(this.readInt8()); } }, { key: 'readChars', value(e) { void 0 === e && (e = 1), a.length = e; for (let t = 0; t < e; t++)a[t] = this.readChar(); return a.join(''); } }, { key: 'writeBoolean', value(e) { this.writeUint8(e ? 255 : 0); } }, { key: 'writeInt8', value(e) { this.ensureAvailable(1), this._data.setInt8(this.offset++, e); } }, { key: 'writeUint8', value(e) { this.ensureAvailable(1), this._data.setUint8(this.offset++, e); } }, { key: 'writeByte', value(e) { this.writeUint8(e); } }, { key: 'writeBytes', value(e) { this.ensureAvailable(e.length); for (let t = 0; t < e.length; t++) this._data.setUint8(this.offset++, e[t]); } }, { key: 'writeInt16', value(e) { this.ensureAvailable(2), this._data.setInt16(this.offset, e, this.littleEndian), this.offset += 2; } }, { key: 'writeUint16', value(e) { this.ensureAvailable(2), this._data.setUint16(this.offset, e, this.littleEndian), this.offset += 2; } }, { key: 'writeInt32', value(e) { this.ensureAvailable(4), this._data.setInt32(this.offset, e, this.littleEndian), this.offset += 4; } }, { key: 'writeUint32', value(e) { this.ensureAvailable(4), this._data.setUint32(this.offset, e, this.littleEndian), this.offset += 4; } }, { key: 'writeFloat32', value(e) { this.ensureAvailable(4), this._data.setFloat32(this.offset, e, this.littleEndian), this.offset += 4; } }, { key: 'writeFloat64', value(e) { this.ensureAvailable(8), this._data.setFloat64(this.offset, e, this.littleEndian), this.offset += 8; } }, { key: 'writeChar', value(e) { this.writeUint8(e.charCodeAt(0)); } }, { key: 'writeChars', value(e) { for (let t = 0; t < e.length; t++) this.writeUint8(e.charCodeAt(t)); } }, { key: 'toArray', value() { return new Uint8Array(this.buffer, 0, this.offset); } }]), e; }()); e.exports = o;
    },
    6163(e, t, r) {
      const n = r(331); e.exports = function (e, t) { return new n(e, t).decode(t); };
    },
    9440(e, t, r) {
      const n = r(4704).default; const i = r(6690).default; const a = r(9728).default; const o = { standard: r(5796), exif: r(508), gps: r(7622) }; const s = (function () { function e(t) { if (i(this, e), !t) throw new Error('missing kind'); this.data = null, this.fields = new Map(), this.kind = t, this._map = null; } return a(e, [{ key: 'get', value(e) { if (typeof e === 'number') return this.fields.get(e); if (typeof e === 'string') return this.fields.get(o[this.kind].tagsByName[e]); throw new Error('expected a number or string'); } }, { key: 'map', get() { if (!this._map) { this._map = {}; let e; const t = o[this.kind].tagsById; const r = n(this.fields.keys()); try { for (r.s(); !(e = r.n()).done;) { const i = e.value; t[i] && (this._map[t[i]] = this.fields.get(i)); } } catch (a) { r.e(a); } finally { r.f(); } } return this._map; } }]), e; }()); e.exports = s;
    },
    8130(e, t) {
      const r = new Map([[1, [1, n]], [2, [1, function (e, t) { for (var r = [], n = '', i = 0; i < t; i++) { const a = String.fromCharCode(e.readUint8()); a === '\0' ? (r.push(n), n = '') : n += a; } return r.length === 1 ? r[0] : r; }]], [3, [2, function (e, t) { if (t === 1) return e.readUint16(); for (var r = new Uint16Array(t), n = 0; n < t; n++)r[n] = e.readUint16(); return r; }]], [4, [4, function (e, t) { if (t === 1) return e.readUint32(); for (var r = new Uint32Array(t), n = 0; n < t; n++)r[n] = e.readUint32(); return r; }]], [5, [8, function (e, t) { if (t === 1) return e.readUint32() / e.readUint32(); for (var r = new Array(t), n = 0; n < t; n++)r[n] = e.readUint32() / e.readUint32(); return r; }]], [6, [1, function (e, t) { if (t === 1) return e.readInt8(); for (var r = new Int8Array(t), n = 0; n < t; n++)r[n] = e.readInt8(); return r; }]], [7, [1, n]], [8, [2, function (e, t) { if (t === 1) return e.readInt16(); for (var r = new Int16Array(t), n = 0; n < t; n++)r[n] = e.readInt16(); return r; }]], [9, [4, function (e, t) { if (t === 1) return e.readInt32(); for (var r = new Int32Array(t), n = 0; n < t; n++)r[n] = e.readInt32(); return r; }]], [10, [8, function (e, t) { if (t === 1) return e.readInt32() / e.readInt32(); for (var r = new Array(t), n = 0; n < t; n++)r[n] = e.readInt32() / e.readInt32(); return r; }]], [11, [4, function (e, t) { if (t === 1) return e.readFloat32(); for (var r = new Float32Array(t), n = 0; n < t; n++)r[n] = e.readFloat32(); return r; }]], [12, [8, function (e, t) { if (t === 1) return e.readFloat64(); for (var r = new Float64Array(t), n = 0; n < t; n++)r[n] = e.readFloat64(); return r; }]]]); function n(e, t) { if (t === 1) return e.readUint8(); for (var r = new Uint8Array(t), n = 0; n < t; n++)r[n] = e.readUint8(); return r; }t.getByteLength = function (e, t) { return r.get(e)[0] * t; }, t.readData = function (e, t, n) { return r.get(t)[1](e, n); };
    },
    8714(e, t, r) {
      t.decode = r(6163);
    },
    508(e) {
      const t = {
        33434: 'ExposureTime', 33437: 'FNumber', 34850: 'ExposureProgram', 34852: 'SpectralSensitivity', 34855: 'ISOSpeedRatings', 34856: 'OECF', 34864: 'SensitivityType', 34865: 'StandardOutputSensitivity', 34866: 'RecommendedExposureIndex', 34867: 'ISOSpeed', 34868: 'ISOSpeedLatitudeyyy', 34869: 'ISOSpeedLatitudezzz', 36864: 'ExifVersion', 36867: 'DateTimeOriginal', 36868: 'DateTimeDigitized', 37121: 'ComponentsConfiguration', 37122: 'CompressedBitsPerPixel', 37377: 'ShutterSpeedValue', 37378: 'ApertureValue', 37379: 'BrightnessValue', 37380: 'ExposureBiasValue', 37381: 'MaxApertureValue', 37382: 'SubjectDistance', 37383: 'MeteringMode', 37384: 'LightSource', 37385: 'Flash', 37386: 'FocalLength', 37396: 'SubjectArea', 37500: 'MakerNote', 37510: 'UserComment', 37520: 'SubsecTime', 37521: 'SubsecTimeOriginal', 37522: 'SubsecTimeDigitized', 40960: 'FlashpixVersion', 40961: 'ColorSpace', 40962: 'PixelXDimension', 40963: 'PixelYDimension', 40964: 'RelatedSoundFile', 41483: 'FlashEnergy', 41484: 'SpatialFrequencyResponse', 41486: 'FocalPlaneXResolution', 41487: 'FocalPlaneYResolution', 41488: 'FocalPlaneResolutionUnit', 41492: 'SubjectLocation', 41493: 'ExposureIndex', 41495: 'SensingMethod', 41728: 'FileSource', 41729: 'SceneType', 41730: 'CFAPattern', 41985: 'CustomRendered', 41986: 'ExposureMode', 41987: 'WhiteBalance', 41988: 'DigitalZoomRatio', 41989: 'FocalLengthIn35mmFilm', 41990: 'SceneCaptureType', 41991: 'GainControl', 41992: 'Contrast', 41993: 'Saturation', 41994: 'Sharpness', 41995: 'DeviceSettingDescription', 41996: 'SubjectDistanceRange', 42016: 'ImageUniqueID', 42032: 'CameraOwnerName', 42033: 'BodySerialNumber', 42034: 'LensSpecification', 42035: 'LensMake', 42036: 'LensModel', 42037: 'LensSerialNumber', 42240: 'Gamma',
      }; const r = {}; for (const n in t)r[t[n]] = n; e.exports = { tagsById: t, tagsByName: r };
    },
    7622(e) {
      const t = {
        0: 'GPSVersionID', 1: 'GPSLatitudeRef', 2: 'GPSLatitude', 3: 'GPSLongitudeRef', 4: 'GPSLongitude', 5: 'GPSAltitudeRef', 6: 'GPSAltitude', 7: 'GPSTimeStamp', 8: 'GPSSatellites', 9: 'GPSStatus', 10: 'GPSMeasureMode', 11: 'GPSDOP', 12: 'GPSSpeedRef', 13: 'GPSSpeed', 14: 'GPSTrackRef', 15: 'GPSTrack', 16: 'GPSImgDirectionRef', 17: 'GPSImgDirection', 18: 'GPSMapDatum', 19: 'GPSDestLatitudeRef', 20: 'GPSDestLatitude', 21: 'GPSDestLongitudeRef', 22: 'GPSDestLongitude', 23: 'GPSDestBearingRef', 24: 'GPSDestBearing', 25: 'GPSDestDistanceRef', 26: 'GPSDestDistance', 27: 'GPSProcessingMethod', 28: 'GPSAreaInformation', 29: 'GPSDateStamp', 30: 'GPSDifferential', 31: 'GPSHPositioningError',
      }; const r = {}; for (const n in t)r[t[n]] = n; e.exports = { tagsById: t, tagsByName: r };
    },
    5796(e) {
      const t = {
        254: 'NewSubfileType', 255: 'SubfileType', 256: 'ImageWidth', 257: 'ImageLength', 258: 'BitsPerSample', 259: 'Compression', 262: 'PhotometricInterpretation', 263: 'Threshholding', 264: 'CellWidth', 265: 'CellLength', 266: 'FillOrder', 270: 'ImageDescription', 271: 'Make', 272: 'Model', 273: 'StripOffsets', 274: 'Orientation', 277: 'SamplesPerPixel', 278: 'RowsPerStrip', 279: 'StripByteCounts', 280: 'MinSampleValue', 281: 'MaxSampleValue', 282: 'XResolution', 283: 'YResolution', 284: 'PlanarConfiguration', 288: 'FreeOffsets', 289: 'FreeByteCounts', 290: 'GrayResponseUnit', 291: 'GrayResponseCurve', 296: 'ResolutionUnit', 305: 'Software', 306: 'DateTime', 315: 'Artist', 316: 'HostComputer', 320: 'ColorMap', 338: 'ExtraSamples', 33432: 'Copyright', 269: 'DocumentName', 285: 'PageName', 286: 'XPosition', 287: 'YPosition', 292: 'T4Options', 293: 'T6Options', 297: 'PageNumber', 301: 'TransferFunction', 317: 'Predictor', 318: 'WhitePoint', 319: 'PrimaryChromaticities', 321: 'HalftoneHints', 322: 'TileWidth', 323: 'TileLength', 324: 'TileOffsets', 325: 'TileByteCounts', 326: 'BadFaxLines', 327: 'CleanFaxData', 328: 'ConsecutiveBadFaxLines', 330: 'SubIFDs', 332: 'InkSet', 333: 'InkNames', 334: 'NumberOfInks', 336: 'DotRange', 337: 'TargetPrinter', 339: 'SampleFormat', 340: 'SMinSampleValue', 341: 'SMaxSampleValue', 342: 'TransferRange', 343: 'ClipPath', 344: 'XClipPathUnits', 345: 'YClipPathUnits', 346: 'Indexed', 347: 'JPEGTables', 351: 'OPIProxy', 400: 'GlobalParametersIFD', 401: 'ProfileType', 402: 'FaxProfile', 403: 'CodingMethods', 404: 'VersionYear', 405: 'ModeNumber', 433: 'Decode', 434: 'DefaultImageColor', 512: 'JPEGProc', 513: 'JPEGInterchangeFormat', 514: 'JPEGInterchangeFormatLength', 515: 'JPEGRestartInterval', 517: 'JPEGLosslessPredictors', 518: 'JPEGPointTransforms', 519: 'JPEGQTables', 520: 'JPEGDCTables', 521: 'JPEGACTables', 529: 'YCbCrCoefficients', 530: 'YCbCrSubSampling', 531: 'YCbCrPositioning', 532: 'ReferenceBlackWhite', 559: 'StripRowCounts', 700: 'XMP', 32781: 'ImageID', 34732: 'ImageLayer', 32932: 'WangAnnotatio', 33445: 'MDFileTag', 33446: 'MDScalePixel', 33447: 'MDColorTable', 33448: 'MDLabName', 33449: 'MDSampleInfo', 33450: 'MDPrepDate', 33451: 'MDPrepTime', 33452: 'MDFileUnits', 33550: 'ModelPixelScaleTag', 33723: 'IPTC', 33918: 'INGRPacketDataTag', 33919: 'INGRFlagRegisters', 33920: 'IrasBTransformationMatrix', 33922: 'ModelTiepointTag', 34264: 'ModelTransformationTag', 34377: 'Photoshop', 34665: 'ExifIFD', 34675: 'ICCProfile', 34735: 'GeoKeyDirectoryTag', 34736: 'GeoDoubleParamsTag', 34737: 'GeoAsciiParamsTag', 34853: 'GPSIFD', 34908: 'HylaFAXFaxRecvParams', 34909: 'HylaFAXFaxSubAddress', 34910: 'HylaFAXFaxRecvTime', 37724: 'ImageSourceData', 40965: 'InteroperabilityIFD', 42112: 'GDAL_METADATA', 42113: 'GDAL_NODATA', 50215: 'OceScanjobDescription', 50216: 'OceApplicationSelector', 50217: 'OceIdentificationNumber', 50218: 'OceImageLogicCharacteristics', 50706: 'DNGVersion', 50707: 'DNGBackwardVersion', 50708: 'UniqueCameraModel', 50709: 'LocalizedCameraModel', 50710: 'CFAPlaneColor', 50711: 'CFALayout', 50712: 'LinearizationTable', 50713: 'BlackLevelRepeatDim', 50714: 'BlackLevel', 50715: 'BlackLevelDeltaH', 50716: 'BlackLevelDeltaV', 50717: 'WhiteLevel', 50718: 'DefaultScale', 50719: 'DefaultCropOrigin', 50720: 'DefaultCropSize', 50721: 'ColorMatrix1', 50722: 'ColorMatrix2', 50723: 'CameraCalibration1', 50724: 'CameraCalibration2', 50725: 'ReductionMatrix1', 50726: 'ReductionMatrix2', 50727: 'AnalogBalance', 50728: 'AsShotNeutral', 50729: 'AsShotWhiteXY', 50730: 'BaselineExposure', 50731: 'BaselineNoise', 50732: 'BaselineSharpness', 50733: 'BayerGreenSplit', 50734: 'LinearResponseLimit', 50735: 'CameraSerialNumber', 50736: 'LensInfo', 50737: 'ChromaBlurRadius', 50738: 'AntiAliasStrength', 50740: 'DNGPrivateData', 50741: 'MakerNoteSafety', 50778: 'CalibrationIlluminant1', 50779: 'CalibrationIlluminant2', 50780: 'BestQualityScale', 50784: 'AliasLayerMetadata',
      }; const r = {}; for (const n in t)r[t[n]] = n; e.exports = { tagsById: t, tagsByName: r };
    },
    331(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = r(1655).default; const o = r(6389).default; const s = r(9823); const u = r(9440); const l = r(4027); const c = r(8130); const h = { ignoreImageData: !1, onlyFirst: !1 }; const f = (function (e) { a(r, e); const t = o(r); function r(e, i) { let a; return n(this, r), (a = t.call(this, e, i))._nextIFD = 0, a; } return i(r, [{ key: 'decode', value(e) { e = { ...h, ...e }; const t = []; for (this.decodeHeader(); this._nextIFD;) if (t.push(this.decodeIFD(e)), e.onlyFirst) return t[0]; return t; } }, { key: 'decodeHeader', value() { let e = this.readUint16(); if (e === 18761) this.setLittleEndian(); else { if (e !== 19789) throw new Error(`invalid byte order: 0x${e.toString(16)}`); this.setBigEndian(); } if ((e = this.readUint16()) !== 42) throw new Error('not a TIFF file'); this._nextIFD = this.readUint32(); } }, { key: 'decodeIFD', value(e) { let t; this.seek(this._nextIFD), t = e.kind ? new u(e.kind) : new l(); for (let r = this.readUint16(), n = 0; n < r; n++) this.decodeIFDEntry(t); return e.ignoreImageData || this.decodeImageData(t), this._nextIFD = this.readUint32(), t; } }, { key: 'decodeIFDEntry', value(e) { const t = this.offset; const r = this.readUint16(); const n = this.readUint16(); const i = this.readUint32(); if (n < 1 || n > 12) this.skip(4); else { c.getByteLength(n, i) > 4 && this.seek(this.readUint32()); const a = c.readData(this, n, i); if (e.fields.set(r, a), r === 34665 || r === 34853) { let o; const s = this.offset; r === 34665 ? o = 'exif' : r === 34853 && (o = 'gps'), this._nextIFD = a, e[o] = this.decodeIFD({ kind: o, ignoreImageData: !0 }), this.offset = s; } this.seek(t), this.skip(12); } } }, { key: 'decodeImageData', value(e) { const t = e.orientation; switch (t && t !== 1 && v('orientation', t), e.type) { case 1: case 2: this.readStripData(e); break; default: v('image type', e.type); } } }, { key: 'readStripData', value(e) { for (var t = e.width, r = e.height, n = (function (e) { if (e.length) { const t = e; e = t[0]; for (let r = 0; r < t.length; r++)t[r] !== e && v('bit depth', t); } return e; }(e.bitsPerSample)), i = e.sampleFormat, a = t * r, o = (function (e, t, r, n) { return r === 8 ? new Uint8Array(e * t) : r === 16 ? new Uint16Array(e * t) : r === 32 && n === 3 ? new Float32Array(e * t) : v('bit depth / sample format', `${r} / ${n}`); }(a, 1, n, i)), s = e.compression, u = e.rowsPerStrip * t, l = e.stripOffsets, c = e.stripByteCounts, h = 0, f = 0; f < l.length; f++) { const g = this.getStripData(s, l[f], c[f]); const y = a > u ? u : a; a -= y, n === 8 ? h = d(o, g, h, y) : n === 16 ? h = p(o, g, h, y, this.isLittleEndian()) : n === 32 && i === 3 ? h = m(o, g, h, y, this.isLittleEndian()) : v('bitDepth', n); }e.data = o; } }, { key: 'getStripData', value(e, t, r) { switch (e) { case 1: return new DataView(this.buffer, t, r); case 2: case 32773: return v('Compression', e); default: throw new Error(`invalid compression: ${e}`); } } }]), r; }(s)); function d(e, t, r, n) { for (let i = 0; i < n; i++)e[r++] = t.getUint8(i); return r; } function p(e, t, r, n, i) { for (let a = 0; a < 2 * n; a += 2)e[r++] = t.getUint16(a, i); return r; } function m(e, t, r, n, i) { for (let a = 0; a < 4 * n; a += 4)e[r++] = t.getFloat32(a, i); return r; } function v(e, t) { throw new Error(`Unsupported ${e}: ${t}`); }e.exports = f;
    },
    4027(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = r(1655).default; const o = r(6389).default; const s = r(9440); const u = /^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/; const l = (function (e) {
        a(r, e); const t = o(r); function r() { return n(this, r), t.call(this, 'standard'); } return i(r, [{ key: 'size', get() { return this.width * this.height; } }, { key: 'width', get() { return this.imageWidth; } }, { key: 'height', get() { return this.imageLength; } }, { key: 'components', get() { return this.samplesPerPixel; } }, {
          key: 'date',
          get() {
            const e = new Date(); const
              t = u.exec(this.dateTime); return e.setFullYear(t[1], t[2] - 1, t[3]), e.setHours(t[4], t[5], t[6]), e;
          },
        }, { key: 'newSubfileType', get() { return this.get(254); } }, { key: 'imageWidth', get() { return this.get(256); } }, { key: 'imageLength', get() { return this.get(257); } }, { key: 'bitsPerSample', get() { return this.get(258); } }, { key: 'compression', get() { return this.get(259) || 1; } }, { key: 'type', get() { return this.get(262); } }, { key: 'fillOrder', get() { return this.get(266) || 1; } }, { key: 'documentName', get() { return this.get(269); } }, { key: 'imageDescription', get() { return this.get(270); } }, { key: 'stripOffsets', get() { return c(this.get(273)); } }, { key: 'orientation', get() { return this.get(274); } }, { key: 'samplesPerPixel', get() { return this.get(277); } }, { key: 'rowsPerStrip', get() { return this.get(278); } }, { key: 'stripByteCounts', get() { return c(this.get(279)); } }, { key: 'minSampleValue', get() { return this.get(280) || 0; } }, { key: 'maxSampleValue', get() { return this.get(281) || 2 ** this.bitsPerSample - 1; } }, { key: 'xResolution', get() { return this.get(282); } }, { key: 'yResolution', get() { return this.get(283); } }, { key: 'planarConfiguration', get() { return this.get(284) || 1; } }, { key: 'resolutionUnit', get() { return this.get(296) || 2; } }, { key: 'dateTime', get() { return this.get(306); } }, { key: 'predictor', get() { return this.get(317) || 1; } }, { key: 'sampleFormat', get() { return this.get(339) || 1; } }, { key: 'sMinSampleValue', get() { return this.get(340) || this.minSampleValue; } }, { key: 'sMaxSampleValue', get() { return this.get(341) || this.maxSampleValue; } }]), r;
      }(s)); function c(e) { return typeof e === 'number' ? [e] : e; }e.exports = l;
    },
    674(e, t, r) {
      const n = r(9823); const i = r(8714); e.exports = function (e) { const t = new n(e); const r = {}; if (t.setBigEndian(), t.readUint16() !== 65496) throw new Error('SOI marker not found. Not a valid JPEG file'); if (t.readUint16() === 65505) { t.readUint16(); const a = t.readBytes(6); if (a[0] === 69 && a[1] === 120 && a[2] === 105 && a[3] === 102 && a[4] === 0 && a[5] === 0) { const o = i.decode(t, { onlyFirst: !0, ignoreImageData: !0, offset: t.offset }); r.exif = o; } } return r; };
    },
    6984(e, t, r) {
      t.decode = r(674);
    },
    2847(e) {
      !(function () {
        function t(e, t, r) { this.next = r, r && (r.prev = this), this.prev = t, t && (t.next = this), this.data = e; } function r() { if (!(this instanceof r)) return new r(); this._head = null, this._tail = null, this.length = 0; }r.prototype = {
          push(e) { this._tail = new t(e, this._tail, null), this._head || (this._head = this._tail), this.length++; }, pop() { if (this.length !== 0) { const e = this._tail; return this._tail = e.prev, e.prev && (e.prev = this._tail.next = null), this.length--, this.length === 1 ? this._head = this._tail : this.length === 0 && (this._head = this._tail = null), e.data; } }, unshift(e) { this._head = new t(e, null, this._head), this._tail || (this._tail = this._head), this.length++; }, shift() { if (this.length !== 0) { const e = this._head; return this._head = e.next, e.next && (e.next = this._head.prev = null), this.length--, this.length === 1 ? this._tail = this._head : this.length === 0 && (this._head = this._tail = null), e.data; } }, item(e) { e < 0 && (e = this.length + e); for (var t = this._head; e-- > 0 && t;)t = t.next; return t ? t.data : void 0; }, slice(e, t) { if (e || (e = 0), t || (t = this.length), t < 0 && (t = this.length + t), e < 0 && (e = this.length + e), t === e) return []; if (t < e) throw new Error(`invalid offset: ${e},${t} (length=${this.length})`); for (var r = t - e, n = new Array(r), i = 0, a = this._head; e-- > 0 && a;)a = a.next; for (;i < r && a;)n[i++] = a.data, a = a.next; return n; }, drop() { r.call(this); }, forEach(e, t) { for (let r = this._head, n = 0, i = this.length; n < i && r;)e.call(t || this, r.data, n, this), r = r.next, n++; }, map(e, t) { const n = new r(); return this.forEach(((r, i, a) => { n.push(e.call(t || a, r, i, a)); })), n; }, filter(e, t) { const n = new r(); return this.forEach(((r, i, a) => { e.call(t || a, r, i, a) && n.push(r); })), n; }, reduce(e, t, r) { let n = 0; let i = this._head; const a = this.length; for (t || (n = 1, t = i && i.data, i = i && i.next); n < a && i;)t = e.call(r || this, t, i.data, this), n++, i = i.next; return t; },
        }, e.exports = r;
      }());
    },
    567(e) {
      function t(e) { if (this.size = 0 | e, this.size <= 1 || (this.size & this.size - 1) !== 0) throw new Error('FFT size must be a power of two and bigger than 1'); this._csize = e << 1; for (var t = new Array(2 * this.size), r = 0; r < t.length; r += 2) { const n = Math.PI * r / this.size; t[r] = Math.cos(n), t[r + 1] = -Math.sin(n); } this.table = t; for (var i = 0, a = 1; this.size > a; a <<= 1)i++; this._width = i % 2 === 0 ? i - 1 : i, this._bitrev = new Array(1 << this._width); for (let o = 0; o < this._bitrev.length; o++) { this._bitrev[o] = 0; for (let s = 0; s < this._width; s += 2) { const u = this._width - s - 2; this._bitrev[o] |= (o >>> s & 3) << u; } } this._out = null, this._data = null, this._inv = 0; }e.exports = t, t.prototype.fromComplexArray = function (e, t) { for (var r = t || new Array(e.length >>> 1), n = 0; n < e.length; n += 2)r[n >>> 1] = e[n]; return r; }, t.prototype.createComplexArray = function () { for (var e = new Array(this._csize), t = 0; t < e.length; t++)e[t] = 0; return e; }, t.prototype.toComplexArray = function (e, t) { for (var r = t || this.createComplexArray(), n = 0; n < r.length; n += 2)r[n] = e[n >>> 1], r[n + 1] = 0; return r; }, t.prototype.completeSpectrum = function (e) { for (let t = this._csize, r = t >>> 1, n = 2; n < r; n += 2)e[t - n] = e[n], e[t - n + 1] = -e[n + 1]; }, t.prototype.transform = function (e, t) { if (e === t) throw new Error('Input and output buffers must be different'); this._out = e, this._data = t, this._inv = 0, this._transform4(), this._out = null, this._data = null; }, t.prototype.realTransform = function (e, t) { if (e === t) throw new Error('Input and output buffers must be different'); this._out = e, this._data = t, this._inv = 0, this._realTransform4(), this._out = null, this._data = null; }, t.prototype.inverseTransform = function (e, t) { if (e === t) throw new Error('Input and output buffers must be different'); this._out = e, this._data = t, this._inv = 1, this._transform4(); for (let r = 0; r < e.length; r++)e[r] /= this.size; this._out = null, this._data = null; }, t.prototype._transform4 = function () { let e; let t; const r = this._out; const n = this._csize; let i = 1 << this._width; let a = n / i << 1; const o = this._bitrev; if (a === 4) for (e = 0, t = 0; e < n; e += a, t++) { const s = o[t]; this._singleTransform2(e, s, i); } else for (e = 0, t = 0; e < n; e += a, t++) { const u = o[t]; this._singleTransform4(e, u, i); } const l = this._inv ? -1 : 1; const c = this.table; for (i >>= 2; i >= 2; i >>= 2) { const h = (a = n / i << 1) >>> 2; for (e = 0; e < n; e += a) for (let f = e + h, d = e, p = 0; d < f; d += 2, p += i) { const m = d; const v = m + h; const g = v + h; const y = g + h; const b = r[m]; const w = r[m + 1]; const k = r[v]; const x = r[v + 1]; const _ = r[g]; const S = r[g + 1]; const M = r[y]; const E = r[y + 1]; const C = b; const P = w; const A = c[p]; const T = l * c[p + 1]; const R = k * A - x * T; const I = k * T + x * A; const O = c[2 * p]; const D = l * c[2 * p + 1]; const z = _ * O - S * D; const N = _ * D + S * O; const L = c[3 * p]; const j = l * c[3 * p + 1]; const F = M * L - E * j; const B = M * j + E * L; const U = C + z; const V = P + N; const Y = C - z; const H = P - N; const q = R + F; const W = I + B; const X = l * (R - F); const G = l * (I - B); const $ = U + q; const Z = V + W; const K = U - q; const Q = V - W; const J = Y + G; const ee = H - X; const te = Y - G; const re = H + X; r[m] = $, r[m + 1] = Z, r[v] = J, r[v + 1] = ee, r[g] = K, r[g + 1] = Q, r[y] = te, r[y + 1] = re; } } }, t.prototype._singleTransform2 = function (e, t, r) { const n = this._out; const i = this._data; const a = i[t]; const o = i[t + 1]; const s = i[t + r]; const u = i[t + r + 1]; const l = a + s; const c = o + u; const h = a - s; const f = o - u; n[e] = l, n[e + 1] = c, n[e + 2] = h, n[e + 3] = f; }, t.prototype._singleTransform4 = function (e, t, r) { const n = this._out; const i = this._data; const a = this._inv ? -1 : 1; const o = 2 * r; const s = 3 * r; const u = i[t]; const l = i[t + 1]; const c = i[t + r]; const h = i[t + r + 1]; const f = i[t + o]; const d = i[t + o + 1]; const p = i[t + s]; const m = i[t + s + 1]; const v = u + f; const g = l + d; const y = u - f; const b = l - d; const w = c + p; const k = h + m; const x = a * (c - p); const _ = a * (h - m); const S = v + w; const M = g + k; const E = y + _; const C = b - x; const P = v - w; const A = g - k; const T = y - _; const R = b + x; n[e] = S, n[e + 1] = M, n[e + 2] = E, n[e + 3] = C, n[e + 4] = P, n[e + 5] = A, n[e + 6] = T, n[e + 7] = R; }, t.prototype._realTransform4 = function () { let e; let t; const r = this._out; const n = this._csize; let i = 1 << this._width; let a = n / i << 1; const o = this._bitrev; if (a === 4) for (e = 0, t = 0; e < n; e += a, t++) { const s = o[t]; this._singleRealTransform2(e, s >>> 1, i >>> 1); } else for (e = 0, t = 0; e < n; e += a, t++) { const u = o[t]; this._singleRealTransform4(e, u >>> 1, i >>> 1); } const l = this._inv ? -1 : 1; const c = this.table; for (i >>= 2; i >= 2; i >>= 2) { const h = (a = n / i << 1) >>> 1; const f = h >>> 1; const d = f >>> 1; for (e = 0; e < n; e += a) for (let p = 0, m = 0; p <= d; p += 2, m += i) { const v = e + p; const g = v + f; const y = g + f; const b = y + f; const w = r[v]; const k = r[v + 1]; const x = r[g]; const _ = r[g + 1]; const S = r[y]; const M = r[y + 1]; const E = r[b]; const C = r[b + 1]; const P = w; const A = k; const T = c[m]; const R = l * c[m + 1]; const I = x * T - _ * R; const O = x * R + _ * T; const D = c[2 * m]; const z = l * c[2 * m + 1]; const N = S * D - M * z; const L = S * z + M * D; const j = c[3 * m]; const F = l * c[3 * m + 1]; const B = E * j - C * F; const U = E * F + C * j; const V = P + N; const Y = A + L; const H = P - N; const q = A - L; const W = I + B; const X = O + U; const G = l * (I - B); const $ = l * (O - U); const Z = V + W; const K = Y + X; const Q = H + $; const J = q - G; if (r[v] = Z, r[v + 1] = K, r[g] = Q, r[g + 1] = J, p !== 0) { if (p !== d) { const ee = H + -l * $; const te = -q + -l * G; const re = V + -l * W; const ne = -Y - -l * X; const ie = e + f - p; const ae = e + h - p; r[ie] = ee, r[ie + 1] = te, r[ae] = re, r[ae + 1] = ne; } } else { const oe = V - W; const se = Y - X; r[y] = oe, r[y + 1] = se; } } } }, t.prototype._singleRealTransform2 = function (e, t, r) { const n = this._out; const i = this._data; const a = i[t]; const o = i[t + r]; const s = a + o; const u = a - o; n[e] = s, n[e + 1] = 0, n[e + 2] = u, n[e + 3] = 0; }, t.prototype._singleRealTransform4 = function (e, t, r) { const n = this._out; const i = this._data; const a = this._inv ? -1 : 1; const o = 2 * r; const s = 3 * r; const u = i[t]; const l = i[t + r]; const c = i[t + o]; const h = i[t + s]; const f = u + c; const d = u - c; const p = l + h; const m = a * (l - h); const v = f + p; const g = d; const y = -m; const b = f - p; const w = d; const k = m; n[e] = v, n[e + 1] = 0, n[e + 2] = g, n[e + 3] = y, n[e + 4] = b, n[e + 5] = 0, n[e + 6] = w, n[e + 7] = k; };
    },
    5323(module, __unused_webpack_exports, __webpack_require__) {
      const _toConsumableArray = __webpack_require__(861).default; const toBytes = function (e) { return _toConsumableArray(e).map(((e) => e.charCodeAt(0))); }; const xpiZipFilename = toBytes('META-INF/mozilla.rsa'); const oxmlContentTypes = toBytes('[Content_Types].xml'); const oxmlRels = toBytes('_rels/.rels'); function readUInt64LE(e) { for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = e[t], n = 1, i = 0; ++i < 8;)n *= 256, r += e[t + i] * n; return r; } const fileType = function (e) { if (!(e instanceof Uint8Array || e instanceof ArrayBuffer || Buffer.isBuffer(e))) throw new TypeError('Expected the `input` argument to be of type `Uint8Array` or `Buffer` or `ArrayBuffer`, got `'.concat(typeof e, '`')); const t = e instanceof Uint8Array ? e : new Uint8Array(e); if (!(t && t.length > 1)) return null; const r = function (e, r) { r = { offset: 0, ...r }; for (let n = 0; n < e.length; n++) if (r.mask) { if (e[n] !== (r.mask[n] & t[n + r.offset])) return !1; } else if (e[n] !== t[n + r.offset]) return !1; return !0; }; const n = function (e, t) { return r(toBytes(e), t); }; if (r([255, 216, 255])) return { ext: 'jpg', mime: 'image/jpeg' }; if (r([137, 80, 78, 71, 13, 10, 26, 10])) return { ext: 'png', mime: 'image/png' }; if (r([71, 73, 70])) return { ext: 'gif', mime: 'image/gif' }; if (r([87, 69, 66, 80], { offset: 8 })) return { ext: 'webp', mime: 'image/webp' }; if (r([70, 76, 73, 70])) return { ext: 'flif', mime: 'image/flif' }; if ((r([73, 73, 42, 0]) || r([77, 77, 0, 42])) && r([67, 82], { offset: 8 })) return { ext: 'cr2', mime: 'image/x-canon-cr2' }; if (r([73, 73, 42, 0]) || r([77, 77, 0, 42])) return { ext: 'tif', mime: 'image/tiff' }; if (r([66, 77])) return { ext: 'bmp', mime: 'image/bmp' }; if (r([73, 73, 188])) return { ext: 'jxr', mime: 'image/vnd.ms-photo' }; if (r([56, 66, 80, 83])) return { ext: 'psd', mime: 'image/vnd.adobe.photoshop' }; if (r([80, 75, 3, 4])) { if (r([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) return { ext: 'epub', mime: 'application/epub+zip' }; if (r(xpiZipFilename, { offset: 30 })) return { ext: 'xpi', mime: 'application/x-xpinstall' }; if (n('mimetypeapplication/vnd.oasis.opendocument.text', { offset: 30 })) return { ext: 'odt', mime: 'application/vnd.oasis.opendocument.text' }; if (n('mimetypeapplication/vnd.oasis.opendocument.spreadsheet', { offset: 30 })) return { ext: 'ods', mime: 'application/vnd.oasis.opendocument.spreadsheet' }; if (n('mimetypeapplication/vnd.oasis.opendocument.presentation', { offset: 30 })) return { ext: 'odp', mime: 'application/vnd.oasis.opendocument.presentation' }; const i = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; return e.findIndex(((e, r, n) => r >= t && n[r] === 80 && n[r + 1] === 75 && n[r + 2] === 3 && n[r + 3] === 4)); }; let a = 0; let o = !1; let s = null; do { const u = a + 30; if (o || (o = r(oxmlContentTypes, { offset: u }) || r(oxmlRels, { offset: u })), s || (n('word/', { offset: u }) ? s = { ext: 'docx', mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' } : n('ppt/', { offset: u }) ? s = { ext: 'pptx', mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation' } : n('xl/', { offset: u }) && (s = { ext: 'xlsx', mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' })), o && s) return s; a = i(t, u); } while (a >= 0); if (s) return s; } if (r([80, 75]) && (t[2] === 3 || t[2] === 5 || t[2] === 7) && (t[3] === 4 || t[3] === 6 || t[3] === 8)) return { ext: 'zip', mime: 'application/zip' }; if (r([117, 115, 116, 97, 114], { offset: 257 })) return { ext: 'tar', mime: 'application/x-tar' }; if (r([82, 97, 114, 33, 26, 7]) && (t[6] === 0 || t[6] === 1)) return { ext: 'rar', mime: 'application/x-rar-compressed' }; if (r([31, 139, 8])) return { ext: 'gz', mime: 'application/gzip' }; if (r([66, 90, 104])) return { ext: 'bz2', mime: 'application/x-bzip2' }; if (r([55, 122, 188, 175, 39, 28])) return { ext: '7z', mime: 'application/x-7z-compressed' }; if (r([120, 1])) return { ext: 'dmg', mime: 'application/x-apple-diskimage' }; if (r([51, 103, 112, 53]) || r([0, 0, 0]) && r([102, 116, 121, 112], { offset: 4 }) && (r([109, 112, 52, 49], { offset: 8 }) || r([109, 112, 52, 50], { offset: 8 }) || r([105, 115, 111, 109], { offset: 8 }) || r([105, 115, 111, 50], { offset: 8 }) || r([109, 109, 112, 52], { offset: 8 }) || r([77, 52, 86], { offset: 8 }) || r([100, 97, 115, 104], { offset: 8 }))) return { ext: 'mp4', mime: 'video/mp4' }; if (r([77, 84, 104, 100])) return { ext: 'mid', mime: 'audio/midi' }; if (r([26, 69, 223, 163])) { const l = t.subarray(4, 4100); const c = l.findIndex(((e, t, r) => r[t] === 66 && r[t + 1] === 130)); if (c !== -1) { const h = c + 3; const f = function (e) { return _toConsumableArray(e).every(((e, t) => l[h + t] === e.charCodeAt(0))); }; if (f('matroska')) return { ext: 'mkv', mime: 'video/x-matroska' }; if (f('webm')) return { ext: 'webm', mime: 'video/webm' }; } } if (r([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || r([102, 114, 101, 101], { offset: 4 }) || r([102, 116, 121, 112, 113, 116, 32, 32], { offset: 4 }) || r([109, 100, 97, 116], { offset: 4 }) || r([109, 111, 111, 118], { offset: 4 }) || r([119, 105, 100, 101], { offset: 4 })) return { ext: 'mov', mime: 'video/quicktime' }; if (r([82, 73, 70, 70])) { if (r([65, 86, 73], { offset: 8 })) return { ext: 'avi', mime: 'video/vnd.avi' }; if (r([87, 65, 86, 69], { offset: 8 })) return { ext: 'wav', mime: 'audio/vnd.wave' }; if (r([81, 76, 67, 77], { offset: 8 })) return { ext: 'qcp', mime: 'audio/qcelp' }; } if (r([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) { let d = 30; do { const p = readUInt64LE(t, d + 16); if (r([145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101], { offset: d })) { if (r([64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: d + 24 })) return { ext: 'wma', mime: 'audio/x-ms-wma' }; if (r([192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: d + 24 })) return { ext: 'wmv', mime: 'video/x-ms-asf' }; break; }d += p; } while (d + 24 <= t.length); return { ext: 'asf', mime: 'application/vnd.ms-asf' }; } if (r([0, 0, 1, 186]) || r([0, 0, 1, 179])) return { ext: 'mpg', mime: 'video/mpeg' }; if (r([102, 116, 121, 112, 51, 103], { offset: 4 })) return { ext: '3gp', mime: 'video/3gpp' }; for (let m = 0; m < 2 && m < t.length - 16; m++) { if (r([73, 68, 51], { offset: m }) || r([255, 226], { offset: m, mask: [255, 226] })) return { ext: 'mp3', mime: 'audio/mpeg' }; if (r([255, 228], { offset: m, mask: [255, 228] })) return { ext: 'mp2', mime: 'audio/mpeg' }; if (r([255, 248], { offset: m, mask: [255, 252] })) return { ext: 'mp2', mime: 'audio/mpeg' }; if (r([255, 240], { offset: m, mask: [255, 252] })) return { ext: 'mp4', mime: 'audio/mpeg' }; } if (r([102, 116, 121, 112, 77, 52, 65], { offset: 4 })) return { ext: 'm4a', mime: 'audio/mp4' }; if (r([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) return { ext: 'opus', mime: 'audio/opus' }; if (r([79, 103, 103, 83])) return r([128, 116, 104, 101, 111, 114, 97], { offset: 28 }) ? { ext: 'ogv', mime: 'video/ogg' } : r([1, 118, 105, 100, 101, 111, 0], { offset: 28 }) ? { ext: 'ogm', mime: 'video/ogg' } : r([127, 70, 76, 65, 67], { offset: 28 }) ? { ext: 'oga', mime: 'audio/ogg' } : r([83, 112, 101, 101, 120, 32, 32], { offset: 28 }) ? { ext: 'spx', mime: 'audio/ogg' } : r([1, 118, 111, 114, 98, 105, 115], { offset: 28 }) ? { ext: 'ogg', mime: 'audio/ogg' } : { ext: 'ogx', mime: 'application/ogg' }; if (r([102, 76, 97, 67])) return { ext: 'flac', mime: 'audio/x-flac' }; if (r([77, 65, 67, 32])) return { ext: 'ape', mime: 'audio/ape' }; if (r([119, 118, 112, 107])) return { ext: 'wv', mime: 'audio/wavpack' }; if (r([35, 33, 65, 77, 82, 10])) return { ext: 'amr', mime: 'audio/amr' }; if (r([37, 80, 68, 70])) return { ext: 'pdf', mime: 'application/pdf' }; if (r([77, 90])) return { ext: 'exe', mime: 'application/x-msdownload' }; if ((t[0] === 67 || t[0] === 70) && r([87, 83], { offset: 1 })) return { ext: 'swf', mime: 'application/x-shockwave-flash' }; if (r([123, 92, 114, 116, 102])) return { ext: 'rtf', mime: 'application/rtf' }; if (r([0, 97, 115, 109])) return { ext: 'wasm', mime: 'application/wasm' }; if (r([119, 79, 70, 70]) && (r([0, 1, 0, 0], { offset: 4 }) || r([79, 84, 84, 79], { offset: 4 }))) return { ext: 'woff', mime: 'font/woff' }; if (r([119, 79, 70, 50]) && (r([0, 1, 0, 0], { offset: 4 }) || r([79, 84, 84, 79], { offset: 4 }))) return { ext: 'woff2', mime: 'font/woff2' }; if (r([76, 80], { offset: 34 }) && (r([0, 0, 1], { offset: 8 }) || r([1, 0, 2], { offset: 8 }) || r([2, 0, 2], { offset: 8 }))) return { ext: 'eot', mime: 'application/vnd.ms-fontobject' }; if (r([0, 1, 0, 0, 0])) return { ext: 'ttf', mime: 'font/ttf' }; if (r([79, 84, 84, 79, 0])) return { ext: 'otf', mime: 'font/otf' }; if (r([0, 0, 1, 0])) return { ext: 'ico', mime: 'image/x-icon' }; if (r([0, 0, 2, 0])) return { ext: 'cur', mime: 'image/x-icon' }; if (r([70, 76, 86, 1])) return { ext: 'flv', mime: 'video/x-flv' }; if (r([37, 33])) return { ext: 'ps', mime: 'application/postscript' }; if (r([253, 55, 122, 88, 90, 0])) return { ext: 'xz', mime: 'application/x-xz' }; if (r([83, 81, 76, 105])) return { ext: 'sqlite', mime: 'application/x-sqlite3' }; if (r([78, 69, 83, 26])) return { ext: 'nes', mime: 'application/x-nintendo-nes-rom' }; if (r([67, 114, 50, 52])) return { ext: 'crx', mime: 'application/x-google-chrome-extension' }; if (r([77, 83, 67, 70]) || r([73, 83, 99, 40])) return { ext: 'cab', mime: 'application/vnd.ms-cab-compressed' }; if (r([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) return { ext: 'deb', mime: 'application/x-deb' }; if (r([33, 60, 97, 114, 99, 104, 62])) return { ext: 'ar', mime: 'application/x-unix-archive' }; if (r([237, 171, 238, 219])) return { ext: 'rpm', mime: 'application/x-rpm' }; if (r([31, 160]) || r([31, 157])) return { ext: 'Z', mime: 'application/x-compress' }; if (r([76, 90, 73, 80])) return { ext: 'lz', mime: 'application/x-lzip' }; if (r([208, 207, 17, 224, 161, 177, 26, 225])) return { ext: 'msi', mime: 'application/x-msi' }; if (r([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) return { ext: 'mxf', mime: 'application/mxf' }; if (r([71], { offset: 4 }) && (r([71], { offset: 192 }) || r([71], { offset: 196 }))) return { ext: 'mts', mime: 'video/mp2t' }; if (r([66, 76, 69, 78, 68, 69, 82])) return { ext: 'blend', mime: 'application/x-blender' }; if (r([66, 80, 71, 251])) return { ext: 'bpg', mime: 'image/bpg' }; if (r([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) { if (r([106, 112, 50, 32], { offset: 20 })) return { ext: 'jp2', mime: 'image/jp2' }; if (r([106, 112, 120, 32], { offset: 20 })) return { ext: 'jpx', mime: 'image/jpx' }; if (r([106, 112, 109, 32], { offset: 20 })) return { ext: 'jpm', mime: 'image/jpm' }; if (r([109, 106, 112, 50], { offset: 20 })) return { ext: 'mj2', mime: 'image/mj2' }; } if (r([70, 79, 82, 77])) return { ext: 'aif', mime: 'audio/aiff' }; if (n('<?xml ')) return { ext: 'xml', mime: 'application/xml' }; if (r([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) return { ext: 'mobi', mime: 'application/x-mobipocket-ebook' }; if (r([102, 116, 121, 112], { offset: 4 })) { if (r([109, 105, 102, 49], { offset: 8 })) return { ext: 'heic', mime: 'image/heif' }; if (r([109, 115, 102, 49], { offset: 8 })) return { ext: 'heic', mime: 'image/heif-sequence' }; if (r([104, 101, 105, 99], { offset: 8 }) || r([104, 101, 105, 120], { offset: 8 })) return { ext: 'heic', mime: 'image/heic' }; if (r([104, 101, 118, 99], { offset: 8 }) || r([104, 101, 118, 120], { offset: 8 })) return { ext: 'heic', mime: 'image/heic-sequence' }; } return r([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]) ? { ext: 'ktx', mime: 'image/ktx' } : r([68, 73, 67, 77], { offset: 128 }) ? { ext: 'dcm', mime: 'application/dicom' } : r([77, 80, 43]) || r([77, 80, 67, 75]) ? { ext: 'mpc', mime: 'audio/x-musepack' } : r([66, 69, 71, 73, 78, 58]) ? { ext: 'ics', mime: 'text/calendar' } : r([103, 108, 84, 70, 2, 0, 0, 0]) ? { ext: 'glb', mime: 'model/gltf-binary' } : r([212, 195, 178, 161]) || r([161, 178, 195, 212]) ? { ext: 'pcap', mime: 'application/vnd.tcpdump.pcap' } : null; }; module.exports = fileType, module.exports.default = fileType, Object.defineProperty(fileType, 'minimumBytes', { value: 4100 }), module.exports.stream = function (readableStream) {
        return new Promise(((resolve, reject) => {
          const stream = eval('require')('stream'); readableStream.once('readable', (() => {
            const e = new stream.PassThrough(); const
              t = readableStream.read(module.exports.minimumBytes) || readableStream.read(); try { e.fileType = fileType(t); } catch (r) { reject(r); }readableStream.unshift(t), stream.pipeline ? resolve(stream.pipeline(readableStream, e, (() => {}))) : resolve(readableStream.pipe(e));
          }));
        }));
      };
    },
    5357(e, t, r) { const n = Object.prototype.hasOwnProperty; e.exports = t = function (e, t) { return n.call(t, e); }, t.version = r(2898).version; },
    2110(e, t, r) {
      const n = r(8309); const i = {
        childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0,
      }; const a = {
        name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0,
      }; const o = {
        $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0,
      }; const s = {}; function u(e) { return n.isMemo(e) ? o : s[e.$$typeof] || i; }s[n.ForwardRef] = {
        $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0,
      }, s[n.Memo] = o; const l = Object.defineProperty; const c = Object.getOwnPropertyNames; const h = Object.getOwnPropertySymbols; const f = Object.getOwnPropertyDescriptor; const d = Object.getPrototypeOf; const p = Object.prototype; e.exports = function e(t, r, n) { if (typeof r !== 'string') { if (p) { const i = d(r); i && i !== p && e(t, i, n); } let o = c(r); h && (o = o.concat(h(r))); for (let s = u(t), m = u(r), v = 0; v < o.length; ++v) { const g = o[v]; if (!a[g] && (!n || !n[g]) && (!m || !m[g]) && (!s || !s[g])) { const y = f(r, g); try { l(t, g, y); } catch (b) {} } } } return t; };
    },
    746(e, t) {
      const r = typeof Symbol === 'function' && Symbol.for; const n = r ? Symbol.for('react.element') : 60103; const i = r ? Symbol.for('react.portal') : 60106; const a = r ? Symbol.for('react.fragment') : 60107; const o = r ? Symbol.for('react.strict_mode') : 60108; const s = r ? Symbol.for('react.profiler') : 60114; const u = r ? Symbol.for('react.provider') : 60109; const l = r ? Symbol.for('react.context') : 60110; const c = r ? Symbol.for('react.async_mode') : 60111; const h = r ? Symbol.for('react.concurrent_mode') : 60111; const f = r ? Symbol.for('react.forward_ref') : 60112; const d = r ? Symbol.for('react.suspense') : 60113; const p = r ? Symbol.for('react.suspense_list') : 60120; const m = r ? Symbol.for('react.memo') : 60115; const v = r ? Symbol.for('react.lazy') : 60116; const g = r ? Symbol.for('react.block') : 60121; const y = r ? Symbol.for('react.fundamental') : 60117; const b = r ? Symbol.for('react.responder') : 60118; const w = r ? Symbol.for('react.scope') : 60119; function k(e) { if (typeof e === 'object' && e !== null) { const t = e.$$typeof; switch (t) { case n: switch (e = e.type) { case c: case h: case a: case s: case o: case d: return e; default: switch (e = e && e.$$typeof) { case l: case f: case v: case m: case u: return e; default: return t; } } case i: return t; } } } function x(e) { return k(e) === h; }t.AsyncMode = c, t.ConcurrentMode = h, t.ContextConsumer = l, t.ContextProvider = u, t.Element = n, t.ForwardRef = f, t.Fragment = a, t.Lazy = v, t.Memo = m, t.Portal = i, t.Profiler = s, t.StrictMode = o, t.Suspense = d, t.isAsyncMode = function (e) { return x(e) || k(e) === c; }, t.isConcurrentMode = x, t.isContextConsumer = function (e) { return k(e) === l; }, t.isContextProvider = function (e) { return k(e) === u; }, t.isElement = function (e) { return typeof e === 'object' && e !== null && e.$$typeof === n; }, t.isForwardRef = function (e) { return k(e) === f; }, t.isFragment = function (e) { return k(e) === a; }, t.isLazy = function (e) { return k(e) === v; }, t.isMemo = function (e) { return k(e) === m; }, t.isPortal = function (e) { return k(e) === i; }, t.isProfiler = function (e) { return k(e) === s; }, t.isStrictMode = function (e) { return k(e) === o; }, t.isSuspense = function (e) { return k(e) === d; }, t.isValidElementType = function (e) { return typeof e === 'string' || typeof e === 'function' || e === a || e === h || e === s || e === o || e === d || e === p || typeof e === 'object' && e !== null && (e.$$typeof === v || e.$$typeof === m || e.$$typeof === u || e.$$typeof === l || e.$$typeof === f || e.$$typeof === y || e.$$typeof === b || e.$$typeof === w || e.$$typeof === g); }, t.typeOf = k;
    },
    8309(e, t, r) {
      e.exports = r(746);
    },
    946(e, t, r) {
      const n = r(5323); const i = new Set(['jpg', 'png', 'gif', 'webp', 'flif', 'cr2', 'tif', 'bmp', 'jxr', 'psd', 'ico', 'bpg', 'jp2', 'jpm', 'jpx', 'heic', 'cur', 'dcm']); const a = function (e) { const t = n(e); return i.has(t && t.ext) ? t : null; }; e.exports = a, e.exports.default = a, Object.defineProperty(a, 'minimumBytes', { value: n.minimumBytes });
    },
    1352(e, t, r) {
      r.r(t), r.d(t, { IOBuffer() { return l; } }); const n = r(5671); const i = r(3144); r(4017); function a(e) { return new TextDecoder(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'utf8').decode(e); } const o = new TextEncoder(); const s = (function () { const e = new Uint8Array(4); return !((new Uint32Array(e.buffer)[0] = 1) & e[0]); }()); const u = {
        int8: globalThis.Int8Array, uint8: globalThis.Uint8Array, int16: globalThis.Int16Array, uint16: globalThis.Uint16Array, int32: globalThis.Int32Array, uint32: globalThis.Uint32Array, uint64: globalThis.BigUint64Array, int64: globalThis.BigInt64Array, float32: globalThis.Float32Array, float64: globalThis.Float64Array,
      }; var l = (function () { function e() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8192; const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; (0, n.Z)(this, e); let i = !1; typeof t === 'number' ? t = new ArrayBuffer(t) : (i = !0, this.lastWrittenByte = t.byteLength); const a = r.offset ? r.offset >>> 0 : 0; const o = t.byteLength - a; let s = a; (ArrayBuffer.isView(t) || t instanceof e) && (t.byteLength !== t.buffer.byteLength && (s = t.byteOffset + a), t = t.buffer), this.lastWrittenByte = i ? o : 0, this.buffer = t, this.length = o, this.byteLength = o, this.byteOffset = s, this.offset = 0, this.littleEndian = !0, this._data = new DataView(this.buffer, s, o), this._mark = 0, this._marks = []; } return (0, i.Z)(e, [{ key: 'available', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1; return this.offset + e <= this.length; } }, { key: 'isLittleEndian', value() { return this.littleEndian; } }, { key: 'setLittleEndian', value() { return this.littleEndian = !0, this; } }, { key: 'isBigEndian', value() { return !this.littleEndian; } }, { key: 'setBigEndian', value() { return this.littleEndian = !1, this; } }, { key: 'skip', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1; return this.offset += e, this; } }, { key: 'back', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1; return this.offset -= e, this; } }, { key: 'seek', value(e) { return this.offset = e, this; } }, { key: 'mark', value() { return this._mark = this.offset, this; } }, { key: 'reset', value() { return this.offset = this._mark, this; } }, { key: 'pushMark', value() { return this._marks.push(this.offset), this; } }, { key: 'popMark', value() { const e = this._marks.pop(); if (void 0 === e) throw new Error('Mark stack empty'); return this.seek(e), this; } }, { key: 'rewind', value() { return this.offset = 0, this; } }, { key: 'ensureAvailable', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1; if (!this.available(e)) { const t = 2 * (this.offset + e); const r = new Uint8Array(t); r.set(new Uint8Array(this.buffer)), this.buffer = r.buffer, this.length = this.byteLength = t, this._data = new DataView(this.buffer); } return this; } }, { key: 'readBoolean', value() { return this.readUint8() !== 0; } }, { key: 'readInt8', value() { return this._data.getInt8(this.offset++); } }, { key: 'readUint8', value() { return this._data.getUint8(this.offset++); } }, { key: 'readByte', value() { return this.readUint8(); } }, { key: 'readBytes', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1; return this.readArray(e, 'uint8'); } }, { key: 'readArray', value(e, t) { const r = u[t].BYTES_PER_ELEMENT * e; const n = this.byteOffset + this.offset; const i = this.buffer.slice(n, n + r); if (this.littleEndian === s && t !== 'uint8' && t !== 'int8') { const a = new Uint8Array(this.buffer.slice(n, n + r)); a.reverse(); const o = new u[t](a.buffer); return this.offset += r, o.reverse(), o; } const l = new u[t](i); return this.offset += r, l; } }, { key: 'readInt16', value() { const e = this._data.getInt16(this.offset, this.littleEndian); return this.offset += 2, e; } }, { key: 'readUint16', value() { const e = this._data.getUint16(this.offset, this.littleEndian); return this.offset += 2, e; } }, { key: 'readInt32', value() { const e = this._data.getInt32(this.offset, this.littleEndian); return this.offset += 4, e; } }, { key: 'readUint32', value() { const e = this._data.getUint32(this.offset, this.littleEndian); return this.offset += 4, e; } }, { key: 'readFloat32', value() { const e = this._data.getFloat32(this.offset, this.littleEndian); return this.offset += 4, e; } }, { key: 'readFloat64', value() { const e = this._data.getFloat64(this.offset, this.littleEndian); return this.offset += 8, e; } }, { key: 'readBigInt64', value() { const e = this._data.getBigInt64(this.offset, this.littleEndian); return this.offset += 8, e; } }, { key: 'readBigUint64', value() { const e = this._data.getBigUint64(this.offset, this.littleEndian); return this.offset += 8, e; } }, { key: 'readChar', value() { return String.fromCharCode(this.readInt8()); } }, { key: 'readChars', value() { for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t = '', r = 0; r < e; r++)t += this.readChar(); return t; } }, { key: 'readUtf8', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1; return a(this.readBytes(e)); } }, { key: 'decodeText', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1; const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'utf-8'; return a(this.readBytes(e), t); } }, { key: 'writeBoolean', value(e) { return this.writeUint8(e ? 255 : 0), this; } }, { key: 'writeInt8', value(e) { return this.ensureAvailable(1), this._data.setInt8(this.offset++, e), this._updateLastWrittenByte(), this; } }, { key: 'writeUint8', value(e) { return this.ensureAvailable(1), this._data.setUint8(this.offset++, e), this._updateLastWrittenByte(), this; } }, { key: 'writeByte', value(e) { return this.writeUint8(e); } }, { key: 'writeBytes', value(e) { this.ensureAvailable(e.length); for (let t = 0; t < e.length; t++) this._data.setUint8(this.offset++, e[t]); return this._updateLastWrittenByte(), this; } }, { key: 'writeInt16', value(e) { return this.ensureAvailable(2), this._data.setInt16(this.offset, e, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this; } }, { key: 'writeUint16', value(e) { return this.ensureAvailable(2), this._data.setUint16(this.offset, e, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this; } }, { key: 'writeInt32', value(e) { return this.ensureAvailable(4), this._data.setInt32(this.offset, e, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this; } }, { key: 'writeUint32', value(e) { return this.ensureAvailable(4), this._data.setUint32(this.offset, e, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this; } }, { key: 'writeFloat32', value(e) { return this.ensureAvailable(4), this._data.setFloat32(this.offset, e, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this; } }, { key: 'writeFloat64', value(e) { return this.ensureAvailable(8), this._data.setFloat64(this.offset, e, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this; } }, { key: 'writeBigInt64', value(e) { return this.ensureAvailable(8), this._data.setBigInt64(this.offset, e, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this; } }, { key: 'writeBigUint64', value(e) { return this.ensureAvailable(8), this._data.setBigUint64(this.offset, e, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this; } }, { key: 'writeChar', value(e) { return this.writeUint8(e.charCodeAt(0)); } }, { key: 'writeChars', value(e) { for (let t = 0; t < e.length; t++) this.writeUint8(e.charCodeAt(t)); return this; } }, { key: 'writeUtf8', value(e) { return this.writeBytes(function (e) { return o.encode(e); }(e)); } }, { key: 'toArray', value() { return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte); } }, { key: '_updateLastWrittenByte', value() { this.offset > this.lastWrittenByte && (this.lastWrittenByte = this.offset); } }]), e; }());
    },
    4017() {
      !(function (e) { if (e.TextEncoder && e.TextDecoder) return !1; function t() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'utf-8'; if (e !== 'utf-8') throw new RangeError("Failed to construct 'TextEncoder': The encoding label provided ('".concat(e, "') is invalid.")); } function r() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'utf-8'; const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { fatal: !1 }; if (e !== 'utf-8') throw new RangeError("Failed to construct 'TextDecoder': The encoding label provided ('".concat(e, "') is invalid.")); if (t.fatal) throw new Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported."); }Object.defineProperty(t.prototype, 'encoding', { value: 'utf-8' }), t.prototype.encode = function (e) { if ((arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { stream: !1 }).stream) throw new Error("Failed to encode: the 'stream' option is unsupported."); for (var t = 0, r = e.length, n = 0, i = Math.max(32, r + (r >> 1) + 7), a = new Uint8Array(i >> 3 << 3); t < r;) { let o = e.charCodeAt(t++); if (o >= 55296 && o <= 56319) { if (t < r) { const s = e.charCodeAt(t); (64512 & s) === 56320 && (++t, o = ((1023 & o) << 10) + (1023 & s) + 65536); } if (o >= 55296 && o <= 56319) continue; } if (n + 4 > a.length) { i += 8, i = (i *= 1 + t / e.length * 2) >> 3 << 3; const u = new Uint8Array(i); u.set(a), a = u; } if ((4294967168 & o) !== 0) { if ((4294965248 & o) === 0)a[n++] = o >> 6 & 31 | 192; else if ((4294901760 & o) === 0)a[n++] = o >> 12 & 15 | 224, a[n++] = o >> 6 & 63 | 128; else { if ((4292870144 & o) !== 0) continue; a[n++] = o >> 18 & 7 | 240, a[n++] = o >> 12 & 63 | 128, a[n++] = o >> 6 & 63 | 128; }a[n++] = 63 & o | 128; } else a[n++] = o; } return a.slice(0, n); }, Object.defineProperty(r.prototype, 'encoding', { value: 'utf-8' }), Object.defineProperty(r.prototype, 'fatal', { value: !1 }), Object.defineProperty(r.prototype, 'ignoreBOM', { value: !1 }), r.prototype.decode = function (e) { if ((arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { stream: !1 }).stream) throw new Error("Failed to decode: the 'stream' option is unsupported."); for (var t = new Uint8Array(e), r = 0, n = t.length, i = []; r < n;) { const a = t[r++]; if (a === 0) break; if ((128 & a) === 0)i.push(a); else if ((224 & a) === 192) { const o = 63 & t[r++]; i.push((31 & a) << 6 | o); } else if ((240 & a) === 224) { const s = 63 & t[r++]; const u = 63 & t[r++]; i.push((31 & a) << 12 | s << 6 | u); } else if ((248 & a) === 240) { let l = (7 & a) << 18 | (63 & t[r++]) << 12 | (63 & t[r++]) << 6 | 63 & t[r++]; l > 65535 && (l -= 65536, i.push(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), i.push(l); } } return String.fromCharCode.apply(null, i); }, e.TextEncoder = t, e.TextDecoder = r; }(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : this));
    },
    8061(e, t, r) {
      r.r(t), r.d(t, { isAnyArray() { return i; } }); const n = Object.prototype.toString; function i(e) { const t = n.call(e); return t.endsWith('Array]') && !t.includes('Big'); }
    },
    6990(e) {
      const t = Object.prototype.toString; e.exports = function (e) { return t.call(e).substr(-6, 5) === 'Array'; };
    },
    5821(e) {
      e.exports = Number.isFinite || function (e) { return !(typeof e !== 'number' || e !== e || e === 1 / 0 || e === -1 / 0); };
    },
    7390(e, t, r) { const n = r(5821); e.exports = Number.isInteger || function (e) { return typeof e === 'number' && n(e) && Math.floor(e) === e; }; },
    1684(e, t, r) { const n = r(5998); const i = r(4720); e.exports = { encode: n, decode: i }; },
    4720(e, t, r) {
      const n = r(2122).default; const i = (function () {
        const e = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]); const t = 4017; const r = 799; const n = 3406; const i = 2276; const a = 1567; const o = 3784; const s = 5793; const u = 2896; function l() {} function c(e, t) { for (var r, n, i = 0, a = [], o = 16; o > 0 && !e[o - 1];)o--; a.push({ children: [], index: 0 }); let s; let u = a[0]; for (r = 0; r < o; r++) { for (n = 0; n < e[r]; n++) { for ((u = a.pop()).children[u.index] = t[i]; u.index > 0;) { if (a.length === 0) throw new Error('Could not recreate Huffman Table'); u = a.pop(); } for (u.index++, a.push(u); a.length <= r;)a.push(s = { children: [], index: 0 }), u.children[u.index] = s.children, u = s; i++; }r + 1 < o && (a.push(s = { children: [], index: 0 }), u.children[u.index] = s.children, u = s); } return a[0].children; } function h(t, r, n, i, a, o, s, u, l, c) { n.precision, n.samplesPerLine, n.scanLines; const h = n.mcusPerLine; const f = n.progressive; const d = (n.maxH, n.maxV, r); let p = 0; let m = 0; function v() { if (m > 0) return m--, p >> m & 1; if ((p = t[r++]) == 255) { const e = t[r++]; if (e) throw new Error(`unexpected marker: ${(p << 8 | e).toString(16)}`); } return m = 7, p >>> 7; } function g(e) { for (var t, r = e; (t = v()) !== null;) { if (typeof (r = r[t]) === 'number') return r; if (typeof r !== 'object') throw new Error('invalid huffman sequence'); } return null; } function y(e) { for (var t = 0; e > 0;) { const r = v(); if (r === null) return; t = t << 1 | r, e--; } return t; } function b(e) { const t = y(e); return t >= 1 << e - 1 ? t : t + (-1 << e) + 1; } let w = 0; let k; let x = 0; function _(e, t, r, n, i) { const a = r % h; const o = (r / h | 0) * e.v + n; const s = a * e.h + i; void 0 === e.blocks[o] && c.tolerantDecoding || t(e, e.blocks[o][s]); } function S(e, t, r) { const n = r / e.blocksPerLine | 0; const i = r % e.blocksPerLine; void 0 === e.blocks[n] && c.tolerantDecoding || t(e, e.blocks[n][i]); } let M; let E; let C; let P; let A; let T; const R = i.length; T = f ? o === 0 ? u === 0 ? function (e, t) { const r = g(e.huffmanTableDC); const n = r === 0 ? 0 : b(r) << l; t[0] = e.pred += n; } : function (e, t) { t[0] |= v() << l; } : u === 0 ? function (t, r) { if (w > 0)w--; else for (let n = o, i = s; n <= i;) { const a = g(t.huffmanTableAC); const u = 15 & a; const c = a >> 4; if (u !== 0)r[e[n += c]] = b(u) * (1 << l), n++; else { if (c < 15) { w = y(c) + (1 << c) - 1; break; }n += 16; } } } : function (t, r) { for (let n = o, i = s, a = 0; n <= i;) { const u = e[n]; const c = r[u] < 0 ? -1 : 1; switch (x) { case 0: var h = g(t.huffmanTableAC); var f = 15 & h; if (a = h >> 4, f === 0)a < 15 ? (w = y(a) + (1 << a), x = 4) : (a = 16, x = 1); else { if (f !== 1) throw new Error('invalid ACn encoding'); k = b(f), x = a ? 2 : 3; } continue; case 1: case 2: r[u] ? r[u] += (v() << l) * c : --a === 0 && (x = x == 2 ? 3 : 0); break; case 3: r[u] ? r[u] += (v() << l) * c : (r[u] = k << l, x = 0); break; case 4: r[u] && (r[u] += (v() << l) * c); }n++; }x === 4 && --w === 0 && (x = 0); } : function (t, r) { const n = g(t.huffmanTableDC); const i = n === 0 ? 0 : b(n); r[0] = t.pred += i; for (let a = 1; a < 64;) { const o = g(t.huffmanTableAC); const s = 15 & o; const u = o >> 4; if (s !== 0)r[e[a += u]] = b(s), a++; else { if (u < 15) break; a += 16; } } }; let I; let O; let D; let z; let N = 0; for (O = R == 1 ? i[0].blocksPerLine * i[0].blocksPerColumn : h * n.mcusPerColumn, a || (a = O); N < O;) { for (E = 0; E < R; E++)i[E].pred = 0; if (w = 0, R == 1) for (M = i[0], A = 0; A < a; A++)S(M, T, N), N++; else for (A = 0; A < a; A++) { for (E = 0; E < R; E++) for (D = (M = i[E]).h, z = M.v, C = 0; C < z; C++) for (P = 0; P < D; P++)_(M, T, N, C, P); if (++N === O) break; } if (N === O) do { if (t[r] === 255 && t[r + 1] !== 0) break; r += 1; } while (r < t.length - 2); if (m = 0, (I = t[r] << 8 | t[r + 1]) < 65280) throw new Error('marker was not found'); if (!(I >= 65488 && I <= 65495)) break; r += 2; } return r - d; } function f(e, l) { let c; let h; const f = []; const d = l.blocksPerLine; const p = l.blocksPerColumn; const m = d << 3; const g = new Int32Array(64); const y = new Uint8Array(64); function b(e, c, h) { let f; let d; let p; let m; let v; let g; let y; let b; let w; let k; const x = l.quantizationTable; const _ = h; for (k = 0; k < 64; k++)_[k] = e[k] * x[k]; for (k = 0; k < 8; ++k) { const S = 8 * k; _[1 + S] != 0 || _[2 + S] != 0 || _[3 + S] != 0 || _[4 + S] != 0 || _[5 + S] != 0 || _[6 + S] != 0 || _[7 + S] != 0 ? (f = s * _[0 + S] + 128 >> 8, d = s * _[4 + S] + 128 >> 8, p = _[2 + S], m = _[6 + S], v = u * (_[1 + S] - _[7 + S]) + 128 >> 8, b = u * (_[1 + S] + _[7 + S]) + 128 >> 8, g = _[3 + S] << 4, y = _[5 + S] << 4, w = f - d + 1 >> 1, f = f + d + 1 >> 1, d = w, w = p * o + m * a + 128 >> 8, p = p * a - m * o + 128 >> 8, m = w, w = v - y + 1 >> 1, v = v + y + 1 >> 1, y = w, w = b + g + 1 >> 1, g = b - g + 1 >> 1, b = w, w = f - m + 1 >> 1, f = f + m + 1 >> 1, m = w, w = d - p + 1 >> 1, d = d + p + 1 >> 1, p = w, w = v * i + b * n + 2048 >> 12, v = v * n - b * i + 2048 >> 12, b = w, w = g * r + y * t + 2048 >> 12, g = g * t - y * r + 2048 >> 12, y = w, _[0 + S] = f + b, _[7 + S] = f - b, _[1 + S] = d + y, _[6 + S] = d - y, _[2 + S] = p + g, _[5 + S] = p - g, _[3 + S] = m + v, _[4 + S] = m - v) : (w = s * _[0 + S] + 512 >> 10, _[0 + S] = w, _[1 + S] = w, _[2 + S] = w, _[3 + S] = w, _[4 + S] = w, _[5 + S] = w, _[6 + S] = w, _[7 + S] = w); } for (k = 0; k < 8; ++k) { const M = k; _[8 + M] != 0 || _[16 + M] != 0 || _[24 + M] != 0 || _[32 + M] != 0 || _[40 + M] != 0 || _[48 + M] != 0 || _[56 + M] != 0 ? (f = s * _[0 + M] + 2048 >> 12, d = s * _[32 + M] + 2048 >> 12, p = _[16 + M], m = _[48 + M], v = u * (_[8 + M] - _[56 + M]) + 2048 >> 12, b = u * (_[8 + M] + _[56 + M]) + 2048 >> 12, g = _[24 + M], y = _[40 + M], w = f - d + 1 >> 1, f = f + d + 1 >> 1, d = w, w = p * o + m * a + 2048 >> 12, p = p * a - m * o + 2048 >> 12, m = w, w = v - y + 1 >> 1, v = v + y + 1 >> 1, y = w, w = b + g + 1 >> 1, g = b - g + 1 >> 1, b = w, w = f - m + 1 >> 1, f = f + m + 1 >> 1, m = w, w = d - p + 1 >> 1, d = d + p + 1 >> 1, p = w, w = v * i + b * n + 2048 >> 12, v = v * n - b * i + 2048 >> 12, b = w, w = g * r + y * t + 2048 >> 12, g = g * t - y * r + 2048 >> 12, y = w, _[0 + M] = f + b, _[56 + M] = f - b, _[8 + M] = d + y, _[48 + M] = d - y, _[16 + M] = p + g, _[40 + M] = p - g, _[24 + M] = m + v, _[32 + M] = m - v) : (w = s * h[k + 0] + 8192 >> 14, _[0 + M] = w, _[8 + M] = w, _[16 + M] = w, _[24 + M] = w, _[32 + M] = w, _[40 + M] = w, _[48 + M] = w, _[56 + M] = w); } for (k = 0; k < 64; ++k) { const E = 128 + (_[k] + 8 >> 4); c[k] = E < 0 ? 0 : E > 255 ? 255 : E; } }v(m * p * 8); for (let w = 0; w < p; w++) { const k = w << 3; for (c = 0; c < 8; c++)f.push(new Uint8Array(m)); for (let x = 0; x < d; x++) { b(l.blocks[w][x], y, g); let _ = 0; const S = x << 3; for (h = 0; h < 8; h++) { const M = f[k + h]; for (c = 0; c < 8; c++)M[S + c] = y[_++]; } } } return f; } function d(e) { return e < 0 ? 0 : e > 255 ? 255 : e; }l.prototype = {
          load(e) { const t = new XMLHttpRequest(); t.open('GET', e, !0), t.responseType = 'arraybuffer', t.onload = function () { const e = new Uint8Array(t.response || t.mozResponseArrayBuffer); this.parse(e), this.onload && this.onload(); }.bind(this), t.send(null); },
          parse(t) {
            const r = 1e3 * this.opts.maxResolutionInMP * 1e3; let n = 0; t.length; function i() { const e = t[n] << 8 | t[n + 1]; return n += 2, e; } function a() { const e = i(); const r = t.subarray(n, n + e - 2); return n += r.length, r; } function o(e) { let t; let r; let n = 1; let i = 1; for (r in e.components)e.components.hasOwnProperty(r) && (n < (t = e.components[r]).h && (n = t.h), i < t.v && (i = t.v)); const a = Math.ceil(e.samplesPerLine / 8 / n); const o = Math.ceil(e.scanLines / 8 / i); for (r in e.components) if (e.components.hasOwnProperty(r)) { t = e.components[r]; const s = Math.ceil(Math.ceil(e.samplesPerLine / 8) * t.h / n); const u = Math.ceil(Math.ceil(e.scanLines / 8) * t.v / i); const l = a * t.h; const c = o * t.v; const h = []; v(256 * (c * l)); for (let f = 0; f < c; f++) { for (var d = [], p = 0; p < l; p++)d.push(new Int32Array(64)); h.push(d); }t.blocksPerLine = s, t.blocksPerColumn = u, t.blocks = h; }e.maxH = n, e.maxV = i, e.mcusPerLine = a, e.mcusPerColumn = o; } let s; let u; let l = null; let d = null; const p = []; const m = []; const g = []; const y = []; let b = i(); let w = -1; if (this.comments = [], b != 65496) throw new Error('SOI not found'); for (b = i(); b != 65497;) {
              switch (b) {
                case 65280: break; case 65504: case 65505: case 65506: case 65507: case 65508: case 65509: case 65510: case 65511: case 65512: case 65513: case 65514: case 65515: case 65516: case 65517: case 65518: case 65519: case 65534: var k = a(); if (b === 65534) { const x = String.fromCharCode.apply(null, k); this.comments.push(x); }b === 65504 && k[0] === 74 && k[1] === 70 && k[2] === 73 && k[3] === 70 && k[4] === 0 && (l = {
                  version: { major: k[5], minor: k[6] }, densityUnits: k[7], xDensity: k[8] << 8 | k[9], yDensity: k[10] << 8 | k[11], thumbWidth: k[12], thumbHeight: k[13], thumbData: k.subarray(14, 14 + 3 * k[12] * k[13]),
                }), b === 65505 && k[0] === 69 && k[1] === 120 && k[2] === 105 && k[3] === 102 && k[4] === 0 && (this.exifBuffer = k.subarray(5, k.length)), b === 65518 && k[0] === 65 && k[1] === 100 && k[2] === 111 && k[3] === 98 && k[4] === 101 && k[5] === 0 && (d = {
                  version: k[6], flags0: k[7] << 8 | k[8], flags1: k[9] << 8 | k[10], transformCode: k[11],
                }); break; case 65499: for (let _ = i() + n - 2; n < _;) { const S = t[n++]; v(256); const M = new Int32Array(64); if (S >> 4 === 0) for (G = 0; G < 64; G++) { M[e[G]] = t[n++]; } else { if (S >> 4 !== 1) throw new Error('DQT: invalid table spec'); for (G = 0; G < 64; G++) { M[e[G]] = i(); } }p[15 & S] = M; } break; case 65472: case 65473: case 65474: i(), (s = {}).extended = b === 65473, s.progressive = b === 65474, s.precision = t[n++], s.scanLines = i(), s.samplesPerLine = i(), s.components = {}, s.componentsOrder = []; var E = s.scanLines * s.samplesPerLine; if (E > r) { const C = Math.ceil((E - r) / 1e6); throw new Error('maxResolutionInMP limit exceeded by '.concat(C, 'MP')); } var P; var A = t[n++]; for (W = 0; W < A; W++) { P = t[n]; const T = t[n + 1] >> 4; const R = 15 & t[n + 1]; const I = t[n + 2]; if (T <= 0 || R <= 0) throw new Error('Invalid sampling factor, expected values above 0'); s.componentsOrder.push(P), s.components[P] = { h: T, v: R, quantizationIdx: I }, n += 3; }o(s), m.push(s); break; case 65476: var O = i(); for (W = 2; W < O;) { const D = t[n++]; const z = new Uint8Array(16); let N = 0; for (G = 0; G < 16; G++, n++)N += z[G] = t[n]; v(16 + N); const L = new Uint8Array(N); for (G = 0; G < N; G++, n++)L[G] = t[n]; W += 17 + N, (D >> 4 === 0 ? y : g)[15 & D] = c(z, L); } break; case 65501: i(), u = i(); break; case 65500: i(), i(); break; case 65498: i(); var j = t[n++]; var F = []; for (W = 0; W < j; W++) { $ = s.components[t[n++]]; const B = t[n++]; $.huffmanTableDC = y[B >> 4], $.huffmanTableAC = g[15 & B], F.push($); } var U = t[n++]; var V = t[n++]; var Y = t[n++]; var H = h(t, n, s, F, u, U, V, Y >> 4, 15 & Y, this.opts); n += H; break; case 65535: t[n] !== 255 && n--; break; default: if (t[n - 3] == 255 && t[n - 2] >= 192 && t[n - 2] <= 254) { n -= 3; break; } if (b === 224 || b == 225) { if (w !== -1) throw new Error('first unknown JPEG marker at offset '.concat(w.toString(16), ', second unknown JPEG marker ').concat(b.toString(16), ' at offset ').concat((n - 1).toString(16))); w = n - 1; const q = i(); if (t[n + q - 2] === 255) { n += q - 2; break; } } throw new Error(`unknown JPEG marker ${b.toString(16)}`);
              }b = i();
            } if (m.length != 1) throw new Error('only single frame JPEGs supported'); for (var W = 0; W < m.length; W++) { const X = m[W].components; for (var G in X)X[G].quantizationTable = p[X[G].quantizationIdx], delete X[G].quantizationIdx; } this.width = s.samplesPerLine, this.height = s.scanLines, this.jfif = l, this.adobe = d, this.components = []; for (W = 0; W < s.componentsOrder.length; W++) { var $ = s.components[s.componentsOrder[W]]; this.components.push({ lines: f(0, $), scaleX: $.h / s.maxH, scaleY: $.v / s.maxV }); }
          },
          getData(e, t) { let r; let n; let i; let a; let o; let s; let u; let l; let c; let h; let f; let p; let m; let g; let y; let b; let w; let k; let x; let _; let S; const M = this.width / e; const E = this.height / t; let C = 0; const P = e * t * this.components.length; v(P); const A = new Uint8Array(P); switch (this.components.length) { case 1: for (r = this.components[0], h = 0; h < t; h++) for (o = r.lines[0 | h * r.scaleY * E], c = 0; c < e; c++)f = o[0 | c * r.scaleX * M], A[C++] = f; break; case 2: for (r = this.components[0], n = this.components[1], h = 0; h < t; h++) for (o = r.lines[0 | h * r.scaleY * E], s = n.lines[0 | h * n.scaleY * E], c = 0; c < e; c++)f = o[0 | c * r.scaleX * M], A[C++] = f, f = s[0 | c * n.scaleX * M], A[C++] = f; break; case 3: for (S = !0, this.adobe && this.adobe.transformCode ? S = !0 : typeof this.opts.colorTransform !== 'undefined' && (S = !!this.opts.colorTransform), r = this.components[0], n = this.components[1], i = this.components[2], h = 0; h < t; h++) for (o = r.lines[0 | h * r.scaleY * E], s = n.lines[0 | h * n.scaleY * E], u = i.lines[0 | h * i.scaleY * E], c = 0; c < e; c++)S ? (f = o[0 | c * r.scaleX * M], p = s[0 | c * n.scaleX * M], k = d(f + 1.402 * ((m = u[0 | c * i.scaleX * M]) - 128)), x = d(f - 0.3441363 * (p - 128) - 0.71413636 * (m - 128)), _ = d(f + 1.772 * (p - 128))) : (k = o[0 | c * r.scaleX * M], x = s[0 | c * n.scaleX * M], _ = u[0 | c * i.scaleX * M]), A[C++] = k, A[C++] = x, A[C++] = _; break; case 4: if (!this.adobe) throw new Error('Unsupported color mode (4 components)'); for (S = !1, this.adobe && this.adobe.transformCode ? S = !0 : typeof this.opts.colorTransform !== 'undefined' && (S = !!this.opts.colorTransform), r = this.components[0], n = this.components[1], i = this.components[2], a = this.components[3], h = 0; h < t; h++) for (o = r.lines[0 | h * r.scaleY * E], s = n.lines[0 | h * n.scaleY * E], u = i.lines[0 | h * i.scaleY * E], l = a.lines[0 | h * a.scaleY * E], c = 0; c < e; c++)S ? (f = o[0 | c * r.scaleX * M], p = s[0 | c * n.scaleX * M], m = u[0 | c * i.scaleX * M], g = l[0 | c * a.scaleX * M], y = 255 - d(f + 1.402 * (m - 128)), b = 255 - d(f - 0.3441363 * (p - 128) - 0.71413636 * (m - 128)), w = 255 - d(f + 1.772 * (p - 128))) : (y = o[0 | c * r.scaleX * M], b = s[0 | c * n.scaleX * M], w = u[0 | c * i.scaleX * M], g = l[0 | c * a.scaleX * M]), A[C++] = 255 - y, A[C++] = 255 - b, A[C++] = 255 - w, A[C++] = 255 - g; break; default: throw new Error('Unsupported color mode'); } return A; },
          copyToImageData(e, t) { let r; let n; let i; let a; let o; let s; let u; let l; let c; const h = e.width; const f = e.height; const p = e.data; const m = this.getData(h, f); let v = 0; let g = 0; switch (this.components.length) { case 1: for (n = 0; n < f; n++) for (r = 0; r < h; r++)i = m[v++], p[g++] = i, p[g++] = i, p[g++] = i, t && (p[g++] = 255); break; case 3: for (n = 0; n < f; n++) for (r = 0; r < h; r++)u = m[v++], l = m[v++], c = m[v++], p[g++] = u, p[g++] = l, p[g++] = c, t && (p[g++] = 255); break; case 4: for (n = 0; n < f; n++) for (r = 0; r < h; r++)o = m[v++], s = m[v++], i = m[v++], u = 255 - d(o * (1 - (a = m[v++]) / 255) + a), l = 255 - d(s * (1 - a / 255) + a), c = 255 - d(i * (1 - a / 255) + a), p[g++] = u, p[g++] = l, p[g++] = c, t && (p[g++] = 255); break; default: throw new Error('Unsupported color mode'); } },
        }; let p = 0; let m = 0; function v() { const e = p + (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0); if (e > m) { const t = Math.ceil((e - m) / 1024 / 1024); throw new Error('maxMemoryUsageInMB limit exceeded by at least '.concat(t, 'MB')); }p = e; } return l.resetMaxMemoryUsage = function (e) { p = 0, m = e; }, l.getBytesAllocated = function () { return p; }, l.requestMemoryAllocation = v, l;
      }()); e.exports = function (e) {
        const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = {
          colorTransform: void 0, useTArray: !1, formatAsRGBA: !0, tolerantDecoding: !0, maxResolutionInMP: 100, maxMemoryUsageInMB: 512,
        }; const a = n(n({}, r), t); const o = new Uint8Array(e); const s = new i(); s.opts = a, i.resetMaxMemoryUsage(1024 * a.maxMemoryUsageInMB * 1024), s.parse(o); const u = a.formatAsRGBA ? 4 : 3; const l = s.width * s.height * u; try {
          i.requestMemoryAllocation(l); var c = {
            width: s.width, height: s.height, exifBuffer: s.exifBuffer, data: a.useTArray ? new Uint8Array(l) : Buffer.alloc(l),
          }; s.comments.length > 0 && (c.comments = s.comments);
        } catch (h) { if (h instanceof RangeError) throw new Error(`Could not allocate enough memory for the image. Required: ${l}`); if (h instanceof ReferenceError && h.message === 'Buffer is not defined') throw new Error('Buffer is not globally defined in this environment. Consider setting useTArray to true'); throw h; } return s.copyToImageData(c, a.formatAsRGBA), c;
      };
    },
    5998(e) { function t(e) { Math.round; let t; let r; let n; let i; let a; const o = Math.floor; const s = new Array(64); const u = new Array(64); const l = new Array(64); const c = new Array(64); const h = new Array(65535); const f = new Array(65535); const d = new Array(64); const p = new Array(64); let m = []; let v = 0; let g = 7; const y = new Array(64); const b = new Array(64); const w = new Array(64); const k = new Array(256); const x = new Array(2048); const _ = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63]; const S = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]; const M = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; const E = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125]; const C = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250]; const P = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]; const A = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; const T = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119]; const R = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250]; function I(e, t) { for (var r = 0, n = 0, i = new Array(), a = 1; a <= 16; a++) { for (let o = 1; o <= e[a]; o++)i[t[n]] = [], i[t[n]][0] = r, i[t[n]][1] = a, n++, r++; r *= 2; } return i; } function O(e) { for (let t = e[0], r = e[1] - 1; r >= 0;)t & 1 << r && (v |= 1 << g), r--, --g < 0 && (v == 255 ? (D(255), D(0)) : D(v), g = 7, v = 0); } function D(e) { m.push(e); } function z(e) { D(e >> 8 & 255), D(255 & e); } function N(e, t, r, n, i) { for (var a, o = i[0], s = i[240], u = (function (e, t) { let r; let n; let i; let a; let o; let s; let u; let l; let c; let h; let f = 0; for (c = 0; c < 8; ++c) { r = e[f], n = e[f + 1], i = e[f + 2], a = e[f + 3], o = e[f + 4], s = e[f + 5], u = e[f + 6]; const p = r + (l = e[f + 7]); const m = r - l; const v = n + u; const g = n - u; const y = i + s; const b = i - s; const w = a + o; const k = a - o; let x = p + w; const _ = p - w; let S = v + y; let M = v - y; e[f] = x + S, e[f + 4] = x - S; const E = 0.707106781 * (M + _); e[f + 2] = _ + E, e[f + 6] = _ - E; const C = 0.382683433 * ((x = k + b) - (M = g + m)); const P = 0.5411961 * x + C; const A = 1.306562965 * M + C; const T = 0.707106781 * (S = b + g); const R = m + T; const I = m - T; e[f + 5] = I + P, e[f + 3] = I - P, e[f + 1] = R + A, e[f + 7] = R - A, f += 8; } for (f = 0, c = 0; c < 8; ++c) { r = e[f], n = e[f + 8], i = e[f + 16], a = e[f + 24], o = e[f + 32], s = e[f + 40], u = e[f + 48]; const O = r + (l = e[f + 56]); const D = r - l; const z = n + u; const N = n - u; const L = i + s; const j = i - s; const F = a + o; const B = a - o; let U = O + F; const V = O - F; let Y = z + L; let H = z - L; e[f] = U + Y, e[f + 32] = U - Y; const q = 0.707106781 * (H + V); e[f + 16] = V + q, e[f + 48] = V - q; const W = 0.382683433 * ((U = B + j) - (H = N + D)); const X = 0.5411961 * U + W; const G = 1.306562965 * H + W; const $ = 0.707106781 * (Y = j + N); const Z = D + $; const K = D - $; e[f + 40] = K + X, e[f + 24] = K - X, e[f + 8] = Z + G, e[f + 56] = Z - G, f++; } for (c = 0; c < 64; ++c)h = e[c] * t[c], d[c] = h > 0 ? h + 0.5 | 0 : h - 0.5 | 0; return d; }(e, t)), l = 0; l < 64; ++l)p[_[l]] = u[l]; const c = p[0] - r; r = p[0], c == 0 ? O(n[0]) : (O(n[f[a = 32767 + c]]), O(h[a])); for (var m = 63; m > 0 && p[m] == 0; m--);if (m == 0) return O(o), r; for (var v, g = 1; g <= m;) { for (var y = g; p[g] == 0 && g <= m; ++g);let b = g - y; if (b >= 16) { v = b >> 4; for (let w = 1; w <= v; ++w)O(s); b &= 15; }a = 32767 + p[g], O(i[(b << 4) + f[a]]), O(h[a]), g++; } return m != 63 && O(o), r; } function L(e) { if (e <= 0 && (e = 1), e > 100 && (e = 100), a != e) { (function (e) { for (let t = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r = 0; r < 64; r++) { let n = o((t[r] * e + 50) / 100); n < 1 ? n = 1 : n > 255 && (n = 255), s[_[r]] = n; } for (let i = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a = 0; a < 64; a++) { let h = o((i[a] * e + 50) / 100); h < 1 ? h = 1 : h > 255 && (h = 255), u[_[a]] = h; } for (let f = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d = 0, p = 0; p < 8; p++) for (let m = 0; m < 8; m++)l[d] = 1 / (s[_[d]] * f[p] * f[m] * 8), c[d] = 1 / (u[_[d]] * f[p] * f[m] * 8), d++; }(e < 50 ? Math.floor(5e3 / e) : Math.floor(200 - 2 * e))), a = e; } } this.encode = function (e, a) { let o; (new Date()).getTime(); a && L(a), m = new Array(), v = 0, g = 7, z(65496), z(65504), z(16), D(74), D(70), D(73), D(70), D(0), D(1), D(1), D(0), z(1), z(1), D(0), D(0), typeof (o = e.comments) !== 'undefined' && o.constructor === Array && o.forEach(((e) => { if (typeof e === 'string') { z(65534); let t; const r = e.length; for (z(r + 2), t = 0; t < r; t++)D(e.charCodeAt(t)); } })), (function (e) { if (e) { z(65505), e[0] === 69 && e[1] === 120 && e[2] === 105 && e[3] === 102 ? z(e.length + 2) : (z(e.length + 5 + 2), D(69), D(120), D(105), D(102), D(0)); for (let t = 0; t < e.length; t++)D(e[t]); } }(e.exifBuffer)), (function () { z(65499), z(132), D(0); for (let e = 0; e < 64; e++)D(s[e]); D(1); for (let t = 0; t < 64; t++)D(u[t]); }()), (function (e, t) { z(65472), z(17), D(8), z(t), z(e), D(3), D(1), D(17), D(0), D(2), D(17), D(1), D(3), D(17), D(1); }(e.width, e.height)), (function () { z(65476), z(418), D(0); for (let e = 0; e < 16; e++)D(S[e + 1]); for (let t = 0; t <= 11; t++)D(M[t]); D(16); for (let r = 0; r < 16; r++)D(E[r + 1]); for (let n = 0; n <= 161; n++)D(C[n]); D(1); for (let i = 0; i < 16; i++)D(P[i + 1]); for (let a = 0; a <= 11; a++)D(A[a]); D(17); for (let o = 0; o < 16; o++)D(T[o + 1]); for (let s = 0; s <= 161; s++)D(R[s]); }()), z(65498), z(12), D(3), D(1), D(0), D(2), D(17), D(3), D(17), D(0), D(63), D(0); let h = 0; let f = 0; let d = 0; v = 0, g = 7, this.encode.displayName = '_encode_'; for (var p, k, _, I, j, F, B, U, V, Y = e.data, H = e.width, q = e.height, W = 4 * H, X = 0; X < q;) { for (p = 0; p < W;) { for (F = j = W * X + p, B = -1, U = 0, V = 0; V < 64; V++)F = j + (U = V >> 3) * W + (B = 4 * (7 & V)), X + U >= q && (F -= W * (X + 1 + U - q)), p + B >= W && (F -= p + B - W + 4), k = Y[F++], _ = Y[F++], I = Y[F++], y[V] = (x[k] + x[_ + 256 >> 0] + x[I + 512 >> 0] >> 16) - 128, b[V] = (x[k + 768 >> 0] + x[_ + 1024 >> 0] + x[I + 1280 >> 0] >> 16) - 128, w[V] = (x[k + 1280 >> 0] + x[_ + 1536 >> 0] + x[I + 1792 >> 0] >> 16) - 128; h = N(y, l, h, t, n), f = N(b, c, f, r, i), d = N(w, c, d, r, i), p += 32; }X += 8; } if (g >= 0) { const G = []; G[1] = g + 1, G[0] = (1 << g + 1) - 1, O(G); } return z(65497), Buffer.from(m); }, (function () { (new Date()).getTime(); e || (e = 50), (function () { for (let e = String.fromCharCode, t = 0; t < 256; t++)k[t] = e(t); }()), t = I(S, M), r = I(P, A), n = I(E, C), i = I(T, R), (function () { for (let e = 1, t = 2, r = 1; r <= 15; r++) { for (let n = e; n < t; n++)f[32767 + n] = r, h[32767 + n] = [], h[32767 + n][1] = r, h[32767 + n][0] = n; for (let i = -(t - 1); i <= -e; i++)f[32767 + i] = r, h[32767 + i] = [], h[32767 + i][1] = r, h[32767 + i][0] = t - 1 + i; e <<= 1, t <<= 1; } }()), (function () { for (let e = 0; e < 256; e++)x[e] = 19595 * e, x[e + 256 >> 0] = 38470 * e, x[e + 512 >> 0] = 7471 * e + 32768, x[e + 768 >> 0] = -11059 * e, x[e + 1024 >> 0] = -21709 * e, x[e + 1280 >> 0] = 32768 * e + 8421375, x[e + 1536 >> 0] = -27439 * e, x[e + 1792 >> 0] = -5329 * e; }()), L(e), (new Date()).getTime(); }()); }e.exports = function (e, r) { typeof r === 'undefined' && (r = 50); return { data: new t(r).encode(e, r), width: e.width, height: e.height }; }; },
    28(e) {
      e.exports = (function e(t, r, n) { function i(o, s) { if (!r[o]) { if (!t[o]) { if (a) return a(o, !0); const u = new Error(`Cannot find module '${o}'`); throw u.code = 'MODULE_NOT_FOUND', u; } const l = r[o] = { exports: {} }; t[o][0].call(l.exports, ((e) => { const r = t[o][1][e]; return i(r || e); }), l, l.exports, e, t, r, n); } return r[o].exports; } for (var a = void 0, o = 0; o < n.length; o++)i(n[o]); return i; }({
        1: [function (e, t, r) { let n; let i; let a; let o; let s; const u = function (e, t) { for (const r in t)l.call(t, r) && (e[r] = t[r]); function n() { this.constructor = e; } return n.prototype = t.prototype, e.prototype = new n(), e.__super__ = t.prototype, e; }; var l = {}.hasOwnProperty; n = e('./PriorityQueue/AbstractPriorityQueue'), i = e('./PriorityQueue/ArrayStrategy'), o = e('./PriorityQueue/BinaryHeapStrategy'), a = e('./PriorityQueue/BHeapStrategy'), (s = (function (e) { function t(e) { e || (e = {}), e.strategy || (e.strategy = o), e.comparator || (e.comparator = function (e, t) { return (e || 0) - (t || 0); }), t.__super__.constructor.call(this, e); } return u(t, e), t; }(n))).ArrayStrategy = i, s.BinaryHeapStrategy = o, s.BHeapStrategy = a, t.exports = s; }, {
          './PriorityQueue/AbstractPriorityQueue': 2, './PriorityQueue/ArrayStrategy': 3, './PriorityQueue/BHeapStrategy': 4, './PriorityQueue/BinaryHeapStrategy': 5,
        }],
        2: [function (e, t, r) { t.exports = (function () { function e(e) { let t; if ((e != null ? e.strategy : void 0) == null) throw 'Must pass options.strategy, a strategy'; if ((e != null ? e.comparator : void 0) == null) throw 'Must pass options.comparator, a comparator'; this.priv = new e.strategy(e), this.length = (e != null && (t = e.initialValues) != null ? t.length : void 0) || 0; } return e.prototype.queue = function (e) { this.length++, this.priv.queue(e); }, e.prototype.dequeue = function (e) { if (!this.length) throw 'Empty queue'; return this.length--, this.priv.dequeue(); }, e.prototype.peek = function (e) { if (!this.length) throw 'Empty queue'; return this.priv.peek(); }, e.prototype.clear = function () { return this.length = 0, this.priv.clear(); }, e; }()); }, {}],
        3: [function (e, t, r) { let n; n = function (e, t, r) { let n; let i; let a; for (i = 0, n = e.length; i < n;)r(e[a = i + n >>> 1], t) >= 0 ? i = a + 1 : n = a; return i; }, t.exports = (function () { function e(e) { let t; this.options = e, this.comparator = this.options.comparator, this.data = ((t = this.options.initialValues) != null ? t.slice(0) : void 0) || [], this.data.sort(this.comparator).reverse(); } return e.prototype.queue = function (e) { let t; t = n(this.data, e, this.comparator), this.data.splice(t, 0, e); }, e.prototype.dequeue = function () { return this.data.pop(); }, e.prototype.peek = function () { return this.data[this.data.length - 1]; }, e.prototype.clear = function () { this.data.length = 0; }, e; }()); }, {}],
        4: [function (e, t, r) { t.exports = (function () { function e(e) { let t; let r; let n; let i; let a; let o; let s; let u; for (this.comparator = (e != null ? e.comparator : void 0) || function (e, t) { return e - t; }, this.pageSize = (e != null ? e.pageSize : void 0) || 512, this.length = 0, s = 0; 1 << s < this.pageSize;)s += 1; if (1 << s !== this.pageSize) throw 'pageSize must be a power of two'; for (this._shift = s, this._emptyMemoryPageTemplate = t = [], r = 0, a = this.pageSize; a >= 0 ? r < a : r > a; a >= 0 ? ++r : --r)t.push(null); if (this._memory = [], this._mask = this.pageSize - 1, e.initialValues) for (n = 0, i = (o = e.initialValues).length; n < i; n++)u = o[n], this.queue(u); } return e.prototype.queue = function (e) { this.length += 1, this._write(this.length, e), this._bubbleUp(this.length, e); }, e.prototype.dequeue = function () { let e; let t; return e = this._read(1), t = this._read(this.length), this.length -= 1, this.length > 0 && (this._write(1, t), this._bubbleDown(1, t)), e; }, e.prototype.peek = function () { return this._read(1); }, e.prototype.clear = function () { this.length = 0, this._memory.length = 0; }, e.prototype._write = function (e, t) { let r; for (r = e >> this._shift; r >= this._memory.length;) this._memory.push(this._emptyMemoryPageTemplate.slice(0)); return this._memory[r][e & this._mask] = t; }, e.prototype._read = function (e) { return this._memory[e >> this._shift][e & this._mask]; }, e.prototype._bubbleUp = function (e, t) { let r; let n; let i; let a; for (r = this.comparator; e > 1 && (n = e & this._mask, e < this.pageSize || n > 3 ? i = e & ~this._mask | n >> 1 : n < 2 ? (i = e - this.pageSize >> this._shift, i += i & ~(this._mask >> 1), i |= this.pageSize >> 1) : i = e - 2, !(r(a = this._read(i), t) < 0));) this._write(i, t), this._write(e, a), e = i; }, e.prototype._bubbleDown = function (e, t) { let r; let n; let i; let a; let o; for (o = this.comparator; e < this.length;) if (e > this._mask && !(e & this._mask - 1) ? r = n = e + 2 : e & this.pageSize >> 1 ? (r = (e & ~this._mask) >> 1, n = 1 + (r = 1 + (r |= e & this._mask >> 1) << this._shift)) : n = (r = e + (e & this._mask)) + 1, r !== n && n <= this.length) if (i = this._read(r), a = this._read(n), o(i, t) < 0 && o(i, a) <= 0) this._write(r, t), this._write(e, i), e = r; else { if (!(o(a, t) < 0)) break; this._write(n, t), this._write(e, a), e = n; } else { if (!(r <= this.length)) break; if (!(o(i = this._read(r), t) < 0)) break; this._write(r, t), this._write(e, i), e = r; } }, e; }()); }, {}],
        5: [function (e, t, r) { t.exports = (function () { function e(e) { let t; this.comparator = (e != null ? e.comparator : void 0) || function (e, t) { return e - t; }, this.length = 0, this.data = ((t = e.initialValues) != null ? t.slice(0) : void 0) || [], this._heapify(); } return e.prototype._heapify = function () { let e; let t; let r; if (this.data.length > 0) for (e = t = 1, r = this.data.length; r >= 1 ? t < r : t > r; e = r >= 1 ? ++t : --t) this._bubbleUp(e); }, e.prototype.queue = function (e) { this.data.push(e), this._bubbleUp(this.data.length - 1); }, e.prototype.dequeue = function () { let e; let t; return t = this.data[0], e = this.data.pop(), this.data.length > 0 && (this.data[0] = e, this._bubbleDown(0)), t; }, e.prototype.peek = function () { return this.data[0]; }, e.prototype.clear = function () { this.length = 0, this.data.length = 0; }, e.prototype._bubbleUp = function (e) { for (var t, r; e > 0 && (t = e - 1 >>> 1, this.comparator(this.data[e], this.data[t]) < 0);)r = this.data[t], this.data[t] = this.data[e], this.data[e] = r, e = t; }, e.prototype._bubbleDown = function (e) { let t; let r; let n; let i; let a; for (t = this.data.length - 1; i = 1 + (r = 1 + (e << 1)), n = e, r <= t && this.comparator(this.data[r], this.data[n]) < 0 && (n = r), i <= t && this.comparator(this.data[i], this.data[n]) < 0 && (n = i), n !== e;)a = this.data[n], this.data[n] = this.data[e], this.data[e] = a, e = n; }, e; }()); }, {}],
      }, {}, [1]))(1);
    },
    2428(e) {
      e.exports = (function () {
        function e(e) { return typeof e === 'string' || e instanceof String; } const t = Number.isFinite || window.isFinite; function r(e) { return t(e); } function n(e) { return e; } function i(e) { const t = {}; return e.filter(((e) => !t.hasOwnProperty(e) && (t[e] = !0))); } function a(e, t) { if (t.length !== e.length) return !1; for (let r = 0; r < e.length; r++) { if (t[r].compareArray && !t[r].compareArray(e[r])) return !1; if (t[r] !== e[r]) return !1; } return !0; } function o(e, t) { Object.keys(t).forEach(((r) => { e[r] = t[r]; })); } function s() { for (var e = 1, t = 0, r = 0; r < arguments.length; r++) { const n = arguments[r]; t += c(n), e *= n; } return t !== 0 ? l(e, t) : e; } function u(e, t) { if (t === 0) throw new Error('Divide by zero'); const r = 10 ** c(t); return s(e, r / (r * t)); } function l(e, t) { return Math.round(e * 10 ** t) / 10 ** t; } function c(e) { if (!isFinite(e)) return 0; for (var t = 0; e % 1 !== 0;)e *= 10, t++; return t; } function h() { let e; if (!this) return e = Object.create(h.prototype), h.apply(e, arguments), e; e = Error.apply(this, arguments), this.name = 'QtyError', this.message = e.message, this.stack = e.stack; } function f(e, t) { throw new h(`Incompatible units: ${e} and ${t}`); }h.prototype = Object.create(Error.prototype, { constructor: { value: h } }); const d = {
          '<googol>': [['googol'], 1e100, 'prefix'], '<kibi>': [['Ki', 'Kibi', 'kibi'], 2 ** 10, 'prefix'], '<mebi>': [['Mi', 'Mebi', 'mebi'], 2 ** 20, 'prefix'], '<gibi>': [['Gi', 'Gibi', 'gibi'], 2 ** 30, 'prefix'], '<tebi>': [['Ti', 'Tebi', 'tebi'], 2 ** 40, 'prefix'], '<pebi>': [['Pi', 'Pebi', 'pebi'], 2 ** 50, 'prefix'], '<exi>': [['Ei', 'Exi', 'exi'], 2 ** 60, 'prefix'], '<zebi>': [['Zi', 'Zebi', 'zebi'], 2 ** 70, 'prefix'], '<yebi>': [['Yi', 'Yebi', 'yebi'], 2 ** 80, 'prefix'], '<yotta>': [['Y', 'Yotta', 'yotta'], 1e24, 'prefix'], '<zetta>': [['Z', 'Zetta', 'zetta'], 1e21, 'prefix'], '<exa>': [['E', 'Exa', 'exa'], 1e18, 'prefix'], '<peta>': [['P', 'Peta', 'peta'], 1e15, 'prefix'], '<tera>': [['T', 'Tera', 'tera'], 1e12, 'prefix'], '<giga>': [['G', 'Giga', 'giga'], 1e9, 'prefix'], '<mega>': [['M', 'Mega', 'mega'], 1e6, 'prefix'], '<kilo>': [['k', 'kilo'], 1e3, 'prefix'], '<hecto>': [['h', 'Hecto', 'hecto'], 100, 'prefix'], '<deca>': [['da', 'Deca', 'deca', 'deka'], 10, 'prefix'], '<deci>': [['d', 'Deci', 'deci'], 0.1, 'prefix'], '<centi>': [['c', 'Centi', 'centi'], 0.01, 'prefix'], '<milli>': [['m', 'Milli', 'milli'], 0.001, 'prefix'], '<micro>': [['u', '\u03bc', '\xb5', 'Micro', 'mc', 'micro'], 1e-6, 'prefix'], '<nano>': [['n', 'Nano', 'nano'], 1e-9, 'prefix'], '<pico>': [['p', 'Pico', 'pico'], 1e-12, 'prefix'], '<femto>': [['f', 'Femto', 'femto'], 1e-15, 'prefix'], '<atto>': [['a', 'Atto', 'atto'], 1e-18, 'prefix'], '<zepto>': [['z', 'Zepto', 'zepto'], 1e-21, 'prefix'], '<yocto>': [['y', 'Yocto', 'yocto'], 1e-24, 'prefix'], '<1>': [['1', '<1>'], 1, ''], '<meter>': [['m', 'meter', 'meters', 'metre', 'metres'], 1, 'length', ['<meter>']], '<inch>': [['in', 'inch', 'inches', '"'], 0.0254, 'length', ['<meter>']], '<foot>': [['ft', 'foot', 'feet', "'"], 0.3048, 'length', ['<meter>']], '<yard>': [['yd', 'yard', 'yards'], 0.9144, 'length', ['<meter>']], '<mile>': [['mi', 'mile', 'miles'], 1609.344, 'length', ['<meter>']], '<naut-mile>': [['nmi', 'naut-mile'], 1852, 'length', ['<meter>']], '<league>': [['league', 'leagues'], 4828, 'length', ['<meter>']], '<furlong>': [['furlong', 'furlongs'], 201.2, 'length', ['<meter>']], '<rod>': [['rd', 'rod', 'rods'], 5.029, 'length', ['<meter>']], '<mil>': [['mil', 'mils'], 254e-7, 'length', ['<meter>']], '<angstrom>': [['ang', 'angstrom', 'angstroms'], 1e-10, 'length', ['<meter>']], '<fathom>': [['fathom', 'fathoms'], 1.829, 'length', ['<meter>']], '<pica>': [['pica', 'picas'], 0.00423333333, 'length', ['<meter>']], '<point>': [['pt', 'point', 'points'], 0.000352777778, 'length', ['<meter>']], '<redshift>': [['z', 'red-shift', 'redshift'], 1302773e20, 'length', ['<meter>']], '<AU>': [['AU', 'astronomical-unit'], 1495979e5, 'length', ['<meter>']], '<light-second>': [['ls', 'light-second'], 299792500, 'length', ['<meter>']], '<light-minute>': [['lmin', 'light-minute'], 1798755e4, 'length', ['<meter>']], '<light-year>': [['ly', 'light-year'], 9460528e9, 'length', ['<meter>']], '<parsec>': [['pc', 'parsec', 'parsecs'], 3085678e10, 'length', ['<meter>']], '<datamile>': [['DM', 'datamile'], 1828.8, 'length', ['<meter>']], '<kilogram>': [['kg', 'kilogram', 'kilograms'], 1, 'mass', ['<kilogram>']], '<AMU>': [['u', 'AMU', 'amu'], 1660538921e-36, 'mass', ['<kilogram>']], '<dalton>': [['Da', 'Dalton', 'Daltons', 'dalton', 'daltons'], 1660538921e-36, 'mass', ['<kilogram>']], '<slug>': [['slug', 'slugs'], 14.5939029, 'mass', ['<kilogram>']], '<short-ton>': [['tn', 'ton', 'short-ton'], 907.18474, 'mass', ['<kilogram>']], '<metric-ton>': [['t', 'tonne', 'metric-ton'], 1e3, 'mass', ['<kilogram>']], '<carat>': [['ct', 'carat', 'carats'], 2e-4, 'mass', ['<kilogram>']], '<pound>': [['lbs', 'lb', 'pound', 'pounds', '#'], 0.45359237, 'mass', ['<kilogram>']], '<ounce>': [['oz', 'ounce', 'ounces'], 0.0283495231, 'mass', ['<kilogram>']], '<gram>': [['g', 'gram', 'grams', 'gramme', 'grammes'], 0.001, 'mass', ['<kilogram>']], '<grain>': [['grain', 'grains', 'gr'], 6479891e-11, 'mass', ['<kilogram>']], '<dram>': [['dram', 'drams', 'dr'], 0.0017718452, 'mass', ['<kilogram>']], '<stone>': [['stone', 'stones', 'st'], 6.35029318, 'mass', ['<kilogram>']], '<hectare>': [['hectare'], 1e4, 'area', ['<meter>', '<meter>']], '<acre>': [['acre', 'acres'], 4046.85642, 'area', ['<meter>', '<meter>']], '<sqft>': [['sqft'], 1, 'area', ['<foot>', '<foot>']], '<liter>': [['l', 'L', 'liter', 'liters', 'litre', 'litres'], 0.001, 'volume', ['<meter>', '<meter>', '<meter>']], '<gallon>': [['gal', 'gallon', 'gallons'], 0.0037854118, 'volume', ['<meter>', '<meter>', '<meter>']], '<gallon-imp>': [['galimp', 'gallon-imp', 'gallons-imp'], 0.00454609, 'volume', ['<meter>', '<meter>', '<meter>']], '<quart>': [['qt', 'quart', 'quarts'], 0.00094635295, 'volume', ['<meter>', '<meter>', '<meter>']], '<pint>': [['pt', 'pint', 'pints'], 0.000473176475, 'volume', ['<meter>', '<meter>', '<meter>']], '<pint-imp>': [['ptimp', 'pint-imp', 'pints-imp'], 0.00056826125, 'volume', ['<meter>', '<meter>', '<meter>']], '<cup>': [['cu', 'cup', 'cups'], 0.000236588238, 'volume', ['<meter>', '<meter>', '<meter>']], '<fluid-ounce>': [['floz', 'fluid-ounce', 'fluid-ounces'], 295735297e-13, 'volume', ['<meter>', '<meter>', '<meter>']], '<fluid-ounce-imp>': [['flozimp', 'floz-imp', 'fluid-ounce-imp', 'fluid-ounces-imp'], 284130625e-13, 'volume', ['<meter>', '<meter>', '<meter>']], '<tablespoon>': [['tb', 'tbsp', 'tbs', 'tablespoon', 'tablespoons'], 147867648e-13, 'volume', ['<meter>', '<meter>', '<meter>']], '<teaspoon>': [['tsp', 'teaspoon', 'teaspoons'], 492892161e-14, 'volume', ['<meter>', '<meter>', '<meter>']], '<bushel>': [['bu', 'bsh', 'bushel', 'bushels'], 0.035239072, 'volume', ['<meter>', '<meter>', '<meter>']], '<oilbarrel>': [['bbl', 'oilbarrel', 'oilbarrels', 'oil-barrel', 'oil-barrels'], 0.158987294928, 'volume', ['<meter>', '<meter>', '<meter>']], '<beerbarrel>': [['bl', 'bl-us', 'beerbarrel', 'beerbarrels', 'beer-barrel', 'beer-barrels'], 0.1173477658, 'volume', ['<meter>', '<meter>', '<meter>']], '<beerbarrel-imp>': [['blimp', 'bl-imp', 'beerbarrel-imp', 'beerbarrels-imp', 'beer-barrel-imp', 'beer-barrels-imp'], 0.16365924, 'volume', ['<meter>', '<meter>', '<meter>']], '<kph>': [['kph'], 0.277777778, 'speed', ['<meter>'], ['<second>']], '<mph>': [['mph'], 0.44704, 'speed', ['<meter>'], ['<second>']], '<knot>': [['kt', 'kn', 'kts', 'knot', 'knots'], 0.514444444, 'speed', ['<meter>'], ['<second>']], '<fps>': [['fps'], 0.3048, 'speed', ['<meter>'], ['<second>']], '<gee>': [['gee'], 9.80665, 'acceleration', ['<meter>'], ['<second>', '<second>']], '<Gal>': [['Gal'], 0.01, 'acceleration', ['<meter>'], ['<second>', '<second>']], '<kelvin>': [['degK', 'kelvin'], 1, 'temperature', ['<kelvin>']], '<celsius>': [['degC', 'celsius', 'celsius', 'centigrade'], 1, 'temperature', ['<kelvin>']], '<fahrenheit>': [['degF', 'fahrenheit'], 5 / 9, 'temperature', ['<kelvin>']], '<rankine>': [['degR', 'rankine'], 5 / 9, 'temperature', ['<kelvin>']], '<temp-K>': [['tempK', 'temp-K'], 1, 'temperature', ['<temp-K>']], '<temp-C>': [['tempC', 'temp-C'], 1, 'temperature', ['<temp-K>']], '<temp-F>': [['tempF', 'temp-F'], 5 / 9, 'temperature', ['<temp-K>']], '<temp-R>': [['tempR', 'temp-R'], 5 / 9, 'temperature', ['<temp-K>']], '<second>': [['s', 'sec', 'secs', 'second', 'seconds'], 1, 'time', ['<second>']], '<minute>': [['min', 'mins', 'minute', 'minutes'], 60, 'time', ['<second>']], '<hour>': [['h', 'hr', 'hrs', 'hour', 'hours'], 3600, 'time', ['<second>']], '<day>': [['d', 'day', 'days'], 86400, 'time', ['<second>']], '<week>': [['wk', 'week', 'weeks'], 604800, 'time', ['<second>']], '<fortnight>': [['fortnight', 'fortnights'], 1209600, 'time', ['<second>']], '<year>': [['y', 'yr', 'year', 'years', 'annum'], 31556926, 'time', ['<second>']], '<decade>': [['decade', 'decades'], 315569260, 'time', ['<second>']], '<century>': [['century', 'centuries'], 3155692600, 'time', ['<second>']], '<pascal>': [['Pa', 'pascal', 'Pascal'], 1, 'pressure', ['<kilogram>'], ['<meter>', '<second>', '<second>']], '<bar>': [['bar', 'bars'], 1e5, 'pressure', ['<kilogram>'], ['<meter>', '<second>', '<second>']], '<mmHg>': [['mmHg'], 133.322368, 'pressure', ['<kilogram>'], ['<meter>', '<second>', '<second>']], '<inHg>': [['inHg'], 3386.3881472, 'pressure', ['<kilogram>'], ['<meter>', '<second>', '<second>']], '<torr>': [['torr'], 133.322368, 'pressure', ['<kilogram>'], ['<meter>', '<second>', '<second>']], '<atm>': [['atm', 'ATM', 'atmosphere', 'atmospheres'], 101325, 'pressure', ['<kilogram>'], ['<meter>', '<second>', '<second>']], '<psi>': [['psi'], 6894.76, 'pressure', ['<kilogram>'], ['<meter>', '<second>', '<second>']], '<cmh2o>': [['cmH2O', 'cmh2o'], 98.0638, 'pressure', ['<kilogram>'], ['<meter>', '<second>', '<second>']], '<inh2o>': [['inH2O', 'inh2o'], 249.082052, 'pressure', ['<kilogram>'], ['<meter>', '<second>', '<second>']], '<poise>': [['P', 'poise'], 0.1, 'viscosity', ['<kilogram>'], ['<meter>', '<second>']], '<stokes>': [['St', 'stokes'], 1e-4, 'viscosity', ['<meter>', '<meter>'], ['<second>']], '<mole>': [['mol', 'mole'], 1, 'substance', ['<mole>']], '<molar>': [['M', 'molar'], 1e3, 'molar_concentration', ['<mole>'], ['<meter>', '<meter>', '<meter>']], '<wtpercent>': [['wt%', 'wtpercent'], 10, 'molar_concentration', ['<kilogram>'], ['<meter>', '<meter>', '<meter>']], '<katal>': [['kat', 'katal', 'Katal'], 1, 'activity', ['<mole>'], ['<second>']], '<unit>': [['U', 'enzUnit', 'unit'], 16667e-19, 'activity', ['<mole>'], ['<second>']], '<farad>': [['F', 'farad', 'Farad'], 1, 'capacitance', ['<second>', '<second>', '<second>', '<second>', '<ampere>', '<ampere>'], ['<meter>', '<meter>', '<kilogram>']], '<coulomb>': [['C', 'coulomb', 'Coulomb'], 1, 'charge', ['<ampere>', '<second>']], '<Ah>': [['Ah'], 3600, 'charge', ['<ampere>', '<second>']], '<ampere>': [['A', 'Ampere', 'ampere', 'amp', 'amps'], 1, 'current', ['<ampere>']], '<siemens>': [['S', 'Siemens', 'siemens'], 1, 'conductance', ['<second>', '<second>', '<second>', '<ampere>', '<ampere>'], ['<kilogram>', '<meter>', '<meter>']], '<henry>': [['H', 'Henry', 'henry'], 1, 'inductance', ['<meter>', '<meter>', '<kilogram>'], ['<second>', '<second>', '<ampere>', '<ampere>']], '<volt>': [['V', 'Volt', 'volt', 'volts'], 1, 'potential', ['<meter>', '<meter>', '<kilogram>'], ['<second>', '<second>', '<second>', '<ampere>']], '<ohm>': [['Ohm', 'ohm', '\u03a9', '\u2126'], 1, 'resistance', ['<meter>', '<meter>', '<kilogram>'], ['<second>', '<second>', '<second>', '<ampere>', '<ampere>']], '<weber>': [['Wb', 'weber', 'webers'], 1, 'magnetism', ['<meter>', '<meter>', '<kilogram>'], ['<second>', '<second>', '<ampere>']], '<tesla>': [['T', 'tesla', 'teslas'], 1, 'magnetism', ['<kilogram>'], ['<second>', '<second>', '<ampere>']], '<gauss>': [['G', 'gauss'], 1e-4, 'magnetism', ['<kilogram>'], ['<second>', '<second>', '<ampere>']], '<maxwell>': [['Mx', 'maxwell', 'maxwells'], 1e-8, 'magnetism', ['<meter>', '<meter>', '<kilogram>'], ['<second>', '<second>', '<ampere>']], '<oersted>': [['Oe', 'oersted', 'oersteds'], 250 / Math.PI, 'magnetism', ['<ampere>'], ['<meter>']], '<joule>': [['J', 'joule', 'Joule', 'joules', 'Joules'], 1, 'energy', ['<meter>', '<meter>', '<kilogram>'], ['<second>', '<second>']], '<erg>': [['erg', 'ergs'], 1e-7, 'energy', ['<meter>', '<meter>', '<kilogram>'], ['<second>', '<second>']], '<btu>': [['BTU', 'btu', 'BTUs'], 1055.056, 'energy', ['<meter>', '<meter>', '<kilogram>'], ['<second>', '<second>']], '<calorie>': [['cal', 'calorie', 'calories'], 4.184, 'energy', ['<meter>', '<meter>', '<kilogram>'], ['<second>', '<second>']], '<Calorie>': [['Cal', 'Calorie', 'Calories'], 4184, 'energy', ['<meter>', '<meter>', '<kilogram>'], ['<second>', '<second>']], '<therm-US>': [['th', 'therm', 'therms', 'Therm', 'therm-US'], 105480400, 'energy', ['<meter>', '<meter>', '<kilogram>'], ['<second>', '<second>']], '<Wh>': [['Wh'], 3600, 'energy', ['<meter>', '<meter>', '<kilogram>'], ['<second>', '<second>']], '<electronvolt>': [['eV', 'electronvolt', 'electronvolts'], 1602176634e-28, 'energy', ['<meter>', '<meter>', '<kilogram>'], ['<second>', '<second>']], '<newton>': [['N', 'Newton', 'newton'], 1, 'force', ['<kilogram>', '<meter>'], ['<second>', '<second>']], '<dyne>': [['dyn', 'dyne'], 1e-5, 'force', ['<kilogram>', '<meter>'], ['<second>', '<second>']], '<pound-force>': [['lbf', 'pound-force'], 4.448222, 'force', ['<kilogram>', '<meter>'], ['<second>', '<second>']], '<hertz>': [['Hz', 'hertz', 'Hertz'], 1, 'frequency', ['<1>'], ['<second>']], '<radian>': [['rad', 'radian', 'radians'], 1, 'angle', ['<radian>']], '<degree>': [['deg', 'degree', 'degrees'], Math.PI / 180, 'angle', ['<radian>']], '<arcminute>': [['arcmin', 'arcminute', 'arcminutes'], Math.PI / 10800, 'angle', ['<radian>']], '<arcsecond>': [['arcsec', 'arcsecond', 'arcseconds'], Math.PI / 648e3, 'angle', ['<radian>']], '<gradian>': [['gon', 'grad', 'gradian', 'grads'], Math.PI / 200, 'angle', ['<radian>']], '<steradian>': [['sr', 'steradian', 'steradians'], 1, 'solid_angle', ['<steradian>']], '<rotation>': [['rotation'], 2 * Math.PI, 'angle', ['<radian>']], '<rpm>': [['rpm'], 2 * Math.PI / 60, 'angular_velocity', ['<radian>'], ['<second>']], '<byte>': [['B', 'byte', 'bytes'], 1, 'information', ['<byte>']], '<bit>': [['b', 'bit', 'bits'], 0.125, 'information', ['<byte>']], '<Bps>': [['Bps'], 1, 'information_rate', ['<byte>'], ['<second>']], '<bps>': [['bps'], 0.125, 'information_rate', ['<byte>'], ['<second>']], '<dollar>': [['USD', 'dollar'], 1, 'currency', ['<dollar>']], '<cents>': [['cents'], 0.01, 'currency', ['<dollar>']], '<candela>': [['cd', 'candela'], 1, 'luminosity', ['<candela>']], '<lumen>': [['lm', 'lumen'], 1, 'luminous_power', ['<candela>', '<steradian>']], '<lux>': [['lux'], 1, 'illuminance', ['<candela>', '<steradian>'], ['<meter>', '<meter>']], '<watt>': [['W', 'watt', 'watts'], 1, 'power', ['<kilogram>', '<meter>', '<meter>'], ['<second>', '<second>', '<second>']], '<volt-ampere>': [['VA', 'volt-ampere'], 1, 'power', ['<kilogram>', '<meter>', '<meter>'], ['<second>', '<second>', '<second>']], '<volt-ampere-reactive>': [['var', 'Var', 'VAr', 'VAR', 'volt-ampere-reactive'], 1, 'power', ['<kilogram>', '<meter>', '<meter>'], ['<second>', '<second>', '<second>']], '<horsepower>': [['hp', 'horsepower'], 745.699872, 'power', ['<kilogram>', '<meter>', '<meter>'], ['<second>', '<second>', '<second>']], '<gray>': [['Gy', 'gray', 'grays'], 1, 'radiation', ['<meter>', '<meter>'], ['<second>', '<second>']], '<roentgen>': [['R', 'roentgen'], 0.00933, 'radiation', ['<meter>', '<meter>'], ['<second>', '<second>']], '<sievert>': [['Sv', 'sievert', 'sieverts'], 1, 'radiation', ['<meter>', '<meter>'], ['<second>', '<second>']], '<becquerel>': [['Bq', 'becquerel', 'becquerels'], 1, 'radiation', ['<1>'], ['<second>']], '<curie>': [['Ci', 'curie', 'curies'], 37e9, 'radiation', ['<1>'], ['<second>']], '<cpm>': [['cpm'], 1 / 60, 'rate', ['<count>'], ['<second>']], '<dpm>': [['dpm'], 1 / 60, 'rate', ['<count>'], ['<second>']], '<bpm>': [['bpm'], 1 / 60, 'rate', ['<count>'], ['<second>']], '<dot>': [['dot', 'dots'], 1, 'resolution', ['<each>']], '<pixel>': [['pixel', 'px'], 1, 'resolution', ['<each>']], '<ppi>': [['ppi'], 1, 'resolution', ['<pixel>'], ['<inch>']], '<dpi>': [['dpi'], 1, 'typography', ['<dot>'], ['<inch>']], '<cell>': [['cells', 'cell'], 1, 'counting', ['<each>']], '<each>': [['each'], 1, 'counting', ['<each>']], '<count>': [['count'], 1, 'counting', ['<each>']], '<base-pair>': [['bp', 'base-pair'], 1, 'counting', ['<each>']], '<nucleotide>': [['nt', 'nucleotide'], 1, 'counting', ['<each>']], '<molecule>': [['molecule', 'molecules'], 1, 'counting', ['<1>']], '<dozen>': [['doz', 'dz', 'dozen'], 12, 'prefix_only', ['<each>']], '<percent>': [['%', 'percent'], 0.01, 'prefix_only', ['<1>']], '<ppm>': [['ppm'], 1e-6, 'prefix_only', ['<1>']], '<ppb>': [['ppb'], 1e-9, 'prefix_only', ['<1>']], '<ppt>': [['ppt'], 1e-12, 'prefix_only', ['<1>']], '<ppq>': [['ppq'], 1e-15, 'prefix_only', ['<1>']], '<gross>': [['gr', 'gross'], 144, 'prefix_only', ['<dozen>', '<dozen>']], '<decibel>': [['dB', 'decibel', 'decibels'], 1, 'logarithmic', ['<decibel>']],
        }; const p = ['<meter>', '<kilogram>', '<second>', '<mole>', '<ampere>', '<radian>', '<kelvin>', '<temp-K>', '<byte>', '<dollar>', '<candela>', '<each>', '<steradian>', '<decibel>']; const m = '<1>'; const v = [m]; function g(e, t) { const n = t[1]; const i = t[3] || []; const a = t[4] || []; if (!r(n)) throw new h(`${e}: Invalid unit definition. 'scalar' must be a number`); i.forEach(((t) => { if (void 0 === d[t]) throw new h(`${e}: Invalid unit definition. Unit ${t} in 'numerator' is not recognized`); })), a.forEach(((t) => { if (void 0 === d[t]) throw new h(`${e}: Invalid unit definition. Unit ${t} in 'denominator' is not recognized`); })); } const y = {}; const b = {}; const w = {}; const k = {}; const x = {}; for (const _ in d) if (d.hasOwnProperty(_)) { const S = d[_]; if (S[2] === 'prefix') { y[_] = S[1]; for (let M = 0; M < S[0].length; M++)b[S[0][M]] = _; } else { g(_, S), w[_] = { scalar: S[1], numerator: S[3], denominator: S[4] }; for (let E = 0; E < S[0].length; E++)k[S[0][E]] = _; }x[_] = S[0][0]; } function C(e) { let t; const r = []; const n = Object.keys(d); if (typeof e === 'undefined') for (t = 0; t < n.length; t++)['', 'prefix'].indexOf(d[n[t]][2]) === -1 && r.push(n[t].substr(1, n[t].length - 2)); else { if (this.getKinds().indexOf(e) === -1) throw new h('Kind not recognized'); for (t = 0; t < n.length; t++)d[n[t]][2] === e && r.push(n[t].substr(1, n[t].length - 2)); } return r.sort(((e, t) => (e.toLowerCase() < t.toLowerCase() ? -1 : e.toLowerCase() > t.toLowerCase() ? 1 : 0))); } function P(e) { if (!k[e]) throw new h('Unit not recognized'); return d[k[e]][0]; } const A = ['length', 'time', 'temperature', 'mass', 'current', 'substance', 'luminosity', 'currency', 'information', 'angle']; function T() { if (this.signature) return this.signature; for (var e = R.call(this), t = 0; t < e.length; t++)e[t] *= 20 ** t; return e.reduce(((e, t) => e + t), 0); } function R() { if (!this.isBase()) return R.call(this.toBase()); for (var e, t, r = new Array(A.length), n = 0; n < r.length; n++)r[n] = 0; for (let i = 0; i < this.numerator.length; i++)(e = d[this.numerator[i]]) && (t = A.indexOf(e[2])) >= 0 && (r[t] = r[t] + 1); for (let a = 0; a < this.denominator.length; a++)(e = d[this.denominator[a]]) && (t = A.indexOf(e[2])) >= 0 && (r[t] = r[t] - 1); return r; } const I = '[+-]'; const O = '\\d+'; const D = `\\.${O}`; const z = new RegExp(`^(${I}?\\s*(?:(?:${O}(?:${D})?)|(?:${D}))(?:[Ee]${I}?${O})?)?\\s*([^/]*)(?:/(.+))?$`); const N = '\\^|\\*{2}'; const L = '[01234]'; const j = new RegExp(`([^ \\*\\d]+?)(?:${N})?(-?${L}(?![a-zA-Z]))`); const F = new RegExp(`([^ \\*\\d]+?)(?:${N})?(${L}(?![a-zA-Z]))`); function B(t) { e(t) || (t = t.toString()), t = t.trim(); let r = z.exec(t); if (!r) throw new h(`${t}: Quantity not recognized`); let n = r[1]; n ? (n = n.replace(/\s/g, ''), this.scalar = parseFloat(n)) : this.scalar = 1; for (var i, a, o, s = r[2], u = r[3]; r = j.exec(s);) { if (i = parseFloat(r[2]), isNaN(i)) throw new h('Unit exponent is not a number'); if (i === 0 && !H.test(r[1])) throw new h('Unit not recognized'); a = `${r[1]} `, o = ''; for (let l = 0; l < Math.abs(i); l++)o += a; i >= 0 ? s = s.replace(r[0], o) : (u = u ? u + o : o, s = s.replace(r[0], '')); } for (;r = F.exec(u);) { if (i = parseFloat(r[2]), isNaN(i)) throw new h('Unit exponent is not a number'); if (i === 0 && !H.test(r[1])) throw new h('Unit not recognized'); a = `${r[1]} `, o = ''; for (let c = 0; c < i; c++)o += a; u = u.replace(r[0], o); }s && (this.numerator = X(s.trim())), u && (this.denominator = X(u.trim())); } const U = Object.keys(b).sort(((e, t) => t.length - e.length)).join('|'); const V = Object.keys(k).sort(((e, t) => t.length - e.length)).join('|'); const Y = `(${U})??(${V})(?:\\b|$)`; var H = new RegExp(`^\\s*(${Y}[\\s\\*]*)+$`); const q = new RegExp(Y, 'g'); const W = {}; function X(e) { const t = W[e]; if (t) return t; let r; let n = []; if (!H.test(e)) throw new h('Unit not recognized'); for (;r = q.exec(e);)n.push(r.slice(1)); return n = (n = (n = n.map(((e) => (b[e[0]] ? [b[e[0]], k[e[1]]] : [k[e[1]]])))).reduce(((e, t) => e.concat(t)), [])).filter(((e) => e)), W[e] = n, n; } function G(t) { if (!e(t)) throw new h('Argument should be a string'); try { return this(t); } catch (r) { return null; } } function $(e) { return e instanceof Z; } function Z(e, t) { if (K.apply(null, arguments), !$(this)) return new Z(e, t); if (this.scalar = null, this.baseScalar = null, this.signature = null, this._conversionCache = {}, this.numerator = v, this.denominator = v, Q(e) ? (this.scalar = e.scalar, this.numerator = e.numerator && e.numerator.length !== 0 ? e.numerator : v, this.denominator = e.denominator && e.denominator.length !== 0 ? e.denominator : v) : t ? (B.call(this, t), this.scalar = e) : B.call(this, e), this.denominator.join('*').indexOf('temp') >= 0) throw new h('Cannot divide with temperatures'); if (this.numerator.join('*').indexOf('temp') >= 0) { if (this.numerator.length > 1) throw new h('Cannot multiply by temperatures'); if (!a(this.denominator, v)) throw new h('Cannot divide with temperatures'); } if (this.initValue = e, J.call(this), this.isTemperature() && this.baseScalar < 0) throw new h('Temperatures must not be less than absolute zero'); } function K(t, n) { if (n) { if (!r(t) || !e(n)) throw new h('Only number accepted as initialization value when units are explicitly provided'); } else if (!(e(t) || r(t) || $(t) || Q(t))) throw new h('Only string, number or quantity accepted as single initialization value'); } function Q(e) { return e && typeof e === 'object' && e.hasOwnProperty('scalar'); } function J() { if (this.baseScalar) return this.baseScalar; if (this.isBase()) this.baseScalar = this.scalar, this.signature = T.call(this); else { const e = this.toBase(); this.baseScalar = e.scalar, this.signature = e.signature; } }Z.prototype = { constructor: Z }; const ee = {
          '-312078': 'elastance', '-312058': 'resistance', '-312038': 'inductance', '-152058': 'potential', '-152040': 'magnetism', '-152038': 'magnetism', '-7997': 'specific_volume', '-79': 'snap', '-59': 'jolt', '-39': 'acceleration', '-38': 'radiation', '-20': 'frequency', '-19': 'speed', '-18': 'viscosity', '-17': 'volumetric_flow', '-1': 'wavenumber', 0: 'unitless', 1: 'length', 2: 'area', 3: 'volume', 20: 'time', 400: 'temperature', 7941: 'yank', 7942: 'power', 7959: 'pressure', 7961: 'force', 7962: 'energy', 7979: 'viscosity', 7981: 'momentum', 7982: 'angular_momentum', 7997: 'density', 7998: 'area_density', 8e3: 'mass', 152020: 'radiation_exposure', 159999: 'magnetism', 16e4: 'current', 160020: 'charge', 312058: 'conductance', 312078: 'capacitance', 3199980: 'activity', 3199997: 'molar_concentration', 32e5: 'substance', 63999998: 'illuminance', 64e6: 'luminous_power', 128e7: 'currency', 25599999980: 'information_rate', 256e8: 'information', 511999999980: 'angular_velocity', 512e9: 'angle',
        }; function te() { return i(Object.keys(ee).map(((e) => ee[e]))); } function re(e, t) { const r = e.units(); const n = t.to(r); const i = Z(ae(r)); return Z({ scalar: e.scalar - n.scalar, numerator: i.numerator, denominator: i.denominator }); } function ne(e, t) { const r = t.to(ae(e.units())); return Z({ scalar: e.scalar - r.scalar, numerator: e.numerator, denominator: e.denominator }); } function ie(e, t) { const r = t.to(ae(e.units())); return Z({ scalar: e.scalar + r.scalar, numerator: e.numerator, denominator: e.denominator }); } function ae(e) { if (e === 'tempK') return 'degK'; if (e === 'tempC') return 'degC'; if (e === 'tempF') return 'degF'; if (e === 'tempR') return 'degR'; throw new h(`Unknown type for temp conversion from: ${e}`); } function oe(e, t) { let r; const n = se(e); const i = t.units(); if (i === 'degK')r = n.scalar; else if (i === 'degC')r = n.scalar; else if (i === 'degF')r = 9 * n.scalar / 5; else { if (i !== 'degR') throw new h(`Unknown type for degree conversion to: ${i}`); r = 9 * n.scalar / 5; } return Z({ scalar: r, numerator: t.numerator, denominator: t.denominator }); } function se(e) { let t; const r = e.units(); if (r.match(/(deg)[CFRK]/))t = e.baseScalar; else if (r === 'tempK')t = e.scalar; else if (r === 'tempC')t = e.scalar; else if (r === 'tempF')t = 5 * e.scalar / 9; else { if (r !== 'tempR') throw new h(`Unknown type for temp conversion from: ${r}`); t = 5 * e.scalar / 9; } return Z({ scalar: t, numerator: ['<kelvin>'], denominator: v }); } function ue(e, t) { let r; const n = t.units(); if (n === 'tempK')r = e.baseScalar; else if (n === 'tempC')r = e.baseScalar - 273.15; else if (n === 'tempF')r = 9 * e.baseScalar / 5 - 459.67; else { if (n !== 'tempR') throw new h(`Unknown type for temp conversion to: ${n}`); r = 9 * e.baseScalar / 5; } return Z({ scalar: r, numerator: t.numerator, denominator: t.denominator }); } function le(e) { let t; const r = e.units(); if (r.match(/(deg)[CFRK]/))t = e.baseScalar; else if (r === 'tempK')t = e.scalar; else if (r === 'tempC')t = e.scalar + 273.15; else if (r === 'tempF')t = 5 * (e.scalar + 459.67) / 9; else { if (r !== 'tempR') throw new h(`Unknown type for temp conversion from: ${r}`); t = 5 * e.scalar / 9; } return Z({ scalar: t, numerator: ['<temp-K>'], denominator: v }); } function ce(e, t) { let r; const i = Z(e); const a = Z(t); return i.eq(a) ? n : (r = i.isTemperature() ? function (e) { return i.mul(e).to(a).scalar; } : function (e) { return e * i.baseScalar / a.baseScalar; }, function (e) { let t; let n; let i; if (Array.isArray(e)) { for (n = e.length, i = [], t = 0; t < n; t++)i.push(r(e[t])); return i; } return r(e); }); }Z.prototype.kind = function () { return ee[this.signature.toString()]; }, o(Z.prototype, { isDegrees() { return (this.signature === null || this.signature === 400) && this.numerator.length === 1 && a(this.denominator, v) && (this.numerator[0].match(/<temp-[CFRK]>/) || this.numerator[0].match(/<(kelvin|celsius|rankine|fahrenheit)>/)); }, isTemperature() { return this.isDegrees() && this.numerator[0].match(/<temp-[CFRK]>/); } }), o(Z.prototype, {
          to(t) { let r; let n; return void 0 === t || t === null ? this : e(t) ? (r = this._conversionCache[t]) ? r : (n = Z(t)).units() === this.units() ? this : (this.isCompatible(n) ? n = n.isTemperature() ? ue(this, n) : n.isDegrees() ? oe(this, n) : Z({ scalar: u(this.baseScalar, n.baseScalar), numerator: n.numerator, denominator: n.denominator }) : this.isInverse(n) ? n = this.inverse().to(t) : f(this.units(), n.units()), this._conversionCache[t] = n, n) : this.to(t.units()); }, toBase() { if (this.isBase()) return this; if (this.isTemperature()) return le(this); let e = he[this.units()]; return e || (e = fe(this.numerator, this.denominator), he[this.units()] = e), e.mul(this.scalar); }, toFloat() { if (this.isUnitless()) return this.scalar; throw new h("Can't convert to Float unless unitless.  Use Unit#scalar"); }, toPrec(t) { if (e(t) && (t = Z(t)), r(t) && (t = Z(`${t} ${this.units()}`)), this.isUnitless() ? t.isUnitless() || f(this.units(), t.units()) : t = t.to(this.units()), t.scalar === 0) throw new h('Divide by zero'); return Z(s(Math.round(this.scalar / t.scalar), t.scalar) + this.units()); },
        }); var he = {}; function fe(e, t) { for (var r, n = [], i = [], a = 1, o = 0; o < e.length; o++)r = e[o], y[r] ? a = s(a, y[r]) : w[r] && (a *= w[r].scalar, w[r].numerator && n.push(w[r].numerator), w[r].denominator && i.push(w[r].denominator)); for (let u = 0; u < t.length; u++)r = t[u], y[r] ? a /= y[r] : w[r] && (a /= w[r].scalar, w[r].numerator && i.push(w[r].numerator), w[r].denominator && n.push(w[r].denominator)); return Z({ scalar: a, numerator: n = n.reduce(((e, t) => e.concat(t)), []), denominator: i = i.reduce(((e, t) => e.concat(t)), []) }); } function de(e, t, r, n) { function i(e) { return e !== m; }e = e.filter(i), r = r.filter(i), t = t.filter(i), n = n.filter(i); const a = {}; function o(e, t) { for (var r, n, i, o = 0; o < e.length; o++) if (y[e[o]] ? (r = e[o + 1], n = e[o], i = y[n], o++) : (r = e[o], n = null, i = 1), r && r !== m) if (a[r]) { a[r][0] += t; const s = a[r][2] ? y[a[r][2]] : 1; a[r][t === 1 ? 3 : 4] *= u(i, s); } else a[r] = [t, r, n, 1, 1]; }o(e, 1), o(t, -1), o(r, 1), o(n, -1); let s = []; let l = []; let c = 1; for (const h in a) if (a.hasOwnProperty(h)) { var f; const d = a[h]; if (d[0] > 0) for (f = 0; f < d[0]; f++)s.push(d[2] === null ? d[1] : [d[2], d[1]]); else if (d[0] < 0) for (f = 0; f < -d[0]; f++)l.push(d[2] === null ? d[1] : [d[2], d[1]]); c *= u(d[3], d[4]); } return s.length === 0 && (s = v), l.length === 0 && (l = v), [s = s.reduce(((e, t) => e.concat(t)), []), l = l.reduce(((e, t) => e.concat(t)), []), c]; } function pe() {} function me(e, t) { return (`${e} ${t}`).trim(); }Z.parse = G, Z.getUnits = C, Z.getAliases = P, Z.mulSafe = s, Z.divSafe = u, Z.getKinds = te, Z.swiftConverter = ce, Z.Error = h, o(Z.prototype, {
          add(t) { if (e(t) && (t = Z(t)), this.isCompatible(t) || f(this.units(), t.units()), this.isTemperature() && t.isTemperature()) throw new h('Cannot add two temperatures'); return this.isTemperature() ? ie(this, t) : t.isTemperature() ? ie(t, this) : Z({ scalar: this.scalar + t.to(this).scalar, numerator: this.numerator, denominator: this.denominator }); }, sub(t) { if (e(t) && (t = Z(t)), this.isCompatible(t) || f(this.units(), t.units()), this.isTemperature() && t.isTemperature()) return re(this, t); if (this.isTemperature()) return ne(this, t); if (t.isTemperature()) throw new h('Cannot subtract a temperature from a differential degree unit'); return Z({ scalar: this.scalar - t.to(this).scalar, numerator: this.numerator, denominator: this.denominator }); }, mul(t) { if (r(t)) return Z({ scalar: s(this.scalar, t), numerator: this.numerator, denominator: this.denominator }); if (e(t) && (t = Z(t)), (this.isTemperature() || t.isTemperature()) && !this.isUnitless() && !t.isUnitless()) throw new h('Cannot multiply by temperatures'); const n = this; let i = t; n.isCompatible(i) && n.signature !== 400 && (i = i.to(n)); const a = de(n.numerator, n.denominator, i.numerator, i.denominator); return Z({ scalar: s(n.scalar, i.scalar, a[2]), numerator: a[0], denominator: a[1] }); }, div(t) { if (r(t)) { if (t === 0) throw new h('Divide by zero'); return Z({ scalar: this.scalar / t, numerator: this.numerator, denominator: this.denominator }); } if (e(t) && (t = Z(t)), t.scalar === 0) throw new h('Divide by zero'); if (t.isTemperature()) throw new h('Cannot divide with temperatures'); if (this.isTemperature() && !t.isUnitless()) throw new h('Cannot divide with temperatures'); const n = this; let i = t; n.isCompatible(i) && n.signature !== 400 && (i = i.to(n)); const a = de(n.numerator, n.denominator, i.denominator, i.numerator); return Z({ scalar: s(n.scalar, a[2]) / i.scalar, numerator: a[0], denominator: a[1] }); }, inverse() { if (this.isTemperature()) throw new h('Cannot divide with temperatures'); if (this.scalar === 0) throw new h('Divide by zero'); return Z({ scalar: 1 / this.scalar, numerator: this.denominator, denominator: this.numerator }); },
        }), o(Z.prototype, {
          eq(e) { return this.compareTo(e) === 0; }, lt(e) { return this.compareTo(e) === -1; }, lte(e) { return this.eq(e) || this.lt(e); }, gt(e) { return this.compareTo(e) === 1; }, gte(e) { return this.eq(e) || this.gt(e); }, compareTo(t) { return e(t) ? this.compareTo(Z(t)) : (this.isCompatible(t) || f(this.units(), t.units()), this.baseScalar < t.baseScalar ? -1 : this.baseScalar === t.baseScalar ? 0 : this.baseScalar > t.baseScalar ? 1 : void 0); }, same(e) { return this.scalar === e.scalar && this.units() === e.units(); },
        }), o(Z.prototype, {
          isUnitless() { return [this.numerator, this.denominator].every(((e) => a(e, v))); }, isCompatible(t) { return e(t) ? this.isCompatible(Z(t)) : !!$(t) && void 0 !== t.signature && this.signature === t.signature; }, isInverse(e) { return this.inverse().isCompatible(e); }, isBase() { return void 0 !== this._isBase ? this._isBase : this.isDegrees() && this.numerator[0].match(/<(kelvin|temp-K)>/) ? (this._isBase = !0, this._isBase) : (this.numerator.concat(this.denominator).forEach((function (e) { e !== m && p.indexOf(e) === -1 && (this._isBase = !1); }), this), !1 === this._isBase || (this._isBase = !0), this._isBase); },
        }), pe.prototype.get = function (e) { return arguments.length > 1 && (e = Array.apply(null, arguments)), e.reduce(((t, r, n) => { if (t) { const i = t[r]; return n === e.length - 1 ? i ? i.data : void 0 : i; } }), this); }, pe.prototype.set = function (e, t) { return arguments.length > 2 && (e = Array.prototype.slice.call(arguments, 0, -1), t = arguments[arguments.length - 1]), e.reduce(((r, n, i) => { let a = r[n]; return void 0 === a && (a = r[n] = {}), i === e.length - 1 ? (a.data = t, t) : a; }), this); }, Z.formatter = me, o(Z.prototype, { units() { if (void 0 !== this._units) return this._units; const e = a(this.numerator, v); const t = a(this.denominator, v); if (e && t) return this._units = '', this._units; const r = ge(this.numerator); const n = ge(this.denominator); return this._units = r + (t ? '' : `/${n}`), this._units; }, toString(t, n) { let i; if (r(t))i = this.units(), n = t; else if (e(t))i = t; else if ($(t)) return this.toPrec(t).toString(n); let a = this.to(i); return a = (`${void 0 !== n ? l(a.scalar, n) : a.scalar} ${a.units()}`).trim(); }, format(e, t) { arguments.length === 1 && typeof e === 'function' && (t = e, e = void 0), t = t || Z.formatter; const r = this.to(e); return t.call(this, r.scalar, r.units()); } }); const ve = new pe(); function ge(e) { let t = ve.get(e); return t || (t = a(e, v) ? '1' : be(ye(e)).join('*'), ve.set(e, t), t); } function ye(e) { for (var t, r, n = [], i = 0; i < e.length; i++)t = e[i], r = e[i + 1], y[t] ? (n.push(x[t] + x[r]), i++) : n.push(x[t]); return n; } function be(e) { return e.reduce(((e, t) => { let r = e[t]; return r || e.push(r = e[t] = [t, 0]), r[1]++, e; }), []).map(((e) => e[0] + (e[1] > 1 ? e[1] : ''))); } return Z.version = '1.8.0', Z;
      }());
    },
    6425(e) { !(function () { function t(e) { for (let t = 0, i = e.length - 1, a = void 0, o = void 0, s = void 0, u = n(t, i); ;) { if (i <= t) return e[u]; if (i == t + 1) return e[t] > e[i] && r(e, t, i), e[u]; for (e[a = n(t, i)] > e[i] && r(e, a, i), e[t] > e[i] && r(e, t, i), e[a] > e[t] && r(e, a, t), r(e, a, t + 1), o = t + 1, s = i; ;) { do { o++; } while (e[t] > e[o]); do { s--; } while (e[s] > e[t]); if (s < o) break; r(e, o, s); }r(e, t, s), s <= u && (t = o), s >= u && (i = s - 1); } } var r = function (e, t, r) { let n; return n = [e[r], e[t]], e[t] = n[0], e[r] = n[1], n; }; var n = function (e, t) { return ~~((e + t) / 2); }; e.exports ? e.exports = t : window.median = t; }()); },
    8045(e, t, r) {
      r.r(t), r.d(t, { default() { return i; } }); const n = r(8061); function i(e) { let t; const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!(0, n.isAnyArray)(e)) throw new TypeError('input must be an array'); if (e.length === 0) throw new TypeError('input must not be empty'); if (void 0 !== r.output) { if (!(0, n.isAnyArray)(r.output)) throw new TypeError('output option must be an array if specified'); t = r.output; } else t = new Array(e.length); const i = (function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!(0, n.isAnyArray)(e)) throw new TypeError('input must be an array'); if (e.length === 0) throw new TypeError('input must not be empty'); const r = t.fromIndex; const i = void 0 === r ? 0 : r; const a = t.toIndex; const o = void 0 === a ? e.length : a; if (i < 0 || i >= e.length || !Number.isInteger(i)) throw new Error('fromIndex must be a positive integer smaller than length'); if (o <= i || o > e.length || !Number.isInteger(o)) throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length'); for (var s = e[i], u = i + 1; u < o; u++)e[u] < s && (s = e[u]); return s; }(e)); const a = (function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!(0, n.isAnyArray)(e)) throw new TypeError('input must be an array'); if (e.length === 0) throw new TypeError('input must not be empty'); const r = t.fromIndex; const i = void 0 === r ? 0 : r; const a = t.toIndex; const o = void 0 === a ? e.length : a; if (i < 0 || i >= e.length || !Number.isInteger(i)) throw new Error('fromIndex must be a positive integer smaller than length'); if (o <= i || o > e.length || !Number.isInteger(o)) throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length'); for (var s = e[i], u = i + 1; u < o; u++)e[u] > s && (s = e[u]); return s; }(e)); if (i === a) throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array'); const o = r.min; const s = void 0 === o ? r.autoMinMax ? i : 0 : o; const u = r.max; const l = void 0 === u ? r.autoMinMax ? a : 1 : u; if (s >= l) throw new RangeError('min option must be smaller than max option'); for (let c = (l - s) / (a - i), h = 0; h < e.length; h++)t[h] = (e[h] - i) * c + s; return t; }
    },
    6755(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = (function () { function e() { n(this, e), this.nodes = new Map(); } return i(e, [{ key: 'add', value(e) { let t = this.nodes.get(e); return t || (t = new o(e), this.nodes.set(e, t)), t; } }, { key: 'union', value(e, t) { const r = this.find(e); const n = this.find(t); r !== n && (r.rank < n.rank ? r.parent = n : r.rank > n.rank ? n.parent = r : (n.parent = r, r.rank++)); } }, { key: 'find', value(e) { for (var t = e; t.parent !== null;)t = t.parent; for (let r = e; r.parent !== null;) { const n = r; r = r.parent, n.parent = t; } return t; } }, { key: 'connected', value(e, t) { return this.find(e) === this.find(t); } }]), e; }()); function o(e) { this.value = e, this.parent = null, this.rank = 0; }e.exports = a;
    },
    1118(e, t, r) {
      function n(e, t) { for (var r = 0, n = 0; n < e.length; n++)r += (e[n] - t[n]) * (e[n] - t[n]); return r; } function i(e, t) { return Math.sqrt(n(e, t)); }r.r(t), r.d(t, { euclidean() { return i; }, squaredEuclidean() { return n; } });
    },
    7316(e, t, r) {
      const n = r(3323); const i = {
        DEBUG: !1, ifft2DArray(e, t, r) { const i = new Array(t * r); const a = t / 2; const o = 2 * (r - 1); n.init(a); for (var s = { re: new Array(a), im: new Array(a) }, u = 0; u < r; u++) { for (var l = a - 1; l >= 0; l--)s.re[l] = e[2 * l * r + u], s.im[l] = e[(2 * l + 1) * r + u]; n.bt(s.re, s.im); for (l = a - 1; l >= 0; l--)i[2 * l * r + u] = s.re[l], i[(2 * l + 1) * r + u] = s.im[l]; } const c = new Array(a * o); n.init(o); const h = { re: new Array(o), im: new Array(o) }; const f = o * a; for (l = 0; l < t; l += 2) { h.re[0] = i[l * r], h.im[0] = i[(l + 1) * r]; for (u = 1; u < r; u++)h.re[u] = i[l * r + u], h.im[u] = i[(l + 1) * r + u], h.re[o - u] = i[l * r + u], h.im[o - u] = -i[(l + 1) * r + u]; n.bt(h.re, h.im); const d = l / 2 * o; for (u = o - 1; u >= 0; u--)c[d + u] = h.re[u] / f; } return c; }, fft2DArray(e, t, r, i) { ({ inplace: !0 }); const a = r / 2 + 1; const o = 2 * t; const s = new Array(o * a); n.init(r); for (var u, l, c, h, f, d = { re: new Array(r), im: new Array(r) }, p = { re: new Array(r), im: new Array(r) }, m = { re: new Array(r), im: new Array(r) }, v = 0; v < t / 2; v++) { u = 2 * v * r, d.re = e.slice(u, u + r), u = (2 * v + 1) * r, d.im = e.slice(u, u + r), n.fft1d(d.re, d.im), this.reconstructTwoRealFFT(d, p, m), l = 4 * v * a, c = (4 * v + 1) * a, h = (4 * v + 2) * a, f = (4 * v + 3) * a; for (let g = a - 1; g >= 0; g--)s[l + g] = p.re[g], s[c + g] = p.im[g], s[h + g] = m.re[g], s[f + g] = m.im[g]; }p = null, m = null; const y = new Array(o * a); n.init(t); for (let b = { re: new Array(t), im: new Array(t) }, w = a - 1; w >= 0; w--) { for (v = t - 1; v >= 0; v--)b.re[v] = s[2 * v * a + w], b.im[v] = s[(2 * v + 1) * a + w], isNaN(b.re[v]) && (b.re[v] = 0), isNaN(b.im[v]) && (b.im[v] = 0); n.fft1d(b.re, b.im); for (v = t - 1; v >= 0; v--)y[2 * v * a + w] = b.re[v], y[(2 * v + 1) * a + w] = b.im[v]; } return y; }, reconstructTwoRealFFT(e, t, r) { let n; let i; let a; let o; let s; const u = e.re.length; t.re[0] = e.re[0], t.im[0] = 0, r.re[0] = e.im[0], r.im[0] = 0; for (let l = u / 2; l > 0; l--)s = u - l, n = 0.5 * (e.re[l] - e.re[s]), i = 0.5 * (e.re[l] + e.re[s]), a = 0.5 * (e.im[l] - e.im[s]), o = 0.5 * (e.im[l] + e.im[s]), t.re[l] = i, t.im[l] = a, t.re[s] = i, t.im[s] = -a, r.re[l] = o, r.im[l] = -n, r.re[s] = o, r.im[s] = n; }, convolute2DI(e, t, r, n) { for (var i, a, o = 0; o < r / 2; o++) for (let s = 0; s < n; s++)i = e[2 * o * n + s] * t[2 * o * n + s] - e[(2 * o + 1) * n + s] * t[(2 * o + 1) * n + s], a = e[2 * o * n + s] * t[(2 * o + 1) * n + s] + e[(2 * o + 1) * n + s] * t[2 * o * n + s], e[2 * o * n + s] = i, e[(2 * o + 1) * n + s] = a; }, convolute(e, t, r, n, i) { for (var a = new Array(n * r), o = 0; o < r * n; o++)a[o] = e[o]; a = this.fft2DArray(a, r, n); let s; const u = t.length; const l = t[0].length; let c = new Array(n * r); for (o = 0; o < n * r; o++)c[o] = 0; for (let h = Math.floor((u - 1) / 2), f = Math.floor((l - 1) / 2), d = 0; d < u; d++) { s = (d - h + r) % r; for (let p = 0; p < l; p++)c[s * n + (p - f + n) % n] = t[d][p]; }c = this.fft2DArray(c, r, n); const m = 2 * r; const v = n / 2 + 1; return this.convolute2DI(a, c, m, v), this.ifft2DArray(a, m, v); }, toRadix2(e, t, r) { let n; let i; let a; let o; let s = r; let u = t; if (r === 0 || (r & r - 1) !== 0) { for (s = 0; r >> ++s != 0;);(s = 1 << s) - r; } if (t === 0 || (t & t - 1) !== 0) { for (u = 0; t >> ++u != 0;);((u = 1 << u) - t) * s; } if (u == t && s == r) return { data: e, rows: t, cols: r }; const l = new Array(u * s); const c = Math.floor((u - t) / 2) - t; const h = Math.floor((s - r) / 2) - r; for (n = 0; n < u; n++) for (a = n * s, o = (n - c) % t * r, i = 0; i < s; i++)l[a + i] = e[o + (i - h) % r]; return { data: l, rows: u, cols: s }; }, crop(e, t, r, n, i, a) { if (t == n && r == i) return e; ({ ...a }); let o; let s; let u; let l; const c = new Array(i * n); const h = Math.floor((t - n) / 2); const f = Math.floor((r - i) / 2); for (u = 0; u < n; u++) for (o = u * i, s = (u + h) * r, l = 0; l < i; l++)c[o + l] = e[s + (l + f)]; return c; },
      }; e.exports = i;
    },
    3323(e, t) {
      (function () {
        let e; const r = '0.3.0'; const n = '2013-03'; (e = t).toString = function () { return `version ${r}, released ${n}`; }; for (var i = 0, a = null, o = null, s = {
            init(e) { if (e === 0 || (e & e - 1) !== 0) throw new Error('init: radix-2 required'); i = e, s._initArray(), s._makeBitReversalTable(), s._makeCosSinTable(); }, fft1d(e, t) { s.fft(e, t, 1); }, ifft1d(e, t) { const r = 1 / i; s.fft(e, t, -1); for (let n = 0; n < i; n++)e[n] *= r, t[n] *= r; }, bt1d(e, t) { s.fft(e, t, -1); }, fft2d(e, t) { for (var r = [], n = [], a = 0, o = 0; o < i; o++) { a = o * i; for (let u = 0; u < i; u++)r[u] = e[u + a], n[u] = t[u + a]; s.fft1d(r, n); for (let l = 0; l < i; l++)e[l + a] = r[l], t[l + a] = n[l]; } for (let c = 0; c < i; c++) { for (let h = 0; h < i; h++)a = c + h * i, r[h] = e[a], n[h] = t[a]; s.fft1d(r, n); for (let f = 0; f < i; f++)e[a = c + f * i] = r[f], t[a] = n[f]; } }, ifft2d(e, t) { for (var r = [], n = [], a = 0, o = 0; o < i; o++) { a = o * i; for (let u = 0; u < i; u++)r[u] = e[u + a], n[u] = t[u + a]; s.ifft1d(r, n); for (let l = 0; l < i; l++)e[l + a] = r[l], t[l + a] = n[l]; } for (let c = 0; c < i; c++) { for (let h = 0; h < i; h++)a = c + h * i, r[h] = e[a], n[h] = t[a]; s.ifft1d(r, n); for (let f = 0; f < i; f++)e[a = c + f * i] = r[f], t[a] = n[f]; } }, fft(e, t, r) { for (var n, s, u, l, c, h, f, d, p, m = i >> 2, v = 0; v < i; v++)v < (l = a[v]) && (c = e[v], e[v] = e[l], e[l] = c, c = t[v], t[v] = t[l], t[l] = c); for (let g = 1; g < i; g <<= 1) { s = 0, n = i / (g << 1); for (let y = 0; y < g; y++) { h = o[s + m], f = r * o[s]; for (let b = y; b < i; b += g << 1)d = h * e[u = b + g] + f * t[u], p = h * t[u] - f * e[u], e[u] = e[b] - d, e[b] += d, t[u] = t[b] - p, t[b] += p; s += n; } } }, _initArray() { a = typeof Uint32Array !== 'undefined' ? new Uint32Array(i) : [], o = typeof Float64Array !== 'undefined' ? new Float64Array(1.25 * i) : []; }, _paddingZero() {}, _makeBitReversalTable() { let e = 0; let t = 0; let r = 0; for (a[0] = 0; ++e < i;) { for (r = i >> 1; r <= t;)t -= r, r >>= 1; t += r, a[e] = t; } }, _makeCosSinTable() { const e = i >> 1; const t = i >> 2; const r = i >> 3; const n = e + t; let a = Math.sin(Math.PI / i); let s = 2 * a * a; let u = Math.sqrt(s * (2 - s)); let l = o[t] = 1; let c = o[0] = 0; a = 2 * s; for (let h = 1; h < r; h++)s += a * (l -= s), u -= a * (c += u), o[h] = c, o[t - h] = l; r !== 0 && (o[r] = Math.sqrt(0.5)); for (let f = 0; f < t; f++)o[e - f] = o[f]; for (let d = 0; d < n; d++)o[d + e] = -o[d]; },
          }, u = ['init', 'fft1d', 'ifft1d', 'fft2d', 'ifft2d'], l = 0; l < u.length; l++)e[u[l]] = s[u[l]]; return e.bt = s.bt1d, e.fft = s.fft1d, e.ifft = s.ifft1d, e;
      }).call(this);
    },
    1319(e, t, r) {
      t.FFTUtils = r(7316), r(3323);
    },
    734(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = r(1118).squaredEuclidean; const o = { sigma: 1 }; const s = (function () { function e(t) { n(this, e), t = { ...o, ...t }, this.sigma = t.sigma, this.divisor = 2 * t.sigma * t.sigma; } return i(e, [{ key: 'compute', value(e, t) { const r = a(e, t); return Math.exp(-r / this.divisor); } }]), e; }()); e.exports = s;
    },
    9952(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = { degree: 1, constant: 1, scale: 1 }; const o = (function () { function e(t) { n(this, e), t = { ...a, ...t }, this.degree = t.degree, this.constant = t.constant, this.scale = t.scale; } return i(e, [{ key: 'compute', value(e, t) { for (var r = 0, n = 0; n < e.length; n++)r += e[n] * t[n]; return (this.scale * r + this.constant) ** this.degree; } }]), e; }()); e.exports = o;
    },
    5139(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = { alpha: 0.01, constant: -Math.E }; const o = (function () { function e(t) { n(this, e), t = { ...a, ...t }, this.alpha = t.alpha, this.constant = t.constant; } return i(e, [{ key: 'compute', value(e, t) { for (var r = 0, n = 0; n < e.length; n++)r += e[n] * t[n]; return Math.tanh(this.alpha * r + this.constant); } }]), e; }()); e.exports = o;
    },
    1533(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = r(1316); const o = a.Matrix; const s = a.MatrixTransposeView; const u = r(734); const l = r(9952); const c = r(5139); const h = r(2147); const f = r(8410); const d = r(5908); const p = r(8207); const m = {
        gaussian: u, rbf: u, polynomial: l, poly: l, anova: h, cauchy: f, exponential: d, histogram: p, min: p, laplacian: r(227), multiquadratic: r(9513), rational: r(7853), sigmoid: c, mlp: c,
      }; const v = (function () { function e(t, r) { if (n(this, e), this.kernelType = t, t !== 'linear') if (typeof t === 'string') { t = t.toLowerCase(); const i = m[t]; if (!i) throw new Error('unsupported kernel type: '.concat(t)); this.kernelFunction = new i(r); } else { if (typeof t !== 'object' || typeof t.compute !== 'function') throw new TypeError('first argument must be a valid kernel type or instance'); this.kernelFunction = t; } } return i(e, [{ key: 'compute', value(e, t) { if (e = o.checkMatrix(e), t = void 0 === t ? e : o.checkMatrix(t), this.kernelType === 'linear') return e.mmul(new s(t)); const r = new o(e.rows, t.rows); if (e === t) for (let n = 0; n < e.rows; n++) for (let i = n; i < e.rows; i++) { const a = this.kernelFunction.compute(e.getRow(n), e.getRow(i)); r.set(n, i, a), r.set(i, n, a); } else for (let u = 0; u < e.rows; u++) for (let l = 0; l < t.rows; l++)r.set(u, l, this.kernelFunction.compute(e.getRow(u), t.getRow(l))); return r; } }]), e; }()); e.exports = v;
    },
    2147(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = { sigma: 1, degree: 1 }; const o = (function () { function e(t) { n(this, e), t = { ...a, ...t }, this.sigma = t.sigma, this.degree = t.degree; } return i(e, [{ key: 'compute', value(e, t) { for (var r = 0, n = Math.min(e.length, t.length), i = 1; i <= n; ++i)r += Math.exp(-this.sigma * (e[i - 1] ** i - t[i - 1] ** i) ** 2) ** this.degree; return r; } }]), e; }()); e.exports = o;
    },
    8410(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = r(1118).squaredEuclidean; const o = { sigma: 1 }; const s = (function () { function e(t) { n(this, e), t = { ...o, ...t }, this.sigma = t.sigma; } return i(e, [{ key: 'compute', value(e, t) { return 1 / (1 + a(e, t) / (this.sigma * this.sigma)); } }]), e; }()); e.exports = s;
    },
    5908(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = r(1118).euclidean; const o = { sigma: 1 }; const s = (function () { function e(t) { n(this, e), t = { ...o, ...t }, this.sigma = t.sigma, this.divisor = 2 * t.sigma * t.sigma; } return i(e, [{ key: 'compute', value(e, t) { const r = a(e, t); return Math.exp(-r / this.divisor); } }]), e; }()); e.exports = s;
    },
    8207(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = (function () { function e() { n(this, e); } return i(e, [{ key: 'compute', value(e, t) { for (var r = Math.min(e.length, t.length), n = 0, i = 0; i < r; ++i)n += Math.min(e[i], t[i]); return n; } }]), e; }()); e.exports = a;
    },
    227(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = r(1118).euclidean; const o = { sigma: 1 }; const s = (function () { function e(t) { n(this, e), t = { ...o, ...t }, this.sigma = t.sigma; } return i(e, [{ key: 'compute', value(e, t) { const r = a(e, t); return Math.exp(-r / this.sigma); } }]), e; }()); e.exports = s;
    },
    9513(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = r(1118).squaredEuclidean; const o = { constant: 1 }; const s = (function () { function e(t) { n(this, e), t = { ...o, ...t }, this.constant = t.constant; } return i(e, [{ key: 'compute', value(e, t) { return Math.sqrt(a(e, t) + this.constant * this.constant); } }]), e; }()); e.exports = s;
    },
    7853(e, t, r) {
      const n = r(6690).default; const i = r(9728).default; const a = r(1118).squaredEuclidean; const o = { constant: 1 }; const s = (function () { function e(t) { n(this, e), t = { ...o, ...t }, this.constant = t.constant; } return i(e, [{ key: 'compute', value(e, t) { const r = a(e, t); return 1 - r / (r + this.constant); } }]), e; }()); e.exports = s;
    },
    2111(e, t, r) {
      const n = r(1319).FFTUtils; function i(e) { let t; let r; let n = e; if (typeof e[0] !== 'number') { t = e.length, r = e[0].length, n = new Array(t * r); for (let i = 0; i < t; i++) for (let a = 0; a < r; a++)n[i * r + a] = e[i][a]; } else { const o = Math.sqrt(e.length); Number.isInteger(o) && (t = o, r = o); } return { data: n, rows: t, cols: r }; }e.exports = {
        fft(e, t, r) {
          let a; let o; const s = i(e); const u = s.data; const l = {
            normalize: !1, divisor: 1, rows: s.rows, cols: s.cols, ...r,
          }; if (!l.rows || !l.cols) throw new Error(`Invalid number of rows or columns ${a} ${o}`); a = l.rows, o = l.cols; let c; let h; let f = l.divisor; const d = t.length; const p = t[0].length; if (l.normalize) for (f = 0, c = 0; c < d; c++) for (h = 0; h < p; h++)f += t[c][h]; if (f === 0) throw new RangeError('convolution: The divisor is equal to zero'); const m = n.toRadix2(u, a, o); let v = n.convolute(m.data, t, m.rows, m.cols); if (v = n.crop(v, m.rows, m.cols, a, o), f != 0 && f != 1) for (c = 0; c < v.length; c++)v[c] /= f; return v;
        },
        direct(e, t, r) {
          let n; let a; const o = i(e); const s = o.data; const u = {
            normalize: !1, divisor: 1, rows: o.rows, cols: o.cols, ...r,
          }; if (!u.rows || !u.cols) throw new Error(`Invalid number of rows or columns ${n} ${a}`); n = u.rows, a = u.cols; let l; let c; let h; let f; let d; let p; let m = u.divisor; const v = t.length; const g = t[0].length; if (u.normalize) for (m = 0, l = 0; l < v; l++) for (c = 0; c < g; c++)m += t[l][c]; if (m === 0) throw new RangeError('convolution: The divisor is equal to zero'); const y = new Array(n * a); const b = Math.floor(v / 2); const w = Math.floor(g / 2); for (f = 0; f < n; f++) for (h = 0; h < a; h++) { for (d = 0, c = 0; c < v; c++) for (l = 0; l < g; l++)p = t[v - c - 1][g - l - 1], d += s[(f + c - b + n) % n * a + (h + l - w + a) % a] * p; y[f * a + h] = d / m; } return y;
        },
        kernelFactory: { LoG(e, t, r) { let n = 1e3; r && r.factor && (n = r.factor); let i; let a; let o; let s; const u = new Array(t); n *= -1; const l = (t - 1) / 2; const c = 2 * e * e; for (i = 0; i < t; i++) for (u[i] = new Array(t), s = (i - l) * (i - l), a = 0; a < t; a++)o = -((a - l) * (a - l) + s) / c, u[i][a] = Math.round(n * (1 + o) * Math.exp(o)); return u; } },
        matrix2Array: i,
      };
    },
    1316(e, t, r) {
      const n = r(4993).default; const i = r(1655).default; const a = r(6389).default; const o = r(6690).default; const s = r(9728).default; Object.defineProperty(t, '__esModule', { value: !0 }); const u = r(8061); const l = r(8045); const c = ' '.repeat(2); const h = ' '.repeat(4); function f(e) {
        const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.maxRows; const n = void 0 === r ? 15 : r; const i = t.maxColumns; const a = void 0 === i ? 10 : i; const o = t.maxNumSize; const s = void 0 === o ? 8 : o; const u = t.padMinus; const l = void 0 === u ? 'auto' : u; return ''.concat(e.constructor.name, ' {\n').concat(c, '[\n').concat(h).concat((function (e, t, r, n, i) { const a = e.rows; const o = e.columns; const s = Math.min(a, t); const u = Math.min(o, r); const l = []; if (i === 'auto') { i = !1; e:for (let c = 0; c < s; c++) for (let f = 0; f < u; f++) if (e.get(c, f) < 0) { i = !0; break e; } } for (let p = 0; p < s; p++) { for (var m = [], v = 0; v < u; v++)m.push(d(e.get(p, v), n, i)); l.push(''.concat(m.join(' '))); }u !== o && (l[l.length - 1] += ' ... '.concat(o - r, ' more columns')); s !== a && l.push('... '.concat(a - t, ' more rows')); return l.join('\n'.concat(h)); }(e, n, a, s, l)), '\n')
          .concat(c, ']\n')
          .concat(c, 'rows: ')
          .concat(e.rows, '\n')
          .concat(c, 'columns: ')
          .concat(e.columns, '\n}');
      } function d(e, t, r) { return (e >= 0 && r ? ' '.concat(p(e, t - 1)) : p(e, t)).padEnd(t); } function p(e, t) { const r = e.toString(); if (r.length <= t) return r; let n = e.toFixed(t); if (n.length > t && (n = e.toFixed(Math.max(0, t - (n.length - t)))), n.length <= t && !n.startsWith('0.000') && !n.startsWith('-0.000')) return n; let i = e.toExponential(t); return i.length > t && (i = e.toExponential(Math.max(0, t - (i.length - t)))), i.slice(0); } function m(e, t, r) { const n = r ? e.rows : e.rows - 1; if (t < 0 || t > n) throw new RangeError('Row index out of range'); } function v(e, t, r) { const n = r ? e.columns : e.columns - 1; if (t < 0 || t > n) throw new RangeError('Column index out of range'); } function g(e, t) { if (t.to1DArray && (t = t.to1DArray()), t.length !== e.columns) throw new RangeError('vector size must be the same as the number of columns'); return t; } function y(e, t) { if (t.to1DArray && (t = t.to1DArray()), t.length !== e.rows) throw new RangeError('vector size must be the same as the number of rows'); return t; } function b(e, t) { if (!u.isAnyArray(t)) throw new TypeError('row indices must be an array'); for (let r = 0; r < t.length; r++) if (t[r] < 0 || t[r] >= e.rows) throw new RangeError('row indices are out of range'); } function w(e, t) { if (!u.isAnyArray(t)) throw new TypeError('column indices must be an array'); for (let r = 0; r < t.length; r++) if (t[r] < 0 || t[r] >= e.columns) throw new RangeError('column indices are out of range'); } function k(e, t, r, n, i) { if (arguments.length !== 5) throw new RangeError('expected 4 arguments'); if (_('startRow', t), _('endRow', r), _('startColumn', n), _('endColumn', i), t > r || n > i || t < 0 || t >= e.rows || r < 0 || r >= e.rows || n < 0 || n >= e.columns || i < 0 || i >= e.columns) throw new RangeError('Submatrix indices are out of range'); } function x(e) { for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = [], n = 0; n < e; n++)r.push(t); return r; } function _(e, t) { if (typeof t !== 'number') throw new TypeError(''.concat(e, ' must be a number')); } function S(e) { if (e.isEmpty()) throw new Error('Empty matrix has no elements to index'); } const M = (function () { function e() { o(this, e); } return s(e, [{ key: 'size', get() { return this.rows * this.columns; } }, { key: 'apply', value(e) { if (typeof e !== 'function') throw new TypeError('callback must be a function'); for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++)e.call(this, t, r); return this; } }, { key: 'to1DArray', value() { for (var e = [], t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++)e.push(this.get(t, r)); return e; } }, { key: 'to2DArray', value() { for (var e = [], t = 0; t < this.rows; t++) { e.push([]); for (let r = 0; r < this.columns; r++)e[t].push(this.get(t, r)); } return e; } }, { key: 'toJSON', value() { return this.to2DArray(); } }, { key: 'isRowVector', value() { return this.rows === 1; } }, { key: 'isColumnVector', value() { return this.columns === 1; } }, { key: 'isVector', value() { return this.rows === 1 || this.columns === 1; } }, { key: 'isSquare', value() { return this.rows === this.columns; } }, { key: 'isEmpty', value() { return this.rows === 0 || this.columns === 0; } }, { key: 'isSymmetric', value() { if (this.isSquare()) { for (let e = 0; e < this.rows; e++) for (let t = 0; t <= e; t++) if (this.get(e, t) !== this.get(t, e)) return !1; return !0; } return !1; } }, { key: 'isEchelonForm', value() { for (var e = 0, t = 0, r = -1, n = !0, i = !1; e < this.rows && n;) { for (t = 0, i = !1; t < this.columns && !1 === i;) this.get(e, t) === 0 ? t++ : this.get(e, t) === 1 && t > r ? (i = !0, r = t) : (n = !1, i = !0); e++; } return n; } }, { key: 'isReducedEchelonForm', value() { for (var e = 0, t = 0, r = -1, n = !0, i = !1; e < this.rows && n;) { for (t = 0, i = !1; t < this.columns && !1 === i;) this.get(e, t) === 0 ? t++ : this.get(e, t) === 1 && t > r ? (i = !0, r = t) : (n = !1, i = !0); for (let a = t + 1; a < this.rows; a++) this.get(e, a) !== 0 && (n = !1); e++; } return n; } }, { key: 'echelonForm', value() { for (var e = this.clone(), t = 0, r = 0; t < e.rows && r < e.columns;) { for (var n = t, i = t; i < e.rows; i++)e.get(i, r) > e.get(n, r) && (n = i); if (e.get(n, r) === 0)r++; else { e.swapRows(t, n); for (let a = e.get(t, r), o = r; o < e.columns; o++)e.set(t, o, e.get(t, o) / a); for (let s = t + 1; s < e.rows; s++) { const u = e.get(s, r) / e.get(t, r); e.set(s, r, 0); for (let l = r + 1; l < e.columns; l++)e.set(s, l, e.get(s, l) - e.get(t, l) * u); }t++, r++; } } return e; } }, { key: 'reducedEchelonForm', value() { for (var e = this.echelonForm(), t = e.columns, r = e.rows, n = r - 1; n >= 0;) if (e.maxRow(n) === 0)n--; else { for (var i = 0, a = !1; i < r && !1 === a;)e.get(n, i) === 1 ? a = !0 : i++; for (let o = 0; o < n; o++) for (let s = e.get(o, i), u = i; u < t; u++) { const l = e.get(o, u) - s * e.get(n, u); e.set(o, u, l); }n--; } return e; } }, { key: 'set', value() { throw new Error('set method is unimplemented'); } }, { key: 'get', value() { throw new Error('get method is unimplemented'); } }, { key: 'repeat', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (typeof e !== 'object') throw new TypeError('options must be an object'); const t = e.rows; const r = void 0 === t ? 1 : t; const n = e.columns; const i = void 0 === n ? 1 : n; if (!Number.isInteger(r) || r <= 0) throw new TypeError('rows must be a positive integer'); if (!Number.isInteger(i) || i <= 0) throw new TypeError('columns must be a positive integer'); for (var a = new C(this.rows * r, this.columns * i), o = 0; o < r; o++) for (let s = 0; s < i; s++)a.setSubMatrix(this, this.rows * o, this.columns * s); return a; } }, { key: 'fill', value(e) { for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, e); return this; } }, { key: 'neg', value() { return this.mulS(-1); } }, { key: 'getRow', value(e) { m(this, e); for (var t = [], r = 0; r < this.columns; r++)t.push(this.get(e, r)); return t; } }, { key: 'getRowVector', value(e) { return C.rowVector(this.getRow(e)); } }, { key: 'setRow', value(e, t) { m(this, e), t = g(this, t); for (let r = 0; r < this.columns; r++) this.set(e, r, t[r]); return this; } }, { key: 'swapRows', value(e, t) { m(this, e), m(this, t); for (let r = 0; r < this.columns; r++) { const n = this.get(e, r); this.set(e, r, this.get(t, r)), this.set(t, r, n); } return this; } }, { key: 'getColumn', value(e) { v(this, e); for (var t = [], r = 0; r < this.rows; r++)t.push(this.get(r, e)); return t; } }, { key: 'getColumnVector', value(e) { return C.columnVector(this.getColumn(e)); } }, { key: 'setColumn', value(e, t) { v(this, e), t = y(this, t); for (let r = 0; r < this.rows; r++) this.set(r, e, t[r]); return this; } }, { key: 'swapColumns', value(e, t) { v(this, e), v(this, t); for (let r = 0; r < this.rows; r++) { const n = this.get(r, e); this.set(r, e, this.get(r, t)), this.set(r, t, n); } return this; } }, { key: 'addRowVector', value(e) { e = g(this, e); for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) + e[r]); return this; } }, { key: 'subRowVector', value(e) { e = g(this, e); for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) - e[r]); return this; } }, { key: 'mulRowVector', value(e) { e = g(this, e); for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) * e[r]); return this; } }, { key: 'divRowVector', value(e) { e = g(this, e); for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) / e[r]); return this; } }, { key: 'addColumnVector', value(e) { e = y(this, e); for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) + e[t]); return this; } }, { key: 'subColumnVector', value(e) { e = y(this, e); for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) - e[t]); return this; } }, { key: 'mulColumnVector', value(e) { e = y(this, e); for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) * e[t]); return this; } }, { key: 'divColumnVector', value(e) { e = y(this, e); for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) / e[t]); return this; } }, { key: 'mulRow', value(e, t) { m(this, e); for (let r = 0; r < this.columns; r++) this.set(e, r, this.get(e, r) * t); return this; } }, { key: 'mulColumn', value(e, t) { v(this, e); for (let r = 0; r < this.rows; r++) this.set(r, e, this.get(r, e) * t); return this; } }, { key: 'max', value(e) { if (this.isEmpty()) return NaN; switch (e) { case 'row': for (var t = new Array(this.rows).fill(Number.NEGATIVE_INFINITY), r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.get(r, n) > t[r] && (t[r] = this.get(r, n)); return t; case 'column': for (var i = new Array(this.columns).fill(Number.NEGATIVE_INFINITY), a = 0; a < this.rows; a++) for (let o = 0; o < this.columns; o++) this.get(a, o) > i[o] && (i[o] = this.get(a, o)); return i; case void 0: for (var s = this.get(0, 0), u = 0; u < this.rows; u++) for (let l = 0; l < this.columns; l++) this.get(u, l) > s && (s = this.get(u, l)); return s; default: throw new Error('invalid option: '.concat(e)); } } }, { key: 'maxIndex', value() { S(this); for (var e = this.get(0, 0), t = [0, 0], r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.get(r, n) > e && (e = this.get(r, n), t[0] = r, t[1] = n); return t; } }, { key: 'min', value(e) { if (this.isEmpty()) return NaN; switch (e) { case 'row': for (var t = new Array(this.rows).fill(Number.POSITIVE_INFINITY), r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.get(r, n) < t[r] && (t[r] = this.get(r, n)); return t; case 'column': for (var i = new Array(this.columns).fill(Number.POSITIVE_INFINITY), a = 0; a < this.rows; a++) for (let o = 0; o < this.columns; o++) this.get(a, o) < i[o] && (i[o] = this.get(a, o)); return i; case void 0: for (var s = this.get(0, 0), u = 0; u < this.rows; u++) for (let l = 0; l < this.columns; l++) this.get(u, l) < s && (s = this.get(u, l)); return s; default: throw new Error('invalid option: '.concat(e)); } } }, { key: 'minIndex', value() { S(this); for (var e = this.get(0, 0), t = [0, 0], r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.get(r, n) < e && (e = this.get(r, n), t[0] = r, t[1] = n); return t; } }, { key: 'maxRow', value(e) { if (m(this, e), this.isEmpty()) return NaN; for (var t = this.get(e, 0), r = 1; r < this.columns; r++) this.get(e, r) > t && (t = this.get(e, r)); return t; } }, { key: 'maxRowIndex', value(e) { m(this, e), S(this); for (var t = this.get(e, 0), r = [e, 0], n = 1; n < this.columns; n++) this.get(e, n) > t && (t = this.get(e, n), r[1] = n); return r; } }, { key: 'minRow', value(e) { if (m(this, e), this.isEmpty()) return NaN; for (var t = this.get(e, 0), r = 1; r < this.columns; r++) this.get(e, r) < t && (t = this.get(e, r)); return t; } }, { key: 'minRowIndex', value(e) { m(this, e), S(this); for (var t = this.get(e, 0), r = [e, 0], n = 1; n < this.columns; n++) this.get(e, n) < t && (t = this.get(e, n), r[1] = n); return r; } }, { key: 'maxColumn', value(e) { if (v(this, e), this.isEmpty()) return NaN; for (var t = this.get(0, e), r = 1; r < this.rows; r++) this.get(r, e) > t && (t = this.get(r, e)); return t; } }, { key: 'maxColumnIndex', value(e) { v(this, e), S(this); for (var t = this.get(0, e), r = [0, e], n = 1; n < this.rows; n++) this.get(n, e) > t && (t = this.get(n, e), r[0] = n); return r; } }, { key: 'minColumn', value(e) { if (v(this, e), this.isEmpty()) return NaN; for (var t = this.get(0, e), r = 1; r < this.rows; r++) this.get(r, e) < t && (t = this.get(r, e)); return t; } }, { key: 'minColumnIndex', value(e) { v(this, e), S(this); for (var t = this.get(0, e), r = [0, e], n = 1; n < this.rows; n++) this.get(n, e) < t && (t = this.get(n, e), r[0] = n); return r; } }, { key: 'diag', value() { for (var e = Math.min(this.rows, this.columns), t = [], r = 0; r < e; r++)t.push(this.get(r, r)); return t; } }, { key: 'norm', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'frobenius'; switch (e) { case 'max': return this.max(); case 'frobenius': return Math.sqrt(this.dot(this)); default: throw new RangeError('unknown norm type: '.concat(e)); } } }, { key: 'cumulativeSum', value() { for (let e = 0, t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++)e += this.get(t, r), this.set(t, r, e); return this; } }, { key: 'dot', value(t) { e.isMatrix(t) && (t = t.to1DArray()); const r = this.to1DArray(); if (r.length !== t.length) throw new RangeError('vectors do not have the same size'); for (var n = 0, i = 0; i < r.length; i++)n += r[i] * t[i]; return n; } }, { key: 'mmul', value(e) { e = C.checkMatrix(e); for (var t = this.rows, r = this.columns, n = e.columns, i = new C(t, n), a = new Float64Array(r), o = 0; o < n; o++) { for (let s = 0; s < r; s++)a[s] = e.get(s, o); for (let u = 0; u < t; u++) { for (var l = 0, c = 0; c < r; c++)l += this.get(u, c) * a[c]; i.set(u, o, l); } } return i; } }, { key: 'strassen2x2', value(e) { e = C.checkMatrix(e); const t = new C(2, 2); const r = this.get(0, 0); const n = e.get(0, 0); const i = this.get(0, 1); const a = e.get(0, 1); const o = this.get(1, 0); const s = e.get(1, 0); const u = this.get(1, 1); const l = e.get(1, 1); const c = (r + u) * (n + l); const h = (o + u) * n; const f = r * (a - l); const d = u * (s - n); const p = (r + i) * l; const m = c + d - p + (i - u) * (s + l); const v = f + p; const g = h + d; const y = c - h + f + (o - r) * (n + a); return t.set(0, 0, m), t.set(0, 1, v), t.set(1, 0, g), t.set(1, 1, y), t; } }, { key: 'strassen3x3', value(e) { e = C.checkMatrix(e); const t = new C(3, 3); const r = this.get(0, 0); const n = this.get(0, 1); const i = this.get(0, 2); const a = this.get(1, 0); const o = this.get(1, 1); const s = this.get(1, 2); const u = this.get(2, 0); const l = this.get(2, 1); const c = this.get(2, 2); const h = e.get(0, 0); const f = e.get(0, 1); const d = e.get(0, 2); const p = e.get(1, 0); const m = e.get(1, 1); const v = e.get(1, 2); const g = e.get(2, 0); const y = e.get(2, 1); const b = e.get(2, 2); const w = (r - a) * (-f + m); const k = (-r + a + o) * (h - f + m); const x = (a + o) * (-h + f); const _ = r * h; const S = (-r + u + l) * (h - d + v); const M = (-r + u) * (d - v); const E = (u + l) * (-h + d); const P = (-i + l + c) * (m + g - y); const A = (i - c) * (m - y); const T = i * g; const R = (l + c) * (-g + y); const I = (-i + o + s) * (v + g - b); const O = (i - s) * (v - b); const D = (o + s) * (-g + b); const z = _ + T + n * p; const N = (r + n + i - a - o - l - c) * m + k + x + _ + P + T + R; const L = _ + S + E + (r + n + i - o - s - u - l) * v + T + I + D; const j = w + o * (-h + f + p - m - v - g + b) + k + _ + T + I + O; const F = w + k + x + _ + s * y; const B = T + I + O + D + a * d; const U = _ + S + M + l * (-h + d + p - m - v - g + y) + P + A + T; const V = P + A + T + R + u * f; const Y = _ + S + M + E + c * b; return t.set(0, 0, z), t.set(0, 1, N), t.set(0, 2, L), t.set(1, 0, j), t.set(1, 1, F), t.set(1, 2, B), t.set(2, 0, U), t.set(2, 1, V), t.set(2, 2, Y), t; } }, { key: 'mmulStrassen', value(t) { t = C.checkMatrix(t); let r = this.clone(); const n = r.rows; const i = r.columns; const a = t.rows; const o = t.columns; function s(t, r, n) { const i = t.rows; const a = t.columns; if (i === r && a === n) return t; let o = e.zeros(r, n); return o = o.setSubMatrix(t, 0, 0); }i !== a && console.warn('Multiplying '.concat(n, ' x ').concat(i, ' and ').concat(a, ' x ').concat(o, ' matrix: dimensions do not match.')); const u = Math.max(n, a); const l = Math.max(i, o); return (function t(r, n, i, a) { if (i <= 512 || a <= 512) return r.mmul(n); i % 2 === 1 && a % 2 === 1 ? (r = s(r, i + 1, a + 1), n = s(n, i + 1, a + 1)) : i % 2 === 1 ? (r = s(r, i + 1, a), n = s(n, i + 1, a)) : a % 2 === 1 && (r = s(r, i, a + 1), n = s(n, i, a + 1)); const o = parseInt(r.rows / 2, 10); const u = parseInt(r.columns / 2, 10); const l = r.subMatrix(0, o - 1, 0, u - 1); const c = n.subMatrix(0, o - 1, 0, u - 1); const h = r.subMatrix(0, o - 1, u, r.columns - 1); const f = n.subMatrix(0, o - 1, u, n.columns - 1); const d = r.subMatrix(o, r.rows - 1, 0, u - 1); const p = n.subMatrix(o, n.rows - 1, 0, u - 1); const m = r.subMatrix(o, r.rows - 1, u, r.columns - 1); const v = n.subMatrix(o, n.rows - 1, u, n.columns - 1); const g = t(e.add(l, m), e.add(c, v), o, u); const y = t(e.add(d, m), c, o, u); const b = t(l, e.sub(f, v), o, u); const w = t(m, e.sub(p, c), o, u); const k = t(e.add(l, h), v, o, u); const x = t(e.sub(d, l), e.add(c, f), o, u); const _ = t(e.sub(h, m), e.add(p, v), o, u); const S = e.add(g, w); S.sub(k), S.add(_); const M = e.add(b, k); const E = e.add(y, w); const C = e.sub(g, y); C.add(b), C.add(x); let P = e.zeros(2 * S.rows, 2 * S.columns); return (P = (P = (P = (P = P.setSubMatrix(S, 0, 0)).setSubMatrix(M, S.rows, 0)).setSubMatrix(E, 0, S.columns)).setSubMatrix(C, S.rows, S.columns)).subMatrix(0, i - 1, 0, a - 1); }(r = s(r, u, l), t = s(t, u, l), u, l)); } }, { key: 'scaleRows', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (typeof e !== 'object') throw new TypeError('options must be an object'); const t = e.min; const r = void 0 === t ? 0 : t; const n = e.max; const i = void 0 === n ? 1 : n; if (!Number.isFinite(r)) throw new TypeError('min must be a number'); if (!Number.isFinite(i)) throw new TypeError('max must be a number'); if (r >= i) throw new RangeError('min must be smaller than max'); for (var a = new C(this.rows, this.columns), o = 0; o < this.rows; o++) { const s = this.getRow(o); s.length > 0 && l(s, { min: r, max: i, output: s }), a.setRow(o, s); } return a; } }, { key: 'scaleColumns', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (typeof e !== 'object') throw new TypeError('options must be an object'); const t = e.min; const r = void 0 === t ? 0 : t; const n = e.max; const i = void 0 === n ? 1 : n; if (!Number.isFinite(r)) throw new TypeError('min must be a number'); if (!Number.isFinite(i)) throw new TypeError('max must be a number'); if (r >= i) throw new RangeError('min must be smaller than max'); for (var a = new C(this.rows, this.columns), o = 0; o < this.columns; o++) { const s = this.getColumn(o); s.length && l(s, { min: r, max: i, output: s }), a.setColumn(o, s); } return a; } }, { key: 'flipRows', value() { for (let e = Math.ceil(this.columns / 2), t = 0; t < this.rows; t++) for (let r = 0; r < e; r++) { const n = this.get(t, r); const i = this.get(t, this.columns - 1 - r); this.set(t, r, i), this.set(t, this.columns - 1 - r, n); } return this; } }, { key: 'flipColumns', value() { for (let e = Math.ceil(this.rows / 2), t = 0; t < this.columns; t++) for (let r = 0; r < e; r++) { const n = this.get(r, t); const i = this.get(this.rows - 1 - r, t); this.set(r, t, i), this.set(this.rows - 1 - r, t, n); } return this; } }, { key: 'kroneckerProduct', value(e) { e = C.checkMatrix(e); for (var t = this.rows, r = this.columns, n = e.rows, i = e.columns, a = new C(t * n, r * i), o = 0; o < t; o++) for (let s = 0; s < r; s++) for (let u = 0; u < n; u++) for (let l = 0; l < i; l++)a.set(n * o + u, i * s + l, this.get(o, s) * e.get(u, l)); return a; } }, { key: 'kroneckerSum', value(e) { if (e = C.checkMatrix(e), !this.isSquare() || !e.isSquare()) throw new Error('Kronecker Sum needs two Square Matrices'); const t = this.rows; const r = e.rows; const n = this.kroneckerProduct(C.eye(r, r)); const i = C.eye(t, t).kroneckerProduct(e); return n.add(i); } }, { key: 'transpose', value() { for (var e = new C(this.columns, this.rows), t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++)e.set(r, t, this.get(t, r)); return e; } }, { key: 'sortRows', value() { for (let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : E, t = 0; t < this.rows; t++) this.setRow(t, this.getRow(t).sort(e)); return this; } }, { key: 'sortColumns', value() { for (let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : E, t = 0; t < this.columns; t++) this.setColumn(t, this.getColumn(t).sort(e)); return this; } }, { key: 'subMatrix', value(e, t, r, n) { k(this, e, t, r, n); for (var i = new C(t - e + 1, n - r + 1), a = e; a <= t; a++) for (let o = r; o <= n; o++)i.set(a - e, o - r, this.get(a, o)); return i; } }, { key: 'subMatrixRow', value(e, t, r) { if (void 0 === t && (t = 0), void 0 === r && (r = this.columns - 1), t > r || t < 0 || t >= this.columns || r < 0 || r >= this.columns) throw new RangeError('Argument out of range'); for (var n = new C(e.length, r - t + 1), i = 0; i < e.length; i++) for (let a = t; a <= r; a++) { if (e[i] < 0 || e[i] >= this.rows) throw new RangeError('Row index out of range: '.concat(e[i])); n.set(i, a - t, this.get(e[i], a)); } return n; } }, { key: 'subMatrixColumn', value(e, t, r) { if (void 0 === t && (t = 0), void 0 === r && (r = this.rows - 1), t > r || t < 0 || t >= this.rows || r < 0 || r >= this.rows) throw new RangeError('Argument out of range'); for (var n = new C(r - t + 1, e.length), i = 0; i < e.length; i++) for (let a = t; a <= r; a++) { if (e[i] < 0 || e[i] >= this.columns) throw new RangeError('Column index out of range: '.concat(e[i])); n.set(a - t, i, this.get(a, e[i])); } return n; } }, { key: 'setSubMatrix', value(e, t, r) { if ((e = C.checkMatrix(e)).isEmpty()) return this; k(this, t, t + e.rows - 1, r, r + e.columns - 1); for (let n = 0; n < e.rows; n++) for (let i = 0; i < e.columns; i++) this.set(t + n, r + i, e.get(n, i)); return this; } }, { key: 'selection', value(e, t) { b(this, e), w(this, t); for (var r = new C(e.length, t.length), n = 0; n < e.length; n++) for (let i = e[n], a = 0; a < t.length; a++) { const o = t[a]; r.set(n, a, this.get(i, o)); } return r; } }, { key: 'trace', value() { for (var e = Math.min(this.rows, this.columns), t = 0, r = 0; r < e; r++)t += this.get(r, r); return t; } }, { key: 'clone', value() { for (var e = new C(this.rows, this.columns), t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++)e.set(t, r, this.get(t, r)); return e; } }, { key: 'sum', value(e) { switch (e) { case 'row': return (function (e) { for (var t = x(e.rows), r = 0; r < e.rows; ++r) for (let n = 0; n < e.columns; ++n)t[r] += e.get(r, n); return t; }(this)); case 'column': return (function (e) { for (var t = x(e.columns), r = 0; r < e.rows; ++r) for (let n = 0; n < e.columns; ++n)t[n] += e.get(r, n); return t; }(this)); case void 0: return (function (e) { for (var t = 0, r = 0; r < e.rows; r++) for (let n = 0; n < e.columns; n++)t += e.get(r, n); return t; }(this)); default: throw new Error('invalid option: '.concat(e)); } } }, { key: 'product', value(e) { switch (e) { case 'row': return (function (e) { for (var t = x(e.rows, 1), r = 0; r < e.rows; ++r) for (let n = 0; n < e.columns; ++n)t[r] *= e.get(r, n); return t; }(this)); case 'column': return (function (e) { for (var t = x(e.columns, 1), r = 0; r < e.rows; ++r) for (let n = 0; n < e.columns; ++n)t[n] *= e.get(r, n); return t; }(this)); case void 0: return (function (e) { for (var t = 1, r = 0; r < e.rows; r++) for (let n = 0; n < e.columns; n++)t *= e.get(r, n); return t; }(this)); default: throw new Error('invalid option: '.concat(e)); } } }, { key: 'mean', value(e) { const t = this.sum(e); switch (e) { case 'row': for (let r = 0; r < this.rows; r++)t[r] /= this.columns; return t; case 'column': for (let n = 0; n < this.columns; n++)t[n] /= this.rows; return t; case void 0: return t / this.size; default: throw new Error('invalid option: '.concat(e)); } } }, { key: 'variance', value(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (typeof e === 'object' && (t = e, e = void 0), typeof t !== 'object') throw new TypeError('options must be an object'); const r = t; const n = r.unbiased; const i = void 0 === n || n; const a = r.mean; const o = void 0 === a ? this.mean(e) : a; if (typeof i !== 'boolean') throw new TypeError('unbiased must be a boolean'); switch (e) { case 'row': if (!u.isAnyArray(o)) throw new TypeError('mean must be an array'); return (function (e, t, r) { for (var n = e.rows, i = e.columns, a = [], o = 0; o < n; o++) { for (var s = 0, u = 0, l = 0, c = 0; c < i; c++)s += l = e.get(o, c) - r[o], u += l * l; t ? a.push((u - s * s / i) / (i - 1)) : a.push((u - s * s / i) / i); } return a; }(this, i, o)); case 'column': if (!u.isAnyArray(o)) throw new TypeError('mean must be an array'); return (function (e, t, r) { for (var n = e.rows, i = e.columns, a = [], o = 0; o < i; o++) { for (var s = 0, u = 0, l = 0, c = 0; c < n; c++)s += l = e.get(c, o) - r[o], u += l * l; t ? a.push((u - s * s / n) / (n - 1)) : a.push((u - s * s / n) / n); } return a; }(this, i, o)); case void 0: if (typeof o !== 'number') throw new TypeError('mean must be a number'); return (function (e, t, r) { for (var n = e.rows, i = e.columns, a = n * i, o = 0, s = 0, u = 0, l = 0; l < n; l++) for (let c = 0; c < i; c++)o += u = e.get(l, c) - r, s += u * u; return t ? (s - o * o / a) / (a - 1) : (s - o * o / a) / a; }(this, i, o)); default: throw new Error('invalid option: '.concat(e)); } } }, { key: 'standardDeviation', value(e, t) { typeof e === 'object' && (t = e, e = void 0); const r = this.variance(e, t); if (void 0 === e) return Math.sqrt(r); for (let n = 0; n < r.length; n++)r[n] = Math.sqrt(r[n]); return r; } }, { key: 'center', value(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (typeof e === 'object' && (t = e, e = void 0), typeof t !== 'object') throw new TypeError('options must be an object'); const r = t.center; const n = void 0 === r ? this.mean(e) : r; switch (e) { case 'row': if (!u.isAnyArray(n)) throw new TypeError('center must be an array'); return (function (e, t) { for (let r = 0; r < e.rows; r++) for (let n = 0; n < e.columns; n++)e.set(r, n, e.get(r, n) - t[r]); }(this, n)), this; case 'column': if (!u.isAnyArray(n)) throw new TypeError('center must be an array'); return (function (e, t) { for (let r = 0; r < e.rows; r++) for (let n = 0; n < e.columns; n++)e.set(r, n, e.get(r, n) - t[n]); }(this, n)), this; case void 0: if (typeof n !== 'number') throw new TypeError('center must be a number'); return (function (e, t) { for (let r = 0; r < e.rows; r++) for (let n = 0; n < e.columns; n++)e.set(r, n, e.get(r, n) - t); }(this, n)), this; default: throw new Error('invalid option: '.concat(e)); } } }, { key: 'scale', value(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (typeof e === 'object' && (t = e, e = void 0), typeof t !== 'object') throw new TypeError('options must be an object'); let r = t.scale; switch (e) { case 'row': if (void 0 === r)r = (function (e) { for (var t = [], r = 0; r < e.rows; r++) { for (var n = 0, i = 0; i < e.columns; i++)n += e.get(r, i) ** 2 / (e.columns - 1); t.push(Math.sqrt(n)); } return t; }(this)); else if (!u.isAnyArray(r)) throw new TypeError('scale must be an array'); return (function (e, t) { for (let r = 0; r < e.rows; r++) for (let n = 0; n < e.columns; n++)e.set(r, n, e.get(r, n) / t[r]); }(this, r)), this; case 'column': if (void 0 === r)r = (function (e) { for (var t = [], r = 0; r < e.columns; r++) { for (var n = 0, i = 0; i < e.rows; i++)n += e.get(i, r) ** 2 / (e.rows - 1); t.push(Math.sqrt(n)); } return t; }(this)); else if (!u.isAnyArray(r)) throw new TypeError('scale must be an array'); return (function (e, t) { for (let r = 0; r < e.rows; r++) for (let n = 0; n < e.columns; n++)e.set(r, n, e.get(r, n) / t[n]); }(this, r)), this; case void 0: if (void 0 === r)r = (function (e) { for (var t = e.size - 1, r = 0, n = 0; n < e.columns; n++) for (let i = 0; i < e.rows; i++)r += e.get(i, n) ** 2 / t; return Math.sqrt(r); }(this)); else if (typeof r !== 'number') throw new TypeError('scale must be a number'); return (function (e, t) { for (let r = 0; r < e.rows; r++) for (let n = 0; n < e.columns; n++)e.set(r, n, e.get(r, n) / t); }(this, r)), this; default: throw new Error('invalid option: '.concat(e)); } } }, { key: 'toString', value(e) { return f(this, e); } }], [{ key: 'from1DArray', value(e, t, r) { if (e * t !== r.length) throw new RangeError('data length does not match given dimensions'); for (var n = new C(e, t), i = 0; i < e; i++) for (let a = 0; a < t; a++)n.set(i, a, r[i * t + a]); return n; } }, { key: 'rowVector', value(e) { for (var t = new C(1, e.length), r = 0; r < e.length; r++)t.set(0, r, e[r]); return t; } }, { key: 'columnVector', value(e) { for (var t = new C(e.length, 1), r = 0; r < e.length; r++)t.set(r, 0, e[r]); return t; } }, { key: 'zeros', value(e, t) { return new C(e, t); } }, { key: 'ones', value(e, t) { return new C(e, t).fill(1); } }, { key: 'rand', value(e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (typeof r !== 'object') throw new TypeError('options must be an object'); for (var n = r.random, i = void 0 === n ? Math.random : n, a = new C(e, t), o = 0; o < e; o++) for (let s = 0; s < t; s++)a.set(o, s, i()); return a; } }, { key: 'randInt', value(e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (typeof r !== 'object') throw new TypeError('options must be an object'); const n = r.min; const i = void 0 === n ? 0 : n; const a = r.max; const o = void 0 === a ? 1e3 : a; const s = r.random; const u = void 0 === s ? Math.random : s; if (!Number.isInteger(i)) throw new TypeError('min must be an integer'); if (!Number.isInteger(o)) throw new TypeError('max must be an integer'); if (i >= o) throw new RangeError('min must be smaller than max'); for (var l = o - i, c = new C(e, t), h = 0; h < e; h++) for (let f = 0; f < t; f++) { const d = i + Math.round(u() * l); c.set(h, f, d); } return c; } }, { key: 'eye', value(e, t, r) { void 0 === t && (t = e), void 0 === r && (r = 1); for (var n = Math.min(e, t), i = this.zeros(e, t), a = 0; a < n; a++)i.set(a, a, r); return i; } }, { key: 'diag', value(e, t, r) { const n = e.length; void 0 === t && (t = n), void 0 === r && (r = t); for (var i = Math.min(n, t, r), a = this.zeros(t, r), o = 0; o < i; o++)a.set(o, o, e[o]); return a; } }, { key: 'min', value(e, t) { e = this.checkMatrix(e), t = this.checkMatrix(t); for (var r = e.rows, n = e.columns, i = new C(r, n), a = 0; a < r; a++) for (let o = 0; o < n; o++)i.set(a, o, Math.min(e.get(a, o), t.get(a, o))); return i; } }, { key: 'max', value(e, t) { e = this.checkMatrix(e), t = this.checkMatrix(t); for (var r = e.rows, n = e.columns, i = new this(r, n), a = 0; a < r; a++) for (let o = 0; o < n; o++)i.set(a, o, Math.max(e.get(a, o), t.get(a, o))); return i; } }, { key: 'checkMatrix', value(t) { return e.isMatrix(t) ? t : new C(t); } }, { key: 'isMatrix', value(e) { return e != null && e.klass === 'Matrix'; } }]), e; }()); function E(e, t) { return e - t; }M.prototype.klass = 'Matrix', typeof Symbol !== 'undefined' && (M.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return f(this); }), M.random = M.rand, M.randomInt = M.randInt, M.diagonal = M.diag, M.prototype.diagonal = M.prototype.diag, M.identity = M.eye, M.prototype.negate = M.prototype.neg, M.prototype.tensorProduct = M.prototype.kroneckerProduct; var C = (function (e) { i(r, e); const t = a(r); function r(e, i) { let a; if (o(this, r), a = t.call(this), r.isMatrix(e)) return n(a, e.clone()); if (Number.isInteger(e) && e >= 0) { if (a.data = [], !(Number.isInteger(i) && i >= 0)) throw new TypeError('nColumns must be a positive integer'); for (let s = 0; s < e; s++)a.data.push(new Float64Array(i)); } else { if (!u.isAnyArray(e)) throw new TypeError('First argument must be a positive number or an array'); const l = e; if (typeof (i = (e = l.length) ? l[0].length : 0) !== 'number') throw new TypeError('Data must be a 2D array with at least one element'); a.data = []; for (let c = 0; c < e; c++) { if (l[c].length !== i) throw new RangeError('Inconsistent array dimensions'); if (!l[c].every(((e) => typeof e === 'number'))) throw new TypeError('Input data contains non-numeric values'); a.data.push(Float64Array.from(l[c])); } } return a.rows = e, a.columns = i, a; } return s(r, [{ key: 'set', value(e, t, r) { return this.data[e][t] = r, this; } }, { key: 'get', value(e, t) { return this.data[e][t]; } }, { key: 'removeRow', value(e) { return m(this, e), this.data.splice(e, 1), this.rows -= 1, this; } }, { key: 'addRow', value(e, t) { return void 0 === t && (t = e, e = this.rows), m(this, e, !0), t = Float64Array.from(g(this, t)), this.data.splice(e, 0, t), this.rows += 1, this; } }, { key: 'removeColumn', value(e) { v(this, e); for (let t = 0; t < this.rows; t++) { for (var r = new Float64Array(this.columns - 1), n = 0; n < e; n++)r[n] = this.data[t][n]; for (let i = e + 1; i < this.columns; i++)r[i - 1] = this.data[t][i]; this.data[t] = r; } return this.columns -= 1, this; } }, { key: 'addColumn', value(e, t) { typeof t === 'undefined' && (t = e, e = this.columns), v(this, e, !0), t = y(this, t); for (let r = 0; r < this.rows; r++) { for (var n = new Float64Array(this.columns + 1), i = 0; i < e; i++)n[i] = this.data[r][i]; for (n[i++] = t[r]; i < this.columns + 1; i++)n[i] = this.data[r][i - 1]; this.data[r] = n; } return this.columns += 1, this; } }]), r; }(M)); !(function (e, t) { e.prototype.add = function (e) { return typeof e === 'number' ? this.addS(e) : this.addM(e); }, e.prototype.addS = function (e) { for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) + e); return this; }, e.prototype.addM = function (e) { if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError('Matrices dimensions must be equal'); for (let r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.set(r, n, this.get(r, n) + e.get(r, n)); return this; }, e.add = function (e, r) { return new t(e).add(r); }, e.prototype.sub = function (e) { return typeof e === 'number' ? this.subS(e) : this.subM(e); }, e.prototype.subS = function (e) { for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) - e); return this; }, e.prototype.subM = function (e) { if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError('Matrices dimensions must be equal'); for (let r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.set(r, n, this.get(r, n) - e.get(r, n)); return this; }, e.sub = function (e, r) { return new t(e).sub(r); }, e.prototype.subtract = e.prototype.sub, e.prototype.subtractS = e.prototype.subS, e.prototype.subtractM = e.prototype.subM, e.subtract = e.sub, e.prototype.mul = function (e) { return typeof e === 'number' ? this.mulS(e) : this.mulM(e); }, e.prototype.mulS = function (e) { for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) * e); return this; }, e.prototype.mulM = function (e) { if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError('Matrices dimensions must be equal'); for (let r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.set(r, n, this.get(r, n) * e.get(r, n)); return this; }, e.mul = function (e, r) { return new t(e).mul(r); }, e.prototype.multiply = e.prototype.mul, e.prototype.multiplyS = e.prototype.mulS, e.prototype.multiplyM = e.prototype.mulM, e.multiply = e.mul, e.prototype.div = function (e) { return typeof e === 'number' ? this.divS(e) : this.divM(e); }, e.prototype.divS = function (e) { for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) / e); return this; }, e.prototype.divM = function (e) { if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError('Matrices dimensions must be equal'); for (let r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.set(r, n, this.get(r, n) / e.get(r, n)); return this; }, e.div = function (e, r) { return new t(e).div(r); }, e.prototype.divide = e.prototype.div, e.prototype.divideS = e.prototype.divS, e.prototype.divideM = e.prototype.divM, e.divide = e.div, e.prototype.mod = function (e) { return typeof e === 'number' ? this.modS(e) : this.modM(e); }, e.prototype.modS = function (e) { for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) % e); return this; }, e.prototype.modM = function (e) { if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError('Matrices dimensions must be equal'); for (let r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.set(r, n, this.get(r, n) % e.get(r, n)); return this; }, e.mod = function (e, r) { return new t(e).mod(r); }, e.prototype.modulus = e.prototype.mod, e.prototype.modulusS = e.prototype.modS, e.prototype.modulusM = e.prototype.modM, e.modulus = e.mod, e.prototype.and = function (e) { return typeof e === 'number' ? this.andS(e) : this.andM(e); }, e.prototype.andS = function (e) { for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) & e); return this; }, e.prototype.andM = function (e) { if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError('Matrices dimensions must be equal'); for (let r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.set(r, n, this.get(r, n) & e.get(r, n)); return this; }, e.and = function (e, r) { return new t(e).and(r); }, e.prototype.or = function (e) { return typeof e === 'number' ? this.orS(e) : this.orM(e); }, e.prototype.orS = function (e) { for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) | e); return this; }, e.prototype.orM = function (e) { if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError('Matrices dimensions must be equal'); for (let r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.set(r, n, this.get(r, n) | e.get(r, n)); return this; }, e.or = function (e, r) { return new t(e).or(r); }, e.prototype.xor = function (e) { return typeof e === 'number' ? this.xorS(e) : this.xorM(e); }, e.prototype.xorS = function (e) { for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) ^ e); return this; }, e.prototype.xorM = function (e) { if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError('Matrices dimensions must be equal'); for (let r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.set(r, n, this.get(r, n) ^ e.get(r, n)); return this; }, e.xor = function (e, r) { return new t(e).xor(r); }, e.prototype.leftShift = function (e) { return typeof e === 'number' ? this.leftShiftS(e) : this.leftShiftM(e); }, e.prototype.leftShiftS = function (e) { for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) << e); return this; }, e.prototype.leftShiftM = function (e) { if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError('Matrices dimensions must be equal'); for (let r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.set(r, n, this.get(r, n) << e.get(r, n)); return this; }, e.leftShift = function (e, r) { return new t(e).leftShift(r); }, e.prototype.signPropagatingRightShift = function (e) { return typeof e === 'number' ? this.signPropagatingRightShiftS(e) : this.signPropagatingRightShiftM(e); }, e.prototype.signPropagatingRightShiftS = function (e) { for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) >> e); return this; }, e.prototype.signPropagatingRightShiftM = function (e) { if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError('Matrices dimensions must be equal'); for (let r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.set(r, n, this.get(r, n) >> e.get(r, n)); return this; }, e.signPropagatingRightShift = function (e, r) { return new t(e).signPropagatingRightShift(r); }, e.prototype.rightShift = function (e) { return typeof e === 'number' ? this.rightShiftS(e) : this.rightShiftM(e); }, e.prototype.rightShiftS = function (e) { for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) >>> e); return this; }, e.prototype.rightShiftM = function (e) { if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError('Matrices dimensions must be equal'); for (let r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.set(r, n, this.get(r, n) >>> e.get(r, n)); return this; }, e.rightShift = function (e, r) { return new t(e).rightShift(r); }, e.prototype.zeroFillRightShift = e.prototype.rightShift, e.prototype.zeroFillRightShiftS = e.prototype.rightShiftS, e.prototype.zeroFillRightShiftM = e.prototype.rightShiftM, e.zeroFillRightShift = e.rightShift, e.prototype.not = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, ~this.get(e, t)); return this; }, e.not = function (e) { return new t(e).not(); }, e.prototype.abs = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.abs(this.get(e, t))); return this; }, e.abs = function (e) { return new t(e).abs(); }, e.prototype.acos = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.acos(this.get(e, t))); return this; }, e.acos = function (e) { return new t(e).acos(); }, e.prototype.acosh = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.acosh(this.get(e, t))); return this; }, e.acosh = function (e) { return new t(e).acosh(); }, e.prototype.asin = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.asin(this.get(e, t))); return this; }, e.asin = function (e) { return new t(e).asin(); }, e.prototype.asinh = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.asinh(this.get(e, t))); return this; }, e.asinh = function (e) { return new t(e).asinh(); }, e.prototype.atan = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.atan(this.get(e, t))); return this; }, e.atan = function (e) { return new t(e).atan(); }, e.prototype.atanh = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.atanh(this.get(e, t))); return this; }, e.atanh = function (e) { return new t(e).atanh(); }, e.prototype.cbrt = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.cbrt(this.get(e, t))); return this; }, e.cbrt = function (e) { return new t(e).cbrt(); }, e.prototype.ceil = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.ceil(this.get(e, t))); return this; }, e.ceil = function (e) { return new t(e).ceil(); }, e.prototype.clz32 = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.clz32(this.get(e, t))); return this; }, e.clz32 = function (e) { return new t(e).clz32(); }, e.prototype.cos = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.cos(this.get(e, t))); return this; }, e.cos = function (e) { return new t(e).cos(); }, e.prototype.cosh = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.cosh(this.get(e, t))); return this; }, e.cosh = function (e) { return new t(e).cosh(); }, e.prototype.exp = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.exp(this.get(e, t))); return this; }, e.exp = function (e) { return new t(e).exp(); }, e.prototype.expm1 = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.expm1(this.get(e, t))); return this; }, e.expm1 = function (e) { return new t(e).expm1(); }, e.prototype.floor = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.floor(this.get(e, t))); return this; }, e.floor = function (e) { return new t(e).floor(); }, e.prototype.fround = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.fround(this.get(e, t))); return this; }, e.fround = function (e) { return new t(e).fround(); }, e.prototype.log = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.log(this.get(e, t))); return this; }, e.log = function (e) { return new t(e).log(); }, e.prototype.log1p = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.log1p(this.get(e, t))); return this; }, e.log1p = function (e) { return new t(e).log1p(); }, e.prototype.log10 = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.log10(this.get(e, t))); return this; }, e.log10 = function (e) { return new t(e).log10(); }, e.prototype.log2 = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.log2(this.get(e, t))); return this; }, e.log2 = function (e) { return new t(e).log2(); }, e.prototype.round = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.round(this.get(e, t))); return this; }, e.round = function (e) { return new t(e).round(); }, e.prototype.sign = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.sign(this.get(e, t))); return this; }, e.sign = function (e) { return new t(e).sign(); }, e.prototype.sin = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.sin(this.get(e, t))); return this; }, e.sin = function (e) { return new t(e).sin(); }, e.prototype.sinh = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.sinh(this.get(e, t))); return this; }, e.sinh = function (e) { return new t(e).sinh(); }, e.prototype.sqrt = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.sqrt(this.get(e, t))); return this; }, e.sqrt = function (e) { return new t(e).sqrt(); }, e.prototype.tan = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.tan(this.get(e, t))); return this; }, e.tan = function (e) { return new t(e).tan(); }, e.prototype.tanh = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.tanh(this.get(e, t))); return this; }, e.tanh = function (e) { return new t(e).tanh(); }, e.prototype.trunc = function () { for (let e = 0; e < this.rows; e++) for (let t = 0; t < this.columns; t++) this.set(e, t, Math.trunc(this.get(e, t))); return this; }, e.trunc = function (e) { return new t(e).trunc(); }, e.pow = function (e, r) { return new t(e).pow(r); }, e.prototype.pow = function (e) { return typeof e === 'number' ? this.powS(e) : this.powM(e); }, e.prototype.powS = function (e) { for (let t = 0; t < this.rows; t++) for (let r = 0; r < this.columns; r++) this.set(t, r, this.get(t, r) ** e); return this; }, e.prototype.powM = function (e) { if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError('Matrices dimensions must be equal'); for (let r = 0; r < this.rows; r++) for (let n = 0; n < this.columns; n++) this.set(r, n, this.get(r, n) ** e.get(r, n)); return this; }; }(M, C)); const P = (function (e) { i(r, e); const t = a(r); function r(e, n, i) { let a; return o(this, r), (a = t.call(this)).matrix = e, a.rows = n, a.columns = i, a; } return s(r); }(M)); const A = (function (e) { i(r, e); const t = a(r); function r(e, n) { let i; return o(this, r), v(e, n), (i = t.call(this, e, e.rows, 1)).column = n, i; } return s(r, [{ key: 'set', value(e, t, r) { return this.matrix.set(e, this.column, r), this; } }, { key: 'get', value(e) { return this.matrix.get(e, this.column); } }]), r; }(P)); const T = (function (e) { i(r, e); const t = a(r); function r(e, n) { let i; return o(this, r), w(e, n), (i = t.call(this, e, e.rows, n.length)).columnIndices = n, i; } return s(r, [{ key: 'set', value(e, t, r) { return this.matrix.set(e, this.columnIndices[t], r), this; } }, { key: 'get', value(e, t) { return this.matrix.get(e, this.columnIndices[t]); } }]), r; }(P)); const R = (function (e) { i(r, e); const t = a(r); function r(e) { return o(this, r), t.call(this, e, e.rows, e.columns); } return s(r, [{ key: 'set', value(e, t, r) { return this.matrix.set(e, this.columns - t - 1, r), this; } }, { key: 'get', value(e, t) { return this.matrix.get(e, this.columns - t - 1); } }]), r; }(P)); const I = (function (e) { i(r, e); const t = a(r); function r(e) { return o(this, r), t.call(this, e, e.rows, e.columns); } return s(r, [{ key: 'set', value(e, t, r) { return this.matrix.set(this.rows - e - 1, t, r), this; } }, { key: 'get', value(e, t) { return this.matrix.get(this.rows - e - 1, t); } }]), r; }(P)); const O = (function (e) { i(r, e); const t = a(r); function r(e, n) { let i; return o(this, r), m(e, n), (i = t.call(this, e, 1, e.columns)).row = n, i; } return s(r, [{ key: 'set', value(e, t, r) { return this.matrix.set(this.row, t, r), this; } }, { key: 'get', value(e, t) { return this.matrix.get(this.row, t); } }]), r; }(P)); const D = (function (e) { i(r, e); const t = a(r); function r(e, n) { let i; return o(this, r), b(e, n), (i = t.call(this, e, n.length, e.columns)).rowIndices = n, i; } return s(r, [{ key: 'set', value(e, t, r) { return this.matrix.set(this.rowIndices[e], t, r), this; } }, { key: 'get', value(e, t) { return this.matrix.get(this.rowIndices[e], t); } }]), r; }(P)); const z = (function (e) { i(r, e); const t = a(r); function r(e, n, i) { let a; return o(this, r), b(e, n), w(e, i), (a = t.call(this, e, n.length, i.length)).rowIndices = n, a.columnIndices = i, a; } return s(r, [{ key: 'set', value(e, t, r) { return this.matrix.set(this.rowIndices[e], this.columnIndices[t], r), this; } }, { key: 'get', value(e, t) { return this.matrix.get(this.rowIndices[e], this.columnIndices[t]); } }]), r; }(P)); const N = (function (e) { i(r, e); const t = a(r); function r(e, n, i, a, s) { let u; return o(this, r), k(e, n, i, a, s), (u = t.call(this, e, i - n + 1, s - a + 1)).startRow = n, u.startColumn = a, u; } return s(r, [{ key: 'set', value(e, t, r) { return this.matrix.set(this.startRow + e, this.startColumn + t, r), this; } }, { key: 'get', value(e, t) { return this.matrix.get(this.startRow + e, this.startColumn + t); } }]), r; }(P)); const L = (function (e) { i(r, e); const t = a(r); function r(e) { return o(this, r), t.call(this, e, e.columns, e.rows); } return s(r, [{ key: 'set', value(e, t, r) { return this.matrix.set(t, e, r), this; } }, { key: 'get', value(e, t) { return this.matrix.get(t, e); } }]), r; }(P)); const j = (function (e) { i(r, e); const t = a(r); function r(e) { let n; const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; o(this, r); const a = i.rows; const s = void 0 === a ? 1 : a; if (e.length % s !== 0) throw new Error('the data length is not divisible by the number of rows'); return (n = t.call(this)).rows = s, n.columns = e.length / s, n.data = e, n; } return s(r, [{ key: 'set', value(e, t, r) { const n = this._calculateIndex(e, t); return this.data[n] = r, this; } }, { key: 'get', value(e, t) { const r = this._calculateIndex(e, t); return this.data[r]; } }, { key: '_calculateIndex', value(e, t) { return e * this.columns + t; } }]), r; }(M)); const F = (function (e) { i(r, e); const t = a(r); function r(e) { let n; return o(this, r), (n = t.call(this)).data = e, n.rows = e.length, n.columns = e[0].length, n; } return s(r, [{ key: 'set', value(e, t, r) { return this.data[e][t] = r, this; } }, { key: 'get', value(e, t) { return this.data[e][t]; } }]), r; }(M)); const B = (function () { function e(t) { o(this, e); let r; let n; let i; let a; let s; let u; let l; let c; let h; const f = (t = F.checkMatrix(t)).clone(); const d = f.rows; const p = f.columns; const m = new Float64Array(d); let v = 1; for (r = 0; r < d; r++)m[r] = r; for (c = new Float64Array(d), n = 0; n < p; n++) { for (r = 0; r < d; r++)c[r] = f.get(r, n); for (r = 0; r < d; r++) { for (h = Math.min(r, n), s = 0, i = 0; i < h; i++)s += f.get(r, i) * c[i]; c[r] -= s, f.set(r, n, c[r]); } for (a = n, r = n + 1; r < d; r++)Math.abs(c[r]) > Math.abs(c[a]) && (a = r); if (a !== n) { for (i = 0; i < p; i++)u = f.get(a, i), f.set(a, i, f.get(n, i)), f.set(n, i, u); l = m[a], m[a] = m[n], m[n] = l, v = -v; } if (n < d && f.get(n, n) !== 0) for (r = n + 1; r < d; r++)f.set(r, n, f.get(r, n) / f.get(n, n)); } this.LU = f, this.pivotVector = m, this.pivotSign = v; } return s(e, [{ key: 'isSingular', value() { for (let e = this.LU, t = e.columns, r = 0; r < t; r++) if (e.get(r, r) === 0) return !0; return !1; } }, { key: 'solve', value(e) { e = C.checkMatrix(e); const t = this.LU; if (t.rows !== e.rows) throw new Error('Invalid matrix dimensions'); if (this.isSingular()) throw new Error('LU matrix is singular'); let r; let n; let i; const a = e.columns; const o = e.subMatrixRow(this.pivotVector, 0, a - 1); const s = t.columns; for (i = 0; i < s; i++) for (r = i + 1; r < s; r++) for (n = 0; n < a; n++)o.set(r, n, o.get(r, n) - o.get(i, n) * t.get(r, i)); for (i = s - 1; i >= 0; i--) { for (n = 0; n < a; n++)o.set(i, n, o.get(i, n) / t.get(i, i)); for (r = 0; r < i; r++) for (n = 0; n < a; n++)o.set(r, n, o.get(r, n) - o.get(i, n) * t.get(r, i)); } return o; } }, { key: 'determinant', get() { const e = this.LU; if (!e.isSquare()) throw new Error('Matrix must be square'); for (var t = this.pivotSign, r = e.columns, n = 0; n < r; n++)t *= e.get(n, n); return t; } }, { key: 'lowerTriangularMatrix', get() { for (var e = this.LU, t = e.rows, r = e.columns, n = new C(t, r), i = 0; i < t; i++) for (let a = 0; a < r; a++)i > a ? n.set(i, a, e.get(i, a)) : i === a ? n.set(i, a, 1) : n.set(i, a, 0); return n; } }, { key: 'upperTriangularMatrix', get() { for (var e = this.LU, t = e.rows, r = e.columns, n = new C(t, r), i = 0; i < t; i++) for (let a = 0; a < r; a++)i <= a ? n.set(i, a, e.get(i, a)) : n.set(i, a, 0); return n; } }, { key: 'pivotPermutationVector', get() { return Array.from(this.pivotVector); } }]), e; }()); function U(e, t) { let r = 0; return Math.abs(e) > Math.abs(t) ? (r = t / e, Math.abs(e) * Math.sqrt(1 + r * r)) : t !== 0 ? (r = e / t, Math.abs(t) * Math.sqrt(1 + r * r)) : 0; } const V = (function () { function e(t) { o(this, e); let r; let n; let i; let a; const s = (t = F.checkMatrix(t)).clone(); const u = t.rows; const l = t.columns; const c = new Float64Array(l); for (i = 0; i < l; i++) { let h = 0; for (r = i; r < u; r++)h = U(h, s.get(r, i)); if (h !== 0) { for (s.get(i, i) < 0 && (h = -h), r = i; r < u; r++)s.set(r, i, s.get(r, i) / h); for (s.set(i, i, s.get(i, i) + 1), n = i + 1; n < l; n++) { for (a = 0, r = i; r < u; r++)a += s.get(r, i) * s.get(r, n); for (a = -a / s.get(i, i), r = i; r < u; r++)s.set(r, n, s.get(r, n) + a * s.get(r, i)); } }c[i] = -h; } this.QR = s, this.Rdiag = c; } return s(e, [{ key: 'solve', value(e) { e = C.checkMatrix(e); const t = this.QR; const r = t.rows; if (e.rows !== r) throw new Error('Matrix row dimensions must agree'); if (!this.isFullRank()) throw new Error('Matrix is rank deficient'); let n; let i; let a; let o; const s = e.columns; const u = e.clone(); const l = t.columns; for (a = 0; a < l; a++) for (i = 0; i < s; i++) { for (o = 0, n = a; n < r; n++)o += t.get(n, a) * u.get(n, i); for (o = -o / t.get(a, a), n = a; n < r; n++)u.set(n, i, u.get(n, i) + o * t.get(n, a)); } for (a = l - 1; a >= 0; a--) { for (i = 0; i < s; i++)u.set(a, i, u.get(a, i) / this.Rdiag[a]); for (n = 0; n < a; n++) for (i = 0; i < s; i++)u.set(n, i, u.get(n, i) - u.get(a, i) * t.get(n, a)); } return u.subMatrix(0, l - 1, 0, s - 1); } }, { key: 'isFullRank', value() { for (let e = this.QR.columns, t = 0; t < e; t++) if (this.Rdiag[t] === 0) return !1; return !0; } }, { key: 'upperTriangularMatrix', get() { let e; let t; const r = this.QR; const n = r.columns; const i = new C(n, n); for (e = 0; e < n; e++) for (t = 0; t < n; t++)e < t ? i.set(e, t, r.get(e, t)) : e === t ? i.set(e, t, this.Rdiag[e]) : i.set(e, t, 0); return i; } }, { key: 'orthogonalMatrix', get() { let e; let t; let r; let n; const i = this.QR; const a = i.rows; const o = i.columns; const s = new C(a, o); for (r = o - 1; r >= 0; r--) { for (e = 0; e < a; e++)s.set(e, r, 0); for (s.set(r, r, 1), t = r; t < o; t++) if (i.get(r, r) !== 0) { for (n = 0, e = r; e < a; e++)n += i.get(e, r) * s.get(e, t); for (n = -n / i.get(r, r), e = r; e < a; e++)s.set(e, t, s.get(e, t) + n * i.get(e, r)); } } return s; } }]), e; }()); const Y = (function () { function e(t) { const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (o(this, e), (t = F.checkMatrix(t)).isEmpty()) throw new Error('Matrix must be non-empty'); let n; let i = t.rows; let a = t.columns; const s = r.computeLeftSingularVectors; const u = void 0 === s || s; const l = r.computeRightSingularVectors; const c = void 0 === l || l; const h = r.autoTranspose; const f = void 0 !== h && h; let d = Boolean(u); let p = Boolean(c); let m = !1; if (i < a) if (f) { i = (n = t.transpose()).rows, a = n.columns, m = !0; const v = d; d = p, p = v; } else n = t.clone(), console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose'); else n = t.clone(); for (var g = Math.min(i, a), y = Math.min(i + 1, a), b = new Float64Array(y), w = new C(i, g), k = new C(a, a), x = new Float64Array(a), _ = new Float64Array(i), S = new Float64Array(y), M = 0; M < y; M++)S[M] = M; for (var E = Math.min(i - 1, a), P = Math.max(0, Math.min(a - 2, i)), A = Math.max(E, P), T = 0; T < A; T++) { if (T < E) { b[T] = 0; for (let R = T; R < i; R++)b[T] = U(b[T], n.get(R, T)); if (b[T] !== 0) { n.get(T, T) < 0 && (b[T] = -b[T]); for (let I = T; I < i; I++)n.set(I, T, n.get(I, T) / b[T]); n.set(T, T, n.get(T, T) + 1); }b[T] = -b[T]; } for (let O = T + 1; O < a; O++) { if (T < E && b[T] !== 0) { for (var D = 0, z = T; z < i; z++)D += n.get(z, T) * n.get(z, O); D = -D / n.get(T, T); for (let N = T; N < i; N++)n.set(N, O, n.get(N, O) + D * n.get(N, T)); }x[O] = n.get(T, O); } if (d && T < E) for (let L = T; L < i; L++)w.set(L, T, n.get(L, T)); if (T < P) { x[T] = 0; for (let j = T + 1; j < a; j++)x[T] = U(x[T], x[j]); if (x[T] !== 0) { x[T + 1] < 0 && (x[T] = 0 - x[T]); for (let B = T + 1; B < a; B++)x[B] /= x[T]; x[T + 1] += 1; } if (x[T] = -x[T], T + 1 < i && x[T] !== 0) { for (let V = T + 1; V < i; V++)_[V] = 0; for (let Y = T + 1; Y < i; Y++) for (let H = T + 1; H < a; H++)_[Y] += x[H] * n.get(Y, H); for (let q = T + 1; q < a; q++) for (let W = -x[q] / x[T + 1], X = T + 1; X < i; X++)n.set(X, q, n.get(X, q) + W * _[X]); } if (p) for (let G = T + 1; G < a; G++)k.set(G, T, x[G]); } } let $ = Math.min(a, i + 1); if (E < a && (b[E] = n.get(E, E)), i < $ && (b[$ - 1] = 0), P + 1 < $ && (x[P] = n.get(P, $ - 1)), x[$ - 1] = 0, d) { for (let Z = E; Z < g; Z++) { for (let K = 0; K < i; K++)w.set(K, Z, 0); w.set(Z, Z, 1); } for (let Q = E - 1; Q >= 0; Q--) if (b[Q] !== 0) { for (let J = Q + 1; J < g; J++) { for (var ee = 0, te = Q; te < i; te++)ee += w.get(te, Q) * w.get(te, J); ee = -ee / w.get(Q, Q); for (let re = Q; re < i; re++)w.set(re, J, w.get(re, J) + ee * w.get(re, Q)); } for (let ne = Q; ne < i; ne++)w.set(ne, Q, -w.get(ne, Q)); w.set(Q, Q, 1 + w.get(Q, Q)); for (let ie = 0; ie < Q - 1; ie++)w.set(ie, Q, 0); } else { for (let ae = 0; ae < i; ae++)w.set(ae, Q, 0); w.set(Q, Q, 1); } } if (p) for (let oe = a - 1; oe >= 0; oe--) { if (oe < P && x[oe] !== 0) for (let se = oe + 1; se < a; se++) { for (var ue = 0, le = oe + 1; le < a; le++)ue += k.get(le, oe) * k.get(le, se); ue = -ue / k.get(oe + 1, oe); for (let ce = oe + 1; ce < a; ce++)k.set(ce, se, k.get(ce, se) + ue * k.get(ce, oe)); } for (let he = 0; he < a; he++)k.set(he, oe, 0); k.set(oe, oe, 1); } for (let fe = $ - 1, de = Number.EPSILON; $ > 0;) { let pe = void 0; let me = void 0; for (pe = $ - 2; pe >= -1 && pe !== -1; pe--) { const ve = Number.MIN_VALUE + de * Math.abs(b[pe] + Math.abs(b[pe + 1])); if (Math.abs(x[pe]) <= ve || Number.isNaN(x[pe])) { x[pe] = 0; break; } } if (pe === $ - 2)me = 4; else { let ge = void 0; for (ge = $ - 1; ge >= pe && ge !== pe; ge--) { const ye = (ge !== $ ? Math.abs(x[ge]) : 0) + (ge !== pe + 1 ? Math.abs(x[ge - 1]) : 0); if (Math.abs(b[ge]) <= de * ye) { b[ge] = 0; break; } }ge === pe ? me = 3 : ge === $ - 1 ? me = 1 : (me = 2, pe = ge); } switch (pe++, me) { case 1: var be = x[$ - 2]; x[$ - 2] = 0; for (let we = $ - 2; we >= pe; we--) { let ke = U(b[we], be); const xe = b[we] / ke; const _e = be / ke; if (b[we] = ke, we !== pe && (be = -_e * x[we - 1], x[we - 1] = xe * x[we - 1]), p) for (let Se = 0; Se < a; Se++)ke = xe * k.get(Se, we) + _e * k.get(Se, $ - 1), k.set(Se, $ - 1, -_e * k.get(Se, we) + xe * k.get(Se, $ - 1)), k.set(Se, we, ke); } break; case 2: var Me = x[pe - 1]; x[pe - 1] = 0; for (let Ee = pe; Ee < $; Ee++) { let Ce = U(b[Ee], Me); const Pe = b[Ee] / Ce; const Ae = Me / Ce; if (b[Ee] = Ce, Me = -Ae * x[Ee], x[Ee] = Pe * x[Ee], d) for (let Te = 0; Te < i; Te++)Ce = Pe * w.get(Te, Ee) + Ae * w.get(Te, pe - 1), w.set(Te, pe - 1, -Ae * w.get(Te, Ee) + Pe * w.get(Te, pe - 1)), w.set(Te, Ee, Ce); } break; case 3: var Re = Math.max(Math.abs(b[$ - 1]), Math.abs(b[$ - 2]), Math.abs(x[$ - 2]), Math.abs(b[pe]), Math.abs(x[pe])); var Ie = b[$ - 1] / Re; var Oe = b[$ - 2] / Re; var De = x[$ - 2] / Re; var ze = b[pe] / Re; var Ne = x[pe] / Re; var Le = ((Oe + Ie) * (Oe - Ie) + De * De) / 2; var je = Ie * De * (Ie * De); var Fe = 0; Le === 0 && je === 0 || (Fe = je / (Le + (Fe = Le < 0 ? 0 - Math.sqrt(Le * Le + je) : Math.sqrt(Le * Le + je)))); for (var Be = (ze + Ie) * (ze - Ie) + Fe, Ue = ze * Ne, Ve = pe; Ve < $ - 1; Ve++) { let Ye = U(Be, Ue); Ye === 0 && (Ye = Number.MIN_VALUE); let He = Be / Ye; let qe = Ue / Ye; if (Ve !== pe && (x[Ve - 1] = Ye), Be = He * b[Ve] + qe * x[Ve], x[Ve] = He * x[Ve] - qe * b[Ve], Ue = qe * b[Ve + 1], b[Ve + 1] = He * b[Ve + 1], p) for (let We = 0; We < a; We++)Ye = He * k.get(We, Ve) + qe * k.get(We, Ve + 1), k.set(We, Ve + 1, -qe * k.get(We, Ve) + He * k.get(We, Ve + 1)), k.set(We, Ve, Ye); if ((Ye = U(Be, Ue)) === 0 && (Ye = Number.MIN_VALUE), He = Be / Ye, qe = Ue / Ye, b[Ve] = Ye, Be = He * x[Ve] + qe * b[Ve + 1], b[Ve + 1] = -qe * x[Ve] + He * b[Ve + 1], Ue = qe * x[Ve + 1], x[Ve + 1] = He * x[Ve + 1], d && Ve < i - 1) for (let Xe = 0; Xe < i; Xe++)Ye = He * w.get(Xe, Ve) + qe * w.get(Xe, Ve + 1), w.set(Xe, Ve + 1, -qe * w.get(Xe, Ve) + He * w.get(Xe, Ve + 1)), w.set(Xe, Ve, Ye); }x[$ - 2] = Be; break; case 4: if (b[pe] <= 0 && (b[pe] = b[pe] < 0 ? -b[pe] : 0, p)) for (let Ge = 0; Ge <= fe; Ge++)k.set(Ge, pe, -k.get(Ge, pe)); for (;pe < fe && !(b[pe] >= b[pe + 1]);) { let $e = b[pe]; if (b[pe] = b[pe + 1], b[pe + 1] = $e, p && pe < a - 1) for (let Ze = 0; Ze < a; Ze++)$e = k.get(Ze, pe + 1), k.set(Ze, pe + 1, k.get(Ze, pe)), k.set(Ze, pe, $e); if (d && pe < i - 1) for (let Ke = 0; Ke < i; Ke++)$e = w.get(Ke, pe + 1), w.set(Ke, pe + 1, w.get(Ke, pe)), w.set(Ke, pe, $e); pe++; }$--; } } if (m) { const Qe = k; k = w, w = Qe; } this.m = i, this.n = a, this.s = b, this.U = w, this.V = k; } return s(e, [{ key: 'solve', value(e) { for (var t = e, r = this.threshold, n = this.s.length, i = C.zeros(n, n), a = 0; a < n; a++)Math.abs(this.s[a]) <= r ? i.set(a, a, 0) : i.set(a, a, 1 / this.s[a]); for (var o = this.U, s = this.rightSingularVectors, u = s.mmul(i), l = s.rows, c = o.rows, h = C.zeros(l, c), f = 0; f < l; f++) for (let d = 0; d < c; d++) { for (var p = 0, m = 0; m < n; m++)p += u.get(f, m) * o.get(d, m); h.set(f, d, p); } return h.mmul(t); } }, { key: 'solveForDiagonal', value(e) { return this.solve(C.diag(e)); } }, { key: 'inverse', value() { for (var e = this.V, t = this.threshold, r = e.rows, n = e.columns, i = new C(r, this.s.length), a = 0; a < r; a++) for (let o = 0; o < n; o++)Math.abs(this.s[o]) > t && i.set(a, o, e.get(a, o) / this.s[o]); for (var s = this.U, u = s.rows, l = s.columns, c = new C(r, u), h = 0; h < r; h++) for (let f = 0; f < u; f++) { for (var d = 0, p = 0; p < l; p++)d += i.get(h, p) * s.get(f, p); c.set(h, f, d); } return c; } }, { key: 'condition', get() { return this.s[0] / this.s[Math.min(this.m, this.n) - 1]; } }, { key: 'norm2', get() { return this.s[0]; } }, { key: 'rank', get() { for (var e = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON, t = 0, r = this.s, n = 0, i = r.length; n < i; n++)r[n] > e && t++; return t; } }, { key: 'diagonal', get() { return Array.from(this.s); } }, { key: 'threshold', get() { return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0]; } }, { key: 'leftSingularVectors', get() { return this.U; } }, { key: 'rightSingularVectors', get() { return this.V; } }, { key: 'diagonalMatrix', get() { return C.diag(this.s); } }]), e; }()); function H(e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; return e = F.checkMatrix(e), t = F.checkMatrix(t), r ? new Y(e).solve(t) : e.isSquare() ? new B(e).solve(t) : new V(e).solve(t); } function q(e, t) { for (var r = [], n = 0; n < e; n++)n !== t && r.push(n); return r; } function W(e, t, r) { const n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e-9; if (e > (arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e-9)) return new Array(t.rows + 1).fill(0); for (var i = t.addRow(r, [0]), a = 0; a < i.rows; a++)Math.abs(i.get(a, 0)) < n && i.set(a, 0, 0); return i.to1DArray(); } const X = (function () { function e(t) { const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; o(this, e); const n = r.assumeSymmetric; const i = void 0 !== n && n; if (!(t = F.checkMatrix(t)).isSquare()) throw new Error('Matrix is not a square matrix'); if (t.isEmpty()) throw new Error('Matrix must be non-empty'); let a; let s; const u = t.columns; const l = new C(u, u); const c = new Float64Array(u); const h = new Float64Array(u); const f = t; if (!!i || t.isSymmetric()) { for (a = 0; a < u; a++) for (s = 0; s < u; s++)l.set(a, s, f.get(a, s)); !(function (e, t, r, n) { let i; let a; let o; let s; let u; let l; let c; let h; for (u = 0; u < e; u++)r[u] = n.get(e - 1, u); for (s = e - 1; s > 0; s--) { for (h = 0, o = 0, l = 0; l < s; l++)h += Math.abs(r[l]); if (h === 0) for (t[s] = r[s - 1], u = 0; u < s; u++)r[u] = n.get(s - 1, u), n.set(s, u, 0), n.set(u, s, 0); else { for (l = 0; l < s; l++)r[l] /= h, o += r[l] * r[l]; for (i = r[s - 1], a = Math.sqrt(o), i > 0 && (a = -a), t[s] = h * a, o -= i * a, r[s - 1] = i - a, u = 0; u < s; u++)t[u] = 0; for (u = 0; u < s; u++) { for (i = r[u], n.set(u, s, i), a = t[u] + n.get(u, u) * i, l = u + 1; l <= s - 1; l++)a += n.get(l, u) * r[l], t[l] += n.get(l, u) * i; t[u] = a; } for (i = 0, u = 0; u < s; u++)t[u] /= o, i += t[u] * r[u]; for (c = i / (o + o), u = 0; u < s; u++)t[u] -= c * r[u]; for (u = 0; u < s; u++) { for (i = r[u], a = t[u], l = u; l <= s - 1; l++)n.set(l, u, n.get(l, u) - (i * t[l] + a * r[l])); r[u] = n.get(s - 1, u), n.set(s, u, 0); } }r[s] = o; } for (s = 0; s < e - 1; s++) { if (n.set(e - 1, s, n.get(s, s)), n.set(s, s, 1), (o = r[s + 1]) !== 0) { for (l = 0; l <= s; l++)r[l] = n.get(l, s + 1) / o; for (u = 0; u <= s; u++) { for (a = 0, l = 0; l <= s; l++)a += n.get(l, s + 1) * n.get(l, u); for (l = 0; l <= s; l++)n.set(l, u, n.get(l, u) - a * r[l]); } } for (l = 0; l <= s; l++)n.set(l, s + 1, 0); } for (u = 0; u < e; u++)r[u] = n.get(e - 1, u), n.set(e - 1, u, 0); n.set(e - 1, e - 1, 1), t[0] = 0; }(u, h, c, l)), (function (e, t, r, n) { let i; let a; let o; let s; let u; let l; let c; let h; let f; let d; let p; let m; let v; let g; let y; let b; for (o = 1; o < e; o++)t[o - 1] = t[o]; t[e - 1] = 0; let w = 0; let k = 0; const x = Number.EPSILON; for (l = 0; l < e; l++) { for (k = Math.max(k, Math.abs(r[l]) + Math.abs(t[l])), c = l; c < e && !(Math.abs(t[c]) <= x * k);)c++; if (c > l) do { for (i = r[l], f = U(h = (r[l + 1] - i) / (2 * t[l]), 1), h < 0 && (f = -f), r[l] = t[l] / (h + f), r[l + 1] = t[l] * (h + f), d = r[l + 1], a = i - r[l], o = l + 2; o < e; o++)r[o] -= a; for (w += a, h = r[c], m = p = 1, v = p, g = t[l + 1], y = 0, b = 0, o = c - 1; o >= l; o--) for (v = m, m = p, b = y, i = p * t[o], a = p * h, f = U(h, t[o]), t[o + 1] = y * f, y = t[o] / f, h = (p = h / f) * r[o] - y * i, r[o + 1] = a + y * (p * i + y * r[o]), u = 0; u < e; u++)a = n.get(u, o + 1), n.set(u, o + 1, y * n.get(u, o) + p * a), n.set(u, o, p * n.get(u, o) - y * a); h = -y * b * v * g * t[l] / d, t[l] = y * h, r[l] = p * h; } while (Math.abs(t[l]) > x * k); r[l] = r[l] + w, t[l] = 0; } for (o = 0; o < e - 1; o++) { for (u = o, h = r[o], s = o + 1; s < e; s++)r[s] < h && (u = s, h = r[s]); if (u !== o) for (r[u] = r[o], r[o] = h, s = 0; s < e; s++)h = n.get(s, o), n.set(s, o, n.get(s, u)), n.set(s, u, h); } }(u, h, c, l)); } else { const d = new C(u, u); const p = new Float64Array(u); for (s = 0; s < u; s++) for (a = 0; a < u; a++)d.set(a, s, f.get(a, s)); !(function (e, t, r, n) { let i; let a; let o; let s; let u; let l; let c; const h = 0; const f = e - 1; for (l = h + 1; l <= f - 1; l++) { for (c = 0, s = l; s <= f; s++)c += Math.abs(t.get(s, l - 1)); if (c !== 0) { for (o = 0, s = f; s >= l; s--)r[s] = t.get(s, l - 1) / c, o += r[s] * r[s]; for (a = Math.sqrt(o), r[l] > 0 && (a = -a), o -= r[l] * a, r[l] = r[l] - a, u = l; u < e; u++) { for (i = 0, s = f; s >= l; s--)i += r[s] * t.get(s, u); for (i /= o, s = l; s <= f; s++)t.set(s, u, t.get(s, u) - i * r[s]); } for (s = 0; s <= f; s++) { for (i = 0, u = f; u >= l; u--)i += r[u] * t.get(s, u); for (i /= o, u = l; u <= f; u++)t.set(s, u, t.get(s, u) - i * r[u]); }r[l] = c * r[l], t.set(l, l - 1, c * a); } } for (s = 0; s < e; s++) for (u = 0; u < e; u++)n.set(s, u, s === u ? 1 : 0); for (l = f - 1; l >= h + 1; l--) if (t.get(l, l - 1) !== 0) { for (s = l + 1; s <= f; s++)r[s] = t.get(s, l - 1); for (u = l; u <= f; u++) { for (a = 0, s = l; s <= f; s++)a += r[s] * n.get(s, u); for (a = a / r[l] / t.get(l, l - 1), s = l; s <= f; s++)n.set(s, u, n.get(s, u) + a * r[s]); } } }(u, d, p, l)), (function (e, t, r, n, i) { let a; let o; let s; let u; let l; let c; let h; let f; let d; let p; let m; let v; let g; let y; let b; let w = e - 1; const k = 0; const x = e - 1; const _ = Number.EPSILON; let S = 0; let M = 0; let E = 0; let C = 0; let P = 0; let A = 0; let T = 0; let R = 0; for (a = 0; a < e; a++) for ((a < k || a > x) && (r[a] = i.get(a, a), t[a] = 0), o = Math.max(a - 1, 0); o < e; o++)M += Math.abs(i.get(a, o)); for (;w >= k;) { for (u = w; u > k && ((A = Math.abs(i.get(u - 1, u - 1)) + Math.abs(i.get(u, u))) === 0 && (A = M), !(Math.abs(i.get(u, u - 1)) < _ * A));)u--; if (u === w)i.set(w, w, i.get(w, w) + S), r[w] = i.get(w, w), t[w] = 0, w--, R = 0; else if (u === w - 1) { if (h = i.get(w, w - 1) * i.get(w - 1, w), C = (E = (i.get(w - 1, w - 1) - i.get(w, w)) / 2) * E + h, T = Math.sqrt(Math.abs(C)), i.set(w, w, i.get(w, w) + S), i.set(w - 1, w - 1, i.get(w - 1, w - 1) + S), f = i.get(w, w), C >= 0) { for (T = E >= 0 ? E + T : E - T, r[w - 1] = f + T, r[w] = r[w - 1], T !== 0 && (r[w] = f - h / T), t[w - 1] = 0, t[w] = 0, E = (f = i.get(w, w - 1)) / (A = Math.abs(f) + Math.abs(T)), C = T / A, E /= P = Math.sqrt(E * E + C * C), C /= P, o = w - 1; o < e; o++)T = i.get(w - 1, o), i.set(w - 1, o, C * T + E * i.get(w, o)), i.set(w, o, C * i.get(w, o) - E * T); for (a = 0; a <= w; a++)T = i.get(a, w - 1), i.set(a, w - 1, C * T + E * i.get(a, w)), i.set(a, w, C * i.get(a, w) - E * T); for (a = k; a <= x; a++)T = n.get(a, w - 1), n.set(a, w - 1, C * T + E * n.get(a, w)), n.set(a, w, C * n.get(a, w) - E * T); } else r[w - 1] = f + E, r[w] = f + E, t[w - 1] = T, t[w] = -T; w -= 2, R = 0; } else { if (f = i.get(w, w), d = 0, h = 0, u < w && (d = i.get(w - 1, w - 1), h = i.get(w, w - 1) * i.get(w - 1, w)), R === 10) { for (S += f, a = k; a <= w; a++)i.set(a, a, i.get(a, a) - f); f = d = 0.75 * (A = Math.abs(i.get(w, w - 1)) + Math.abs(i.get(w - 1, w - 2))), h = -0.4375 * A * A; } if (R === 30 && (A = (A = (d - f) / 2) * A + h) > 0) { for (A = Math.sqrt(A), d < f && (A = -A), A = f - h / ((d - f) / 2 + A), a = k; a <= w; a++)i.set(a, a, i.get(a, a) - A); S += A, f = d = h = 0.964; } for (R += 1, l = w - 2; l >= u && (E = ((P = f - (T = i.get(l, l))) * (A = d - T) - h) / i.get(l + 1, l) + i.get(l, l + 1), C = i.get(l + 1, l + 1) - T - P - A, P = i.get(l + 2, l + 1), E /= A = Math.abs(E) + Math.abs(C) + Math.abs(P), C /= A, P /= A, l !== u) && !(Math.abs(i.get(l, l - 1)) * (Math.abs(C) + Math.abs(P)) < _ * (Math.abs(E) * (Math.abs(i.get(l - 1, l - 1)) + Math.abs(T) + Math.abs(i.get(l + 1, l + 1)))));)l--; for (a = l + 2; a <= w; a++)i.set(a, a - 2, 0), a > l + 2 && i.set(a, a - 3, 0); for (s = l; s <= w - 1 && (y = s !== w - 1, s !== l && (E = i.get(s, s - 1), C = i.get(s + 1, s - 1), P = y ? i.get(s + 2, s - 1) : 0, (f = Math.abs(E) + Math.abs(C) + Math.abs(P)) !== 0 && (E /= f, C /= f, P /= f)), f !== 0); s++) if (A = Math.sqrt(E * E + C * C + P * P), E < 0 && (A = -A), A !== 0) { for (s !== l ? i.set(s, s - 1, -A * f) : u !== l && i.set(s, s - 1, -i.get(s, s - 1)), f = (E += A) / A, d = C / A, T = P / A, C /= E, P /= E, o = s; o < e; o++)E = i.get(s, o) + C * i.get(s + 1, o), y && (E += P * i.get(s + 2, o), i.set(s + 2, o, i.get(s + 2, o) - E * T)), i.set(s, o, i.get(s, o) - E * f), i.set(s + 1, o, i.get(s + 1, o) - E * d); for (a = 0; a <= Math.min(w, s + 3); a++)E = f * i.get(a, s) + d * i.get(a, s + 1), y && (E += T * i.get(a, s + 2), i.set(a, s + 2, i.get(a, s + 2) - E * P)), i.set(a, s, i.get(a, s) - E), i.set(a, s + 1, i.get(a, s + 1) - E * C); for (a = k; a <= x; a++)E = f * n.get(a, s) + d * n.get(a, s + 1), y && (E += T * n.get(a, s + 2), n.set(a, s + 2, n.get(a, s + 2) - E * P)), n.set(a, s, n.get(a, s) - E), n.set(a, s + 1, n.get(a, s + 1) - E * C); } } } if (M === 0) return; for (w = e - 1; w >= 0; w--) if (E = r[w], (C = t[w]) === 0) for (u = w, i.set(w, w, 1), a = w - 1; a >= 0; a--) { for (h = i.get(a, a) - E, P = 0, o = u; o <= w; o++)P += i.get(a, o) * i.get(o, w); if (t[a] < 0)T = h, A = P; else if (u = a, t[a] === 0 ? i.set(a, w, h !== 0 ? -P / h : -P / (_ * M)) : (f = i.get(a, a + 1), d = i.get(a + 1, a), c = (f * A - T * P) / (C = (r[a] - E) * (r[a] - E) + t[a] * t[a]), i.set(a, w, c), i.set(a + 1, w, Math.abs(f) > Math.abs(T) ? (-P - h * c) / f : (-A - d * c) / T)), _ * (c = Math.abs(i.get(a, w))) * c > 1) for (o = a; o <= w; o++)i.set(o, w, i.get(o, w) / c); } else if (C < 0) for (u = w - 1, Math.abs(i.get(w, w - 1)) > Math.abs(i.get(w - 1, w)) ? (i.set(w - 1, w - 1, C / i.get(w, w - 1)), i.set(w - 1, w, -(i.get(w, w) - E) / i.get(w, w - 1))) : (b = G(0, -i.get(w - 1, w), i.get(w - 1, w - 1) - E, C), i.set(w - 1, w - 1, b[0]), i.set(w - 1, w, b[1])), i.set(w, w - 1, 0), i.set(w, w, 1), a = w - 2; a >= 0; a--) { for (p = 0, m = 0, o = u; o <= w; o++)p += i.get(a, o) * i.get(o, w - 1), m += i.get(a, o) * i.get(o, w); if (h = i.get(a, a) - E, t[a] < 0)T = h, P = p, A = m; else if (u = a, t[a] === 0 ? (b = G(-p, -m, h, C), i.set(a, w - 1, b[0]), i.set(a, w, b[1])) : (f = i.get(a, a + 1), d = i.get(a + 1, a), v = (r[a] - E) * (r[a] - E) + t[a] * t[a] - C * C, g = 2 * (r[a] - E) * C, v === 0 && g === 0 && (v = _ * M * (Math.abs(h) + Math.abs(C) + Math.abs(f) + Math.abs(d) + Math.abs(T))), b = G(f * P - T * p + C * m, f * A - T * m - C * p, v, g), i.set(a, w - 1, b[0]), i.set(a, w, b[1]), Math.abs(f) > Math.abs(T) + Math.abs(C) ? (i.set(a + 1, w - 1, (-p - h * i.get(a, w - 1) + C * i.get(a, w)) / f), i.set(a + 1, w, (-m - h * i.get(a, w) - C * i.get(a, w - 1)) / f)) : (b = G(-P - d * i.get(a, w - 1), -A - d * i.get(a, w), T, C), i.set(a + 1, w - 1, b[0]), i.set(a + 1, w, b[1]))), _ * (c = Math.max(Math.abs(i.get(a, w - 1)), Math.abs(i.get(a, w)))) * c > 1) for (o = a; o <= w; o++)i.set(o, w - 1, i.get(o, w - 1) / c), i.set(o, w, i.get(o, w) / c); } for (a = 0; a < e; a++) if (a < k || a > x) for (o = a; o < e; o++)n.set(a, o, i.get(a, o)); for (o = e - 1; o >= k; o--) for (a = k; a <= x; a++) { for (T = 0, s = k; s <= Math.min(o, x); s++)T += n.get(a, s) * i.get(s, o); n.set(a, o, T); } }(u, h, c, l, d)); } this.n = u, this.e = h, this.d = c, this.V = l; } return s(e, [{ key: 'realEigenvalues', get() { return Array.from(this.d); } }, { key: 'imaginaryEigenvalues', get() { return Array.from(this.e); } }, { key: 'eigenvectorMatrix', get() { return this.V; } }, { key: 'diagonalMatrix', get() { let e; let t; const r = this.n; const n = this.e; const i = this.d; const a = new C(r, r); for (e = 0; e < r; e++) { for (t = 0; t < r; t++)a.set(e, t, 0); a.set(e, e, i[e]), n[e] > 0 ? a.set(e, e + 1, n[e]) : n[e] < 0 && a.set(e, e - 1, n[e]); } return a; } }]), e; }()); function G(e, t, r, n) { let i; let a; return Math.abs(r) > Math.abs(n) ? [(e + (i = n / r) * t) / (a = r + i * n), (t - i * e) / a] : [((i = r / n) * e + t) / (a = n + i * r), (i * t - e) / a]; } const $ = (function () { function e(t) { if (o(this, e), !(t = F.checkMatrix(t)).isSymmetric()) throw new Error('Matrix is not symmetric'); let r; let n; let i; const a = t; const s = a.rows; const u = new C(s, s); let l = !0; for (n = 0; n < s; n++) { let c = 0; for (i = 0; i < n; i++) { let h = 0; for (r = 0; r < i; r++)h += u.get(i, r) * u.get(n, r); h = (a.get(n, i) - h) / u.get(i, i), u.set(n, i, h), c += h * h; } for (l &= (c = a.get(n, n) - c) > 0, u.set(n, n, Math.sqrt(Math.max(c, 0))), i = n + 1; i < s; i++)u.set(n, i, 0); } this.L = u, this.positiveDefinite = Boolean(l); } return s(e, [{ key: 'isPositiveDefinite', value() { return this.positiveDefinite; } }, { key: 'solve', value(e) { e = F.checkMatrix(e); const t = this.L; const r = t.rows; if (e.rows !== r) throw new Error('Matrix dimensions do not match'); if (!1 === this.isPositiveDefinite()) throw new Error('Matrix is not positive definite'); let n; let i; let a; const o = e.columns; const s = e.clone(); for (a = 0; a < r; a++) for (i = 0; i < o; i++) { for (n = 0; n < a; n++)s.set(a, i, s.get(a, i) - s.get(n, i) * t.get(a, n)); s.set(a, i, s.get(a, i) / t.get(a, a)); } for (a = r - 1; a >= 0; a--) for (i = 0; i < o; i++) { for (n = a + 1; n < r; n++)s.set(a, i, s.get(a, i) - s.get(n, i) * t.get(n, a)); s.set(a, i, s.get(a, i) / t.get(a, a)); } return s; } }, { key: 'lowerTriangularMatrix', get() { return this.L; } }]), e; }()); const Z = s((function e(t) { const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; o(this, e), t = F.checkMatrix(t); let n; let i = r.Y; const a = r.scaleScores; const s = void 0 !== a && a; const l = r.maxIterations; const c = void 0 === l ? 1e3 : l; const h = r.terminationCriteria; const f = void 0 === h ? 1e-10 : h; if (i) { if ((i = u.isAnyArray(i) && typeof i[0] === 'number' ? C.columnVector(i) : F.checkMatrix(i)).rows !== t.rows) throw new Error('Y should have the same number of rows as X'); n = i.getColumnVector(0); } else n = t.getColumnVector(0); for (var d, p, m, v, g = 1, y = 0; y < c && g > f; y++)m = (m = t.transpose().mmul(n).div(n.transpose().mmul(n).get(0, 0))).div(m.norm()), d = t.mmul(m).div(m.transpose().mmul(m).get(0, 0)), y > 0 && (g = d.clone().sub(v).pow(2).sum()), v = d.clone(), i ? (p = (p = i.transpose().mmul(d).div(d.transpose().mmul(d).get(0, 0))).div(p.norm()), n = i.mmul(p).div(p.transpose().mmul(p).get(0, 0))) : n = d; if (i) { let b = t.transpose().mmul(d).div(d.transpose().mmul(d).get(0, 0)); b = b.div(b.norm()); const w = t.clone().sub(d.clone().mmul(b.transpose())); const k = n.transpose().mmul(d).div(d.transpose().mmul(d).get(0, 0)); const x = i.clone().sub(d.clone().mulS(k.get(0, 0)).mmul(p.transpose())); this.t = d, this.p = b.transpose(), this.w = m.transpose(), this.q = p, this.u = n, this.s = d.transpose().mmul(d), this.xResidual = w, this.yResidual = x, this.betas = k; } else this.w = m.transpose(), this.s = d.transpose().mmul(d).sqrt(), this.t = s ? d.clone().div(this.s.get(0, 0)) : d, this.xResidual = t.sub(d.mmul(m.transpose())); })); t.AbstractMatrix = M, t.CHO = $, t.CholeskyDecomposition = $, t.EVD = X, t.EigenvalueDecomposition = X, t.LU = B, t.LuDecomposition = B, t.Matrix = C, t.MatrixColumnSelectionView = T, t.MatrixColumnView = A, t.MatrixFlipColumnView = R, t.MatrixFlipRowView = I, t.MatrixRowSelectionView = D, t.MatrixRowView = O, t.MatrixSelectionView = z, t.MatrixSubView = N, t.MatrixTransposeView = L, t.NIPALS = Z, t.Nipals = Z, t.QR = V, t.QrDecomposition = V, t.SVD = Y, t.SingularValueDecomposition = Y, t.WrapperMatrix1D = j, t.WrapperMatrix2D = F, t.correlation = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e; let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; e = new C(e); let n = !1; if (typeof t !== 'object' || C.isMatrix(t) || u.isAnyArray(t) ? t = new C(t) : (r = t, t = e, n = !0), e.rows !== t.rows) throw new TypeError('Both matrices must have the same number of rows'); const i = r; const a = i.center; const o = void 0 === a || a; const s = i.scale; const l = void 0 === s || s; o && (e.center('column'), n || t.center('column')), l && (e.scale('column'), n || t.scale('column')); for (var c = e.standardDeviation('column', { unbiased: !0 }), h = n ? c : t.standardDeviation('column', { unbiased: !0 }), f = e.transpose().mmul(t), d = 0; d < f.rows; d++) for (let p = 0; p < f.columns; p++)f.set(d, p, f.get(d, p) * (1 / (c[d] * h[p])) * (1 / (e.rows - 1))); return f; }, t.covariance = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e; let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; e = new C(e); let n = !1; if (typeof t !== 'object' || C.isMatrix(t) || u.isAnyArray(t) ? t = new C(t) : (r = t, t = e, n = !0), e.rows !== t.rows) throw new TypeError('Both matrices must have the same number of rows'); const i = r.center; (void 0 === i || i) && (e = e.center('column'), n || (t = t.center('column'))); for (var a = e.transpose().mmul(t), o = 0; o < a.rows; o++) for (let s = 0; s < a.columns; s++)a.set(o, s, a.get(o, s) * (1 / (e.rows - 1))); return a; }, t.default = C, t.determinant = function e(t) { let r; let n; let i; let a; let o; let s; if ((t = C.checkMatrix(t)).isSquare()) return t.columns === 0 ? 1 : t.columns === 2 ? (r = t.get(0, 0), n = t.get(0, 1), i = t.get(1, 0), r * t.get(1, 1) - n * i) : t.columns === 3 ? (a = new z(t, [1, 2], [1, 2]), o = new z(t, [1, 2], [0, 2]), s = new z(t, [1, 2], [0, 1]), r = t.get(0, 0), n = t.get(0, 1), i = t.get(0, 2), r * e(a) - n * e(o) + i * e(s)) : new B(t).determinant; throw Error('determinant can only be calculated for a square matrix'); }, t.inverse = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; return e = F.checkMatrix(e), t ? new Y(e).inverse() : H(e, C.eye(e.rows)); }, t.linearDependencies = function (e) { for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = t.thresholdValue, n = void 0 === r ? 1e-9 : r, i = t.thresholdError, a = void 0 === i ? 1e-9 : i, o = (e = C.checkMatrix(e)).rows, s = new C(o, o), u = 0; u < o; u++) { const l = C.columnVector(e.getRow(u)); const c = e.subMatrixRow(q(o, u)).transpose(); const h = new Y(c).solve(l); const f = C.sub(l, c.mmul(h)).abs().max(); s.setRow(u, W(f, h, u, n, a)); } return s; }, t.pseudoInverse = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.EPSILON; if ((e = C.checkMatrix(e)).isEmpty()) return e.transpose(); for (var r = new Y(e, { autoTranspose: !0 }), n = r.leftSingularVectors, i = r.rightSingularVectors, a = r.diagonal, o = 0; o < a.length; o++)Math.abs(a[o]) > t ? a[o] = 1 / a[o] : a[o] = 0; return i.mmul(C.diag(a).mmul(n.transpose())); }, t.solve = H, t.wrap = function (e, t) { if (u.isAnyArray(e)) return e[0] && u.isAnyArray(e[0]) ? new F(e) : new j(e, t); throw new Error('the argument is not an array'); };
    },
    49(e) { e.exports = function (e, t) { e = e || 0; for (var r = new Array(e), n = 0; n < e; n++)r[n] = t; return r; }; },
    1257(e) { e.exports = function (e) { return e === 0 ? 1 : (e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, (e |= e >> 16) + 1); }; },
    888(e, t, r) {
      const n = r(9047); function i() {} function a() {}a.resetWarningCache = i, e.exports = function () {
        function e(e, t, r, i, a, o) { if (o !== n) { const s = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types'); throw s.name = 'Invariant Violation', s; } } function t() { return e; }e.isRequired = e; const r = {
          array: e, bigint: e, bool: e, func: e, number: e, object: e, string: e, symbol: e, any: e, arrayOf: t, element: e, elementType: e, instanceOf: t, node: e, objectOf: t, oneOf: t, oneOfType: t, shape: t, exact: t, checkPropTypes: a, resetWarningCache: i,
        }; return r.PropTypes = r, r;
      };
    },
    2007(e, t, r) { e.exports = r(888)(); },
    9047(e) {
      e.exports = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
    },
    4463(e, t, r) {
      const n = r(2791); const i = r(5296); function a(e) { for (var t = `https://reactjs.org/docs/error-decoder.html?invariant=${e}`, r = 1; r < arguments.length; r++)t += `&args[]=${encodeURIComponent(arguments[r])}`; return `Minified React error #${e}; visit ${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`; } const o = new Set(); const
        s = {}; function u(e, t) { l(e, t), l(`${e}Capture`, t); } function l(e, t) { for (s[e] = t, e = 0; e < t.length; e++)o.add(t[e]); } const c = !(typeof window === 'undefined' || typeof window.document === 'undefined' || typeof window.document.createElement === 'undefined'); const h = Object.prototype.hasOwnProperty; const f = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/; const d = {}; const p = {}; function m(e, t, r, n, i, a, o) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = n, this.attributeNamespace = i, this.mustUseProperty = r, this.propertyName = e, this.type = t, this.sanitizeURL = a, this.removeEmptyString = o; } const v = {}; 'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'.split(' ').forEach(((e) => { v[e] = new m(e, 0, !1, e, null, !1, !1); })), [['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(((e) => { const t = e[0]; v[t] = new m(t, 1, !1, e[1], null, !1, !1); })), ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(((e) => { v[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1); })), ['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(((e) => { v[e] = new m(e, 2, !1, e, null, !1, !1); })), 'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'.split(' ').forEach(((e) => { v[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1); })), ['checked', 'multiple', 'muted', 'selected'].forEach(((e) => { v[e] = new m(e, 3, !0, e, null, !1, !1); })), ['capture', 'download'].forEach(((e) => { v[e] = new m(e, 4, !1, e, null, !1, !1); })), ['cols', 'rows', 'size', 'span'].forEach(((e) => { v[e] = new m(e, 6, !1, e, null, !1, !1); })), ['rowSpan', 'start'].forEach(((e) => { v[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1); })); const g = /[\-:]([a-z])/g; function y(e) { return e[1].toUpperCase(); } function b(e, t, r, n) { let i = v.hasOwnProperty(t) ? v[t] : null; (i !== null ? i.type !== 0 : n || !(t.length > 2) || t[0] !== 'o' && t[0] !== 'O' || t[1] !== 'n' && t[1] !== 'N') && ((function (e, t, r, n) { if (t === null || typeof t === 'undefined' || (function (e, t, r, n) { if (r !== null && r.type === 0) return !1; switch (typeof t) { case 'function': case 'symbol': return !0; case 'boolean': return !n && (r !== null ? !r.acceptsBooleans : (e = e.toLowerCase().slice(0, 5)) !== 'data-' && e !== 'aria-'); default: return !1; } }(e, t, r, n))) return !0; if (n) return !1; if (r !== null) switch (r.type) { case 3: return !t; case 4: return !1 === t; case 5: return isNaN(t); case 6: return isNaN(t) || t < 1; } return !1; }(t, r, i, n)) && (r = null), n || i === null ? (function (e) { return !!h.call(p, e) || !h.call(d, e) && (f.test(e) ? p[e] = !0 : (d[e] = !0, !1)); }(t)) && (r === null ? e.removeAttribute(t) : e.setAttribute(t, `${r}`)) : i.mustUseProperty ? e[i.propertyName] = r === null ? i.type !== 3 && '' : r : (t = i.attributeName, n = i.attributeNamespace, r === null ? e.removeAttribute(t) : (r = (i = i.type) === 3 || i === 4 && !0 === r ? '' : `${r}`, n ? e.setAttributeNS(n, t, r) : e.setAttribute(t, r)))); }'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'.split(' ').forEach(((e) => { const t = e.replace(g, y); v[t] = new m(t, 1, !1, e, null, !1, !1); })), 'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'.split(' ').forEach(((e) => { const t = e.replace(g, y); v[t] = new m(t, 1, !1, e, 'http://www.w3.org/1999/xlink', !1, !1); })), ['xml:base', 'xml:lang', 'xml:space'].forEach(((e) => { const t = e.replace(g, y); v[t] = new m(t, 1, !1, e, 'http://www.w3.org/XML/1998/namespace', !1, !1); })), ['tabIndex', 'crossOrigin'].forEach(((e) => { v[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1); })), v.xlinkHref = new m('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1), ['src', 'href', 'action', 'formAction'].forEach(((e) => { v[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0); })); const w = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; const k = Symbol.for('react.element'); const x = Symbol.for('react.portal'); const _ = Symbol.for('react.fragment'); const S = Symbol.for('react.strict_mode'); const M = Symbol.for('react.profiler'); const E = Symbol.for('react.provider'); const C = Symbol.for('react.context'); const P = Symbol.for('react.forward_ref'); const A = Symbol.for('react.suspense'); const T = Symbol.for('react.suspense_list'); const R = Symbol.for('react.memo'); const I = Symbol.for('react.lazy'); Symbol.for('react.scope'), Symbol.for('react.debug_trace_mode'); const O = Symbol.for('react.offscreen'); Symbol.for('react.legacy_hidden'), Symbol.for('react.cache'), Symbol.for('react.tracing_marker'); const D = Symbol.iterator; function z(e) { return e === null || typeof e !== 'object' ? null : typeof (e = D && e[D] || e['@@iterator']) === 'function' ? e : null; } let N; const L = Object.assign; function j(e) { if (void 0 === N) try { throw Error(); } catch (r) { const t = r.stack.trim().match(/\n( *(at )?)/); N = t && t[1] || ''; } return `\n${N}${e}`; } let F = !1; function B(e, t) { if (!e || F) return ''; F = !0; const r = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error(); }, Object.defineProperty(t.prototype, 'props', { set() { throw Error(); } }), typeof Reflect === 'object' && Reflect.construct) { try { Reflect.construct(t, []); } catch (l) { var n = l; }Reflect.construct(e, [], t); } else { try { t.call(); } catch (l) { n = l; }e.call(t.prototype); } else { try { throw Error(); } catch (l) { n = l; }e(); } } catch (l) { if (l && n && typeof l.stack === 'string') { for (var i = l.stack.split('\n'), a = n.stack.split('\n'), o = i.length - 1, s = a.length - 1; o >= 1 && s >= 0 && i[o] !== a[s];)s--; for (;o >= 1 && s >= 0; o--, s--) if (i[o] !== a[s]) { if (o !== 1 || s !== 1) do { if (o--, --s < 0 || i[o] !== a[s]) { let u = `\n${i[o].replace(' at new ', ' at ')}`; return e.displayName && u.includes('<anonymous>') && (u = u.replace('<anonymous>', e.displayName)), u; } } while (o >= 1 && s >= 0); break; } } } finally { F = !1, Error.prepareStackTrace = r; } return (e = e ? e.displayName || e.name : '') ? j(e) : ''; } function U(e) { switch (e.tag) { case 5: return j(e.type); case 16: return j('Lazy'); case 13: return j('Suspense'); case 19: return j('SuspenseList'); case 0: case 2: case 15: return e = B(e.type, !1); case 11: return e = B(e.type.render, !1); case 1: return e = B(e.type, !0); default: return ''; } } function V(e) { if (e == null) return null; if (typeof e === 'function') return e.displayName || e.name || null; if (typeof e === 'string') return e; switch (e) { case _: return 'Fragment'; case x: return 'Portal'; case M: return 'Profiler'; case S: return 'StrictMode'; case A: return 'Suspense'; case T: return 'SuspenseList'; } if (typeof e === 'object') switch (e.$$typeof) { case C: return `${e.displayName || 'Context'}.Consumer`; case E: return `${e._context.displayName || 'Context'}.Provider`; case P: var t = e.render; return (e = e.displayName) || (e = (e = t.displayName || t.name || '') !== '' ? `ForwardRef(${e})` : 'ForwardRef'), e; case R: return (t = e.displayName || null) !== null ? t : V(e.type) || 'Memo'; case I: t = e._payload, e = e._init; try { return V(e(t)); } catch (r) {} } return null; } function Y(e) { const t = e.type; switch (e.tag) { case 24: return 'Cache'; case 9: return `${t.displayName || 'Context'}.Consumer`; case 10: return `${t._context.displayName || 'Context'}.Provider`; case 18: return 'DehydratedFragment'; case 11: return e = (e = t.render).displayName || e.name || '', t.displayName || (e !== '' ? `ForwardRef(${e})` : 'ForwardRef'); case 7: return 'Fragment'; case 5: return t; case 4: return 'Portal'; case 3: return 'Root'; case 6: return 'Text'; case 16: return V(t); case 8: return t === S ? 'StrictMode' : 'Mode'; case 22: return 'Offscreen'; case 12: return 'Profiler'; case 21: return 'Scope'; case 13: return 'Suspense'; case 19: return 'SuspenseList'; case 25: return 'TracingMarker'; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t === 'function') return t.displayName || t.name || null; if (typeof t === 'string') return t; } return null; } function H(e) { switch (typeof e) { case 'boolean': case 'number': case 'string': case 'undefined': case 'object': return e; default: return ''; } } function q(e) { const t = e.type; return (e = e.nodeName) && e.toLowerCase() === 'input' && (t === 'checkbox' || t === 'radio'); } function W(e) { e._valueTracker || (e._valueTracker = (function (e) { const t = q(e) ? 'checked' : 'value'; const r = Object.getOwnPropertyDescriptor(e.constructor.prototype, t); let n = `${e[t]}`; if (!e.hasOwnProperty(t) && typeof r !== 'undefined' && typeof r.get === 'function' && typeof r.set === 'function') { const i = r.get; const a = r.set; return Object.defineProperty(e, t, { configurable: !0, get() { return i.call(this); }, set(e) { n = `${e}`, a.call(this, e); } }), Object.defineProperty(e, t, { enumerable: r.enumerable }), { getValue() { return n; }, setValue(e) { n = `${e}`; }, stopTracking() { e._valueTracker = null, delete e[t]; } }; } }(e))); } function X(e) { if (!e) return !1; const t = e._valueTracker; if (!t) return !0; const r = t.getValue(); let n = ''; return e && (n = q(e) ? e.checked ? 'true' : 'false' : e.value), (e = n) !== r && (t.setValue(e), !0); } function G(e) { if (typeof (e = e || (typeof document !== 'undefined' ? document : void 0)) === 'undefined') return null; try { return e.activeElement || e.body; } catch (t) { return e.body; } } function $(e, t) {
        const r = t.checked; return {
          ...t, defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: r != null ? r : e._wrapperState.initialChecked,
        };
      } function Z(e, t) { let r = t.defaultValue == null ? '' : t.defaultValue; const n = t.checked != null ? t.checked : t.defaultChecked; r = H(t.value != null ? t.value : r), e._wrapperState = { initialChecked: n, initialValue: r, controlled: t.type === 'checkbox' || t.type === 'radio' ? t.checked != null : t.value != null }; } function K(e, t) { (t = t.checked) != null && b(e, 'checked', t, !1); } function Q(e, t) { K(e, t); const r = H(t.value); const n = t.type; if (r != null)n === 'number' ? (r === 0 && e.value === '' || e.value != r) && (e.value = `${r}`) : e.value !== `${r}` && (e.value = `${r}`); else if (n === 'submit' || n === 'reset') return void e.removeAttribute('value'); t.hasOwnProperty('value') ? ee(e, t.type, r) : t.hasOwnProperty('defaultValue') && ee(e, t.type, H(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked); } function J(e, t, r) { if (t.hasOwnProperty('value') || t.hasOwnProperty('defaultValue')) { const n = t.type; if (!(n !== 'submit' && n !== 'reset' || void 0 !== t.value && t.value !== null)) return; t = `${e._wrapperState.initialValue}`, r || t === e.value || (e.value = t), e.defaultValue = t; }(r = e.name) !== '' && (e.name = ''), e.defaultChecked = !!e._wrapperState.initialChecked, r !== '' && (e.name = r); } function ee(e, t, r) { t === 'number' && G(e.ownerDocument) === e || (r == null ? e.defaultValue = `${e._wrapperState.initialValue}` : e.defaultValue !== `${r}` && (e.defaultValue = `${r}`)); } const te = Array.isArray; function re(e, t, r, n) { if (e = e.options, t) { t = {}; for (var i = 0; i < r.length; i++)t[`$${r[i]}`] = !0; for (r = 0; r < e.length; r++)i = t.hasOwnProperty(`$${e[r].value}`), e[r].selected !== i && (e[r].selected = i), i && n && (e[r].defaultSelected = !0); } else { for (r = `${H(r)}`, t = null, i = 0; i < e.length; i++) { if (e[i].value === r) return e[i].selected = !0, void (n && (e[i].defaultSelected = !0)); t !== null || e[i].disabled || (t = e[i]); }t !== null && (t.selected = !0); } } function ne(e, t) {
        if (t.dangerouslySetInnerHTML != null) throw Error(a(91)); return {
          ...t, value: void 0, defaultValue: void 0, children: `${e._wrapperState.initialValue}`,
        };
      } function ie(e, t) { let r = t.value; if (r == null) { if (r = t.children, t = t.defaultValue, r != null) { if (t != null) throw Error(a(92)); if (te(r)) { if (r.length > 1) throw Error(a(93)); r = r[0]; }t = r; }t == null && (t = ''), r = t; }e._wrapperState = { initialValue: H(r) }; } function ae(e, t) { let r = H(t.value); const n = H(t.defaultValue); r != null && ((r = `${r}`) !== e.value && (e.value = r), t.defaultValue == null && e.defaultValue !== r && (e.defaultValue = r)), n != null && (e.defaultValue = `${n}`); } function oe(e) { const t = e.textContent; t === e._wrapperState.initialValue && t !== '' && t !== null && (e.value = t); } function se(e) { switch (e) { case 'svg': return 'http://www.w3.org/2000/svg'; case 'math': return 'http://www.w3.org/1998/Math/MathML'; default: return 'http://www.w3.org/1999/xhtml'; } } function ue(e, t) { return e == null || e === 'http://www.w3.org/1999/xhtml' ? se(t) : e === 'http://www.w3.org/2000/svg' && t === 'foreignObject' ? 'http://www.w3.org/1999/xhtml' : e; } let le; let ce; const he = (ce = function (e, t) { if (e.namespaceURI !== 'http://www.w3.org/2000/svg' || 'innerHTML' in e)e.innerHTML = t; else { for ((le = le || document.createElement('div')).innerHTML = `<svg>${t.valueOf().toString()}</svg>`, t = le.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (;t.firstChild;)e.appendChild(t.firstChild); } }, typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction ? function (e, t, r, n) { MSApp.execUnsafeLocalFunction((() => ce(e, t))); } : ce); function fe(e, t) { if (t) { const r = e.firstChild; if (r && r === e.lastChild && r.nodeType === 3) return void (r.nodeValue = t); }e.textContent = t; } const de = {
        animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0,
      }; const pe = ['Webkit', 'ms', 'Moz', 'O']; function me(e, t, r) { return t == null || typeof t === 'boolean' || t === '' ? '' : r || typeof t !== 'number' || t === 0 || de.hasOwnProperty(e) && de[e] ? (`${t}`).trim() : `${t}px`; } function ve(e, t) { for (let r in e = e.style, t) if (t.hasOwnProperty(r)) { const n = r.indexOf('--') === 0; const i = me(r, t[r], n); r === 'float' && (r = 'cssFloat'), n ? e.setProperty(r, i) : e[r] = i; } }Object.keys(de).forEach(((e) => { pe.forEach(((t) => { t = t + e.charAt(0).toUpperCase() + e.substring(1), de[t] = de[e]; })); })); const ge = {
        menuitem: !0, area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0,
      }; function ye(e, t) { if (t) { if (ge[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(a(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(a(60)); if (typeof t.dangerouslySetInnerHTML !== 'object' || !('__html' in t.dangerouslySetInnerHTML)) throw Error(a(61)); } if (t.style != null && typeof t.style !== 'object') throw Error(a(62)); } } function be(e, t) { if (e.indexOf('-') === -1) return typeof t.is === 'string'; switch (e) { case 'annotation-xml': case 'color-profile': case 'font-face': case 'font-face-src': case 'font-face-uri': case 'font-face-format': case 'font-face-name': case 'missing-glyph': return !1; default: return !0; } } let we = null; function ke(e) { return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e; } let xe = null; let _e = null; let Se = null; function Me(e) { if (e = bi(e)) { if (typeof xe !== 'function') throw Error(a(280)); let t = e.stateNode; t && (t = ki(t), xe(e.stateNode, e.type, t)); } } function Ee(e) { _e ? Se ? Se.push(e) : Se = [e] : _e = e; } function Ce() { if (_e) { let e = _e; const t = Se; if (Se = _e = null, Me(e), t) for (e = 0; e < t.length; e++)Me(t[e]); } } function Pe(e, t) { return e(t); } function Ae() {} let Te = !1; function Re(e, t, r) { if (Te) return e(t, r); Te = !0; try { return Pe(e, t, r); } finally { Te = !1, (_e !== null || Se !== null) && (Ae(), Ce()); } } function Ie(e, t) { let r = e.stateNode; if (r === null) return null; let n = ki(r); if (n === null) return null; r = n[t]; switch (t) { case 'onClick': case 'onClickCapture': case 'onDoubleClick': case 'onDoubleClickCapture': case 'onMouseDown': case 'onMouseDownCapture': case 'onMouseMove': case 'onMouseMoveCapture': case 'onMouseUp': case 'onMouseUpCapture': case 'onMouseEnter': (n = !n.disabled) || (n = !((e = e.type) === 'button' || e === 'input' || e === 'select' || e === 'textarea')), e = !n; break; default: e = !1; } if (e) return null; if (r && typeof r !== 'function') throw Error(a(231, t, typeof r)); return r; } let Oe = !1; if (c) try { const De = {}; Object.defineProperty(De, 'passive', { get() { Oe = !0; } }), window.addEventListener('test', De, De), window.removeEventListener('test', De, De); } catch (ce) { Oe = !1; } function ze(e, t, r, n, i, a, o, s, u) { const l = Array.prototype.slice.call(arguments, 3); try { t.apply(r, l); } catch (c) { this.onError(c); } } let Ne = !1; let Le = null; let je = !1; let Fe = null; const Be = { onError(e) { Ne = !0, Le = e; } }; function Ue(e, t, r, n, i, a, o, s, u) { Ne = !1, Le = null, ze.apply(Be, arguments); } function Ve(e) { let t = e; let r = e; if (e.alternate) for (;t.return;)t = t.return; else { e = t; do { (4098 & (t = e).flags) !== 0 && (r = t.return), e = t.return; } while (e); } return t.tag === 3 ? r : null; } function Ye(e) { if (e.tag === 13) { let t = e.memoizedState; if (t === null && ((e = e.alternate) !== null && (t = e.memoizedState)), t !== null) return t.dehydrated; } return null; } function He(e) { if (Ve(e) !== e) throw Error(a(188)); } function qe(e) { return (e = (function (e) { let t = e.alternate; if (!t) { if ((t = Ve(e)) === null) throw Error(a(188)); return t !== e ? null : e; } for (var r = e, n = t; ;) { const i = r.return; if (i === null) break; let o = i.alternate; if (o === null) { if ((n = i.return) !== null) { r = n; continue; } break; } if (i.child === o.child) { for (o = i.child; o;) { if (o === r) return He(i), e; if (o === n) return He(i), t; o = o.sibling; } throw Error(a(188)); } if (r.return !== n.return)r = i, n = o; else { for (var s = !1, u = i.child; u;) { if (u === r) { s = !0, r = i, n = o; break; } if (u === n) { s = !0, n = i, r = o; break; }u = u.sibling; } if (!s) { for (u = o.child; u;) { if (u === r) { s = !0, r = o, n = i; break; } if (u === n) { s = !0, n = o, r = i; break; }u = u.sibling; } if (!s) throw Error(a(189)); } } if (r.alternate !== n) throw Error(a(190)); } if (r.tag !== 3) throw Error(a(188)); return r.stateNode.current === r ? e : t; }(e))) !== null ? We(e) : null; } function We(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { const t = We(e); if (t !== null) return t; e = e.sibling; } return null; } const Xe = i.unstable_scheduleCallback; const Ge = i.unstable_cancelCallback; const $e = i.unstable_shouldYield; const Ze = i.unstable_requestPaint; const Ke = i.unstable_now; const Qe = i.unstable_getCurrentPriorityLevel; const Je = i.unstable_ImmediatePriority; const et = i.unstable_UserBlockingPriority; const tt = i.unstable_NormalPriority; const rt = i.unstable_LowPriority; const nt = i.unstable_IdlePriority; let it = null; let at = null; const ot = Math.clz32 ? Math.clz32 : function (e) { return e >>>= 0, e === 0 ? 32 : 31 - (st(e) / ut | 0) | 0; }; var st = Math.log; var ut = Math.LN2; let lt = 64; let ct = 4194304; function ht(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & e; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & e; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e; } } function ft(e, t) { let r = e.pendingLanes; if (r === 0) return 0; let n = 0; let i = e.suspendedLanes; let a = e.pingedLanes; let o = 268435455 & r; if (o !== 0) { const s = o & ~i; s !== 0 ? n = ht(s) : (a &= o) !== 0 && (n = ht(a)); } else (o = r & ~i) !== 0 ? n = ht(o) : a !== 0 && (n = ht(a)); if (n === 0) return 0; if (t !== 0 && t !== n && (t & i) === 0 && ((i = n & -n) >= (a = t & -t) || i === 16 && (4194240 & a) !== 0)) return t; if ((4 & n) !== 0 && (n |= 16 & r), (t = e.entangledLanes) !== 0) for (e = e.entanglements, t &= n; t > 0;)i = 1 << (r = 31 - ot(t)), n |= e[r], t &= ~i; return n; } function dt(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; default: return -1; } } function pt(e) { return (e = -1073741825 & e.pendingLanes) !== 0 ? e : 1073741824 & e ? 1073741824 : 0; } function mt() { const e = lt; return (4194240 & (lt <<= 1)) === 0 && (lt = 64), e; } function vt(e) { for (var t = [], r = 0; r < 31; r++)t.push(e); return t; } function gt(e, t, r) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - ot(t)] = r; } function yt(e, t) { let r = e.entangledLanes |= t; for (e = e.entanglements; r;) { const n = 31 - ot(r); const i = 1 << n; i & t | e[n] & t && (e[n] |= t), r &= ~i; } } let bt = 0; function wt(e) { return (e &= -e) > 1 ? e > 4 ? (268435455 & e) !== 0 ? 16 : 536870912 : 4 : 1; } let kt; let xt; let _t; let St; let Mt; let Et = !1; const Ct = []; let Pt = null; let At = null; let Tt = null; const Rt = new Map(); const It = new Map(); const Ot = []; const Dt = 'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(' '); function zt(e, t) { switch (e) { case 'focusin': case 'focusout': Pt = null; break; case 'dragenter': case 'dragleave': At = null; break; case 'mouseover': case 'mouseout': Tt = null; break; case 'pointerover': case 'pointerout': Rt.delete(t.pointerId); break; case 'gotpointercapture': case 'lostpointercapture': It.delete(t.pointerId); } } function Nt(e, t, r, n, i, a) {
        return e === null || e.nativeEvent !== a ? (e = {
          blockedOn: t, domEventName: r, eventSystemFlags: n, nativeEvent: a, targetContainers: [i],
        }, t !== null && ((t = bi(t)) !== null && xt(t)), e) : (e.eventSystemFlags |= n, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e);
      } function Lt(e) { let t = yi(e.target); if (t !== null) { const r = Ve(t); if (r !== null) if ((t = r.tag) === 13) { if ((t = Ye(r)) !== null) return e.blockedOn = t, void Mt(e.priority, (() => { _t(r); })); } else if (t === 3 && r.stateNode.current.memoizedState.isDehydrated) return void (e.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null); }e.blockedOn = null; } function jt(e) { if (e.blockedOn !== null) return !1; for (let t = e.targetContainers; t.length > 0;) { let r = $t(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (r !== null) return (t = bi(r)) !== null && xt(t), e.blockedOn = r, !1; const n = new (r = e.nativeEvent).constructor(r.type, r); we = n, r.target.dispatchEvent(n), we = null, t.shift(); } return !0; } function Ft(e, t, r) { jt(e) && r.delete(t); } function Bt() { Et = !1, Pt !== null && jt(Pt) && (Pt = null), At !== null && jt(At) && (At = null), Tt !== null && jt(Tt) && (Tt = null), Rt.forEach(Ft), It.forEach(Ft); } function Ut(e, t) { e.blockedOn === t && (e.blockedOn = null, Et || (Et = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, Bt))); } function Vt(e) { function t(t) { return Ut(t, e); } if (Ct.length > 0) { Ut(Ct[0], e); for (var r = 1; r < Ct.length; r++) { var n = Ct[r]; n.blockedOn === e && (n.blockedOn = null); } } for (Pt !== null && Ut(Pt, e), At !== null && Ut(At, e), Tt !== null && Ut(Tt, e), Rt.forEach(t), It.forEach(t), r = 0; r < Ot.length; r++)(n = Ot[r]).blockedOn === e && (n.blockedOn = null); for (;Ot.length > 0 && (r = Ot[0]).blockedOn === null;)Lt(r), r.blockedOn === null && Ot.shift(); } const Yt = w.ReactCurrentBatchConfig; let Ht = !0; function qt(e, t, r, n) { const i = bt; const a = Yt.transition; Yt.transition = null; try { bt = 1, Xt(e, t, r, n); } finally { bt = i, Yt.transition = a; } } function Wt(e, t, r, n) { const i = bt; const a = Yt.transition; Yt.transition = null; try { bt = 4, Xt(e, t, r, n); } finally { bt = i, Yt.transition = a; } } function Xt(e, t, r, n) { if (Ht) { let i = $t(e, t, r, n); if (i === null)Hn(e, t, n, Gt, r), zt(e, n); else if (function (e, t, r, n, i) { switch (t) { case 'focusin': return Pt = Nt(Pt, e, t, r, n, i), !0; case 'dragenter': return At = Nt(At, e, t, r, n, i), !0; case 'mouseover': return Tt = Nt(Tt, e, t, r, n, i), !0; case 'pointerover': var a = i.pointerId; return Rt.set(a, Nt(Rt.get(a) || null, e, t, r, n, i)), !0; case 'gotpointercapture': return a = i.pointerId, It.set(a, Nt(It.get(a) || null, e, t, r, n, i)), !0; } return !1; }(i, e, t, r, n))n.stopPropagation(); else if (zt(e, n), 4 & t && Dt.indexOf(e) > -1) { for (;i !== null;) { let a = bi(i); if (a !== null && kt(a), (a = $t(e, t, r, n)) === null && Hn(e, t, n, Gt, r), a === i) break; i = a; }i !== null && n.stopPropagation(); } else Hn(e, t, n, null, r); } } var Gt = null; function $t(e, t, r, n) { if (Gt = null, (e = yi(e = ke(n))) !== null) if ((t = Ve(e)) === null)e = null; else if ((r = t.tag) === 13) { if ((e = Ye(t)) !== null) return e; e = null; } else if (r === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null; } else t !== e && (e = null); return Gt = e, null; } function Zt(e) { switch (e) { case 'cancel': case 'click': case 'close': case 'contextmenu': case 'copy': case 'cut': case 'auxclick': case 'dblclick': case 'dragend': case 'dragstart': case 'drop': case 'focusin': case 'focusout': case 'input': case 'invalid': case 'keydown': case 'keypress': case 'keyup': case 'mousedown': case 'mouseup': case 'paste': case 'pause': case 'play': case 'pointercancel': case 'pointerdown': case 'pointerup': case 'ratechange': case 'reset': case 'resize': case 'seeked': case 'submit': case 'touchcancel': case 'touchend': case 'touchstart': case 'volumechange': case 'change': case 'selectionchange': case 'textInput': case 'compositionstart': case 'compositionend': case 'compositionupdate': case 'beforeblur': case 'afterblur': case 'beforeinput': case 'blur': case 'fullscreenchange': case 'focus': case 'hashchange': case 'popstate': case 'select': case 'selectstart': return 1; case 'drag': case 'dragenter': case 'dragexit': case 'dragleave': case 'dragover': case 'mousemove': case 'mouseout': case 'mouseover': case 'pointermove': case 'pointerout': case 'pointerover': case 'scroll': case 'toggle': case 'touchmove': case 'wheel': case 'mouseenter': case 'mouseleave': case 'pointerenter': case 'pointerleave': return 4; case 'message': switch (Qe()) { case Je: return 1; case et: return 4; case tt: case rt: return 16; case nt: return 536870912; default: return 16; } default: return 16; } } let Kt = null; let Qt = null; let Jt = null; function er() { if (Jt) return Jt; let e; let t; const r = Qt; const n = r.length; const i = 'value' in Kt ? Kt.value : Kt.textContent; const a = i.length; for (e = 0; e < n && r[e] === i[e]; e++);const o = n - e; for (t = 1; t <= o && r[n - t] === i[a - t]; t++);return Jt = i.slice(e, t > 1 ? 1 - t : void 0); } function tr(e) { const t = e.keyCode; return 'charCode' in e ? (e = e.charCode) === 0 && t === 13 && (e = 13) : e = t, e === 10 && (e = 13), e >= 32 || e === 13 ? e : 0; } function rr() { return !0; } function nr() { return !1; } function ir(e) {
        function t(t, r, n, i, a) { for (const o in this._reactName = t, this._targetInst = n, this.type = r, this.nativeEvent = i, this.target = a, this.currentTarget = null, e)e.hasOwnProperty(o) && (t = e[o], this[o] = t ? t(i) : i[o]); return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : !1 === i.returnValue) ? rr : nr, this.isPropagationStopped = nr, this; } return L(t.prototype, {
          preventDefault() { this.defaultPrevented = !0; const e = this.nativeEvent; e && (e.preventDefault ? e.preventDefault() : typeof e.returnValue !== 'unknown' && (e.returnValue = !1), this.isDefaultPrevented = rr); }, stopPropagation() { const e = this.nativeEvent; e && (e.stopPropagation ? e.stopPropagation() : typeof e.cancelBubble !== 'unknown' && (e.cancelBubble = !0), this.isPropagationStopped = rr); }, persist() {}, isPersistent: rr,
        }), t;
      } let ar; let or; let sr; const ur = {
        eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp(e) { return e.timeStamp || Date.now(); }, defaultPrevented: 0, isTrusted: 0,
      }; const lr = ir(ur); const cr = { ...ur, view: 0, detail: 0 }; const hr = ir(cr); const fr = {
        ...cr, screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Sr, button: 0, buttons: 0, relatedTarget(e) { return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget; }, movementX(e) { return 'movementX' in e ? e.movementX : (e !== sr && (sr && e.type === 'mousemove' ? (ar = e.screenX - sr.screenX, or = e.screenY - sr.screenY) : or = ar = 0, sr = e), ar); }, movementY(e) { return 'movementY' in e ? e.movementY : or; }, 
}; const dr = ir(fr); const pr = ir({ ...fr, dataTransfer: 0 }); const mr = ir({ ...cr, relatedTarget: 0 }); const vr = ir({
        ...ur, animationName: 0, elapsedTime: 0, pseudoElement: 0,
      }); const gr = { ...ur, clipboardData(e) { return 'clipboardData' in e ? e.clipboardData : window.clipboardData; } }; const yr = ir(gr); const br = ir({ ...ur, data: 0 }); const wr = {
        Esc: 'Escape', Spacebar: ' ', Left: 'ArrowLeft', Up: 'ArrowUp', Right: 'ArrowRight', Down: 'ArrowDown', Del: 'Delete', Win: 'OS', Menu: 'ContextMenu', Apps: 'ContextMenu', Scroll: 'ScrollLock', MozPrintableKey: 'Unidentified',
      }; const kr = {
        8: 'Backspace', 9: 'Tab', 12: 'Clear', 13: 'Enter', 16: 'Shift', 17: 'Control', 18: 'Alt', 19: 'Pause', 20: 'CapsLock', 27: 'Escape', 32: ' ', 33: 'PageUp', 34: 'PageDown', 35: 'End', 36: 'Home', 37: 'ArrowLeft', 38: 'ArrowUp', 39: 'ArrowRight', 40: 'ArrowDown', 45: 'Insert', 46: 'Delete', 112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6', 118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12', 144: 'NumLock', 145: 'ScrollLock', 224: 'Meta',
      }; const xr = {
        Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey',
      }; function _r(e) { const t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = xr[e]) && !!t[e]; } function Sr() { return _r; } const Mr = {
        ...cr, key(e) { if (e.key) { const t = wr[e.key] || e.key; if (t !== 'Unidentified') return t; } return e.type === 'keypress' ? (e = tr(e)) === 13 ? 'Enter' : String.fromCharCode(e) : e.type === 'keydown' || e.type === 'keyup' ? kr[e.keyCode] || 'Unidentified' : ''; }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Sr, charCode(e) { return e.type === 'keypress' ? tr(e) : 0; }, keyCode(e) { return e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0; }, which(e) { return e.type === 'keypress' ? tr(e) : e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0; },
      }; const Er = ir(Mr); const Cr = ir({
        ...fr, pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0,
      }); const Pr = ir({
        ...cr, touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Sr,
      }); const Ar = ir({
        ...ur, propertyName: 0, elapsedTime: 0, pseudoElement: 0,
      }); const Tr = {
        ...fr, deltaX(e) { return 'deltaX' in e ? e.deltaX : 'wheelDeltaX' in e ? -e.wheelDeltaX : 0; }, deltaY(e) { return 'deltaY' in e ? e.deltaY : 'wheelDeltaY' in e ? -e.wheelDeltaY : 'wheelDelta' in e ? -e.wheelDelta : 0; }, deltaZ: 0, deltaMode: 0,
      }; const Rr = ir(Tr); const Ir = [9, 13, 27, 32]; const Or = c && 'CompositionEvent' in window; let Dr = null; c && 'documentMode' in document && (Dr = document.documentMode); const zr = c && 'TextEvent' in window && !Dr; const Nr = c && (!Or || Dr && Dr > 8 && Dr <= 11); const Lr = String.fromCharCode(32); let jr = !1; function Fr(e, t) { switch (e) { case 'keyup': return Ir.indexOf(t.keyCode) !== -1; case 'keydown': return t.keyCode !== 229; case 'keypress': case 'mousedown': case 'focusout': return !0; default: return !1; } } function Br(e) { return typeof (e = e.detail) === 'object' && 'data' in e ? e.data : null; } let Ur = !1; const Vr = {
        color: !0, date: !0, datetime: !0, 'datetime-local': !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0,
      }; function Yr(e) { const t = e && e.nodeName && e.nodeName.toLowerCase(); return t === 'input' ? !!Vr[e.type] : t === 'textarea'; } function Hr(e, t, r, n) { Ee(n), (t = Wn(t, 'onChange')).length > 0 && (r = new lr('onChange', 'change', null, r, n), e.push({ event: r, listeners: t })); } let qr = null; let Wr = null; function Xr(e) { jn(e, 0); } function Gr(e) { if (X(wi(e))) return e; } function $r(e, t) { if (e === 'change') return t; } let Zr = !1; if (c) { let Kr; if (c) { let Qr = 'oninput' in document; if (!Qr) { const Jr = document.createElement('div'); Jr.setAttribute('oninput', 'return;'), Qr = typeof Jr.oninput === 'function'; }Kr = Qr; } else Kr = !1; Zr = Kr && (!document.documentMode || document.documentMode > 9); } function en() { qr && (qr.detachEvent('onpropertychange', tn), Wr = qr = null); } function tn(e) { if (e.propertyName === 'value' && Gr(Wr)) { const t = []; Hr(t, Wr, e, ke(e)), Re(Xr, t); } } function rn(e, t, r) { e === 'focusin' ? (en(), Wr = r, (qr = t).attachEvent('onpropertychange', tn)) : e === 'focusout' && en(); } function nn(e) { if (e === 'selectionchange' || e === 'keyup' || e === 'keydown') return Gr(Wr); } function an(e, t) { if (e === 'click') return Gr(t); } function on(e, t) { if (e === 'input' || e === 'change') return Gr(t); } const sn = typeof Object.is === 'function' ? Object.is : function (e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t; }; function un(e, t) { if (sn(e, t)) return !0; if (typeof e !== 'object' || e === null || typeof t !== 'object' || t === null) return !1; const r = Object.keys(e); let n = Object.keys(t); if (r.length !== n.length) return !1; for (n = 0; n < r.length; n++) { const i = r[n]; if (!h.call(t, i) || !sn(e[i], t[i])) return !1; } return !0; } function ln(e) { for (;e && e.firstChild;)e = e.firstChild; return e; } function cn(e, t) { let r; let n = ln(e); for (e = 0; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r; }e: { for (;n;) { if (n.nextSibling) { n = n.nextSibling; break e; }n = n.parentNode; }n = void 0; }n = ln(n); } } function hn(e, t) { return !(!e || !t) && (e === t || (!e || e.nodeType !== 3) && (t && t.nodeType === 3 ? hn(e, t.parentNode) : 'contains' in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))); } function fn() { for (var e = window, t = G(); t instanceof e.HTMLIFrameElement;) { try { var r = typeof t.contentWindow.location.href === 'string'; } catch (n) { r = !1; } if (!r) break; t = G((e = t.contentWindow).document); } return t; } function dn(e) { const t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === 'input' && (e.type === 'text' || e.type === 'search' || e.type === 'tel' || e.type === 'url' || e.type === 'password') || t === 'textarea' || e.contentEditable === 'true'); } function pn(e) { let t = fn(); let r = e.focusedElem; let n = e.selectionRange; if (t !== r && r && r.ownerDocument && hn(r.ownerDocument.documentElement, r)) { if (n !== null && dn(r)) if (t = n.start, void 0 === (e = n.end) && (e = t), 'selectionStart' in r)r.selectionStart = t, r.selectionEnd = Math.min(e, r.value.length); else if ((e = (t = r.ownerDocument || document) && t.defaultView || window).getSelection) { e = e.getSelection(); let i = r.textContent.length; let a = Math.min(n.start, i); n = void 0 === n.end ? a : Math.min(n.end, i), !e.extend && a > n && (i = n, n = a, a = i), i = cn(r, a); const o = cn(r, n); i && o && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), a > n ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t))); } for (t = [], e = r; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof r.focus === 'function' && r.focus(), r = 0; r < t.length; r++)(e = t[r]).element.scrollLeft = e.left, e.element.scrollTop = e.top; } } const mn = c && 'documentMode' in document && document.documentMode <= 11; let vn = null; let gn = null; let yn = null; let bn = !1; function wn(e, t, r) {
        let n = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument; bn || vn == null || vn !== G(n) || ('selectionStart' in (n = vn) && dn(n) ? n = { start: n.selectionStart, end: n.selectionEnd } : n = {
          anchorNode: (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection()).anchorNode, anchorOffset: n.anchorOffset, focusNode: n.focusNode, focusOffset: n.focusOffset,
        }, yn && un(yn, n) || (yn = n, (n = Wn(gn, 'onSelect')).length > 0 && (t = new lr('onSelect', 'select', null, t, r), e.push({ event: t, listeners: n }), t.target = vn)));
      } function kn(e, t) { const r = {}; return r[e.toLowerCase()] = t.toLowerCase(), r[`Webkit${e}`] = `webkit${t}`, r[`Moz${e}`] = `moz${t}`, r; } const xn = {
        animationend: kn('Animation', 'AnimationEnd'), animationiteration: kn('Animation', 'AnimationIteration'), animationstart: kn('Animation', 'AnimationStart'), transitionend: kn('Transition', 'TransitionEnd'),
      }; const _n = {}; let Sn = {}; function Mn(e) { if (_n[e]) return _n[e]; if (!xn[e]) return e; let t; const r = xn[e]; for (t in r) if (r.hasOwnProperty(t) && t in Sn) return _n[e] = r[t]; return e; }c && (Sn = document.createElement('div').style, 'AnimationEvent' in window || (delete xn.animationend.animation, delete xn.animationiteration.animation, delete xn.animationstart.animation), 'TransitionEvent' in window || delete xn.transitionend.transition); const En = Mn('animationend'); const Cn = Mn('animationiteration'); const Pn = Mn('animationstart'); const An = Mn('transitionend'); const Tn = new Map(); const Rn = 'abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(' '); function In(e, t) { Tn.set(e, t), u(t, [e]); } for (let On = 0; On < Rn.length; On++) { const Dn = Rn[On]; In(Dn.toLowerCase(), `on${Dn[0].toUpperCase() + Dn.slice(1)}`); }In(En, 'onAnimationEnd'), In(Cn, 'onAnimationIteration'), In(Pn, 'onAnimationStart'), In('dblclick', 'onDoubleClick'), In('focusin', 'onFocus'), In('focusout', 'onBlur'), In(An, 'onTransitionEnd'), l('onMouseEnter', ['mouseout', 'mouseover']), l('onMouseLeave', ['mouseout', 'mouseover']), l('onPointerEnter', ['pointerout', 'pointerover']), l('onPointerLeave', ['pointerout', 'pointerover']), u('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' ')), u('onSelect', 'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(' ')), u('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']), u('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' ')), u('onCompositionStart', 'compositionstart focusout keydown keypress keyup mousedown'.split(' ')), u('onCompositionUpdate', 'compositionupdate focusout keydown keypress keyup mousedown'.split(' ')); const zn = 'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(' '); const Nn = new Set('cancel close invalid load scroll toggle'.split(' ').concat(zn)); function Ln(e, t, r) { const n = e.type || 'unknown-event'; e.currentTarget = r, (function (e, t, r, n, i, o, s, u, l) { if (Ue.apply(this, arguments), Ne) { if (!Ne) throw Error(a(198)); const c = Le; Ne = !1, Le = null, je || (je = !0, Fe = c); } }(n, t, void 0, e)), e.currentTarget = null; } function jn(e, t) { t = (4 & t) !== 0; for (let r = 0; r < e.length; r++) { let n = e[r]; const i = n.event; n = n.listeners; e: { let a = void 0; if (t) for (var o = n.length - 1; o >= 0; o--) { var s = n[o]; var u = s.instance; var l = s.currentTarget; if (s = s.listener, u !== a && i.isPropagationStopped()) break e; Ln(i, s, l), a = u; } else for (o = 0; o < n.length; o++) { if (u = (s = n[o]).instance, l = s.currentTarget, s = s.listener, u !== a && i.isPropagationStopped()) break e; Ln(i, s, l), a = u; } } } if (je) throw e = Fe, je = !1, Fe = null, e; } function Fn(e, t) { let r = t[mi]; void 0 === r && (r = t[mi] = new Set()); const n = `${e}__bubble`; r.has(n) || (Yn(t, e, 2, !1), r.add(n)); } function Bn(e, t, r) { let n = 0; t && (n |= 4), Yn(r, e, n, t); } const Un = `_reactListening${Math.random().toString(36).slice(2)}`; function Vn(e) { if (!e[Un]) { e[Un] = !0, o.forEach(((t) => { t !== 'selectionchange' && (Nn.has(t) || Bn(t, !1, e), Bn(t, !0, e)); })); const t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[Un] || (t[Un] = !0, Bn('selectionchange', !1, t)); } } function Yn(e, t, r, n) { switch (Zt(t)) { case 1: var i = qt; break; case 4: i = Wt; break; default: i = Xt; }r = i.bind(null, t, r, e), i = void 0, !Oe || t !== 'touchstart' && t !== 'touchmove' && t !== 'wheel' || (i = !0), n ? void 0 !== i ? e.addEventListener(t, r, { capture: !0, passive: i }) : e.addEventListener(t, r, !0) : void 0 !== i ? e.addEventListener(t, r, { passive: i }) : e.addEventListener(t, r, !1); } function Hn(e, t, r, n, i) { let a = n; if ((1 & t) === 0 && (2 & t) === 0 && n !== null)e:for (;;) { if (n === null) return; let o = n.tag; if (o === 3 || o === 4) { let s = n.stateNode.containerInfo; if (s === i || s.nodeType === 8 && s.parentNode === i) break; if (o === 4) for (o = n.return; o !== null;) { var u = o.tag; if ((u === 3 || u === 4) && ((u = o.stateNode.containerInfo) === i || u.nodeType === 8 && u.parentNode === i)) return; o = o.return; } for (;s !== null;) { if ((o = yi(s)) === null) return; if ((u = o.tag) === 5 || u === 6) { n = a = o; continue e; }s = s.parentNode; } }n = n.return; }Re((() => { let n = a; let i = ke(r); const o = []; e: { var s = Tn.get(e); if (void 0 !== s) { var u = lr; var l = e; switch (e) { case 'keypress': if (tr(r) === 0) break e; case 'keydown': case 'keyup': u = Er; break; case 'focusin': l = 'focus', u = mr; break; case 'focusout': l = 'blur', u = mr; break; case 'beforeblur': case 'afterblur': u = mr; break; case 'click': if (r.button === 2) break e; case 'auxclick': case 'dblclick': case 'mousedown': case 'mousemove': case 'mouseup': case 'mouseout': case 'mouseover': case 'contextmenu': u = dr; break; case 'drag': case 'dragend': case 'dragenter': case 'dragexit': case 'dragleave': case 'dragover': case 'dragstart': case 'drop': u = pr; break; case 'touchcancel': case 'touchend': case 'touchmove': case 'touchstart': u = Pr; break; case En: case Cn: case Pn: u = vr; break; case An: u = Ar; break; case 'scroll': u = hr; break; case 'wheel': u = Rr; break; case 'copy': case 'cut': case 'paste': u = yr; break; case 'gotpointercapture': case 'lostpointercapture': case 'pointercancel': case 'pointerdown': case 'pointermove': case 'pointerout': case 'pointerover': case 'pointerup': u = Cr; } var c = (4 & t) !== 0; var h = !c && e === 'scroll'; var f = c ? s !== null ? `${s}Capture` : null : s; c = []; for (var d, p = n; p !== null;) { var m = (d = p).stateNode; if (d.tag === 5 && m !== null && (d = m, f !== null && ((m = Ie(p, f)) != null && c.push(qn(p, m, d)))), h) break; p = p.return; }c.length > 0 && (s = new u(s, l, null, r, i), o.push({ event: s, listeners: c })); } } if ((7 & t) === 0) { if (u = e === 'mouseout' || e === 'pointerout', (!(s = e === 'mouseover' || e === 'pointerover') || r === we || !(l = r.relatedTarget || r.fromElement) || !yi(l) && !l[pi]) && (u || s) && (s = i.window === i ? i : (s = i.ownerDocument) ? s.defaultView || s.parentWindow : window, u ? (u = n, (l = (l = r.relatedTarget || r.toElement) ? yi(l) : null) !== null && (l !== (h = Ve(l)) || l.tag !== 5 && l.tag !== 6) && (l = null)) : (u = null, l = n), u !== l)) { if (c = dr, m = 'onMouseLeave', f = 'onMouseEnter', p = 'mouse', e !== 'pointerout' && e !== 'pointerover' || (c = Cr, m = 'onPointerLeave', f = 'onPointerEnter', p = 'pointer'), h = u == null ? s : wi(u), d = l == null ? s : wi(l), (s = new c(m, `${p}leave`, u, r, i)).target = h, s.relatedTarget = d, m = null, yi(i) === n && ((c = new c(f, `${p}enter`, l, r, i)).target = d, c.relatedTarget = h, m = c), h = m, u && l)e: { for (f = l, p = 0, d = c = u; d; d = Xn(d))p++; for (d = 0, m = f; m; m = Xn(m))d++; for (;p - d > 0;)c = Xn(c), p--; for (;d - p > 0;)f = Xn(f), d--; for (;p--;) { if (c === f || f !== null && c === f.alternate) break e; c = Xn(c), f = Xn(f); }c = null; } else c = null; u !== null && Gn(o, s, u, c, !1), l !== null && h !== null && Gn(o, h, l, c, !0); } if ((u = (s = n ? wi(n) : window).nodeName && s.nodeName.toLowerCase()) === 'select' || u === 'input' && s.type === 'file') var v = $r; else if (Yr(s)) if (Zr)v = on; else { v = nn; var g = rn; } else (u = s.nodeName) && u.toLowerCase() === 'input' && (s.type === 'checkbox' || s.type === 'radio') && (v = an); switch (v && (v = v(e, n)) ? Hr(o, v, r, i) : (g && g(e, s, n), e === 'focusout' && (g = s._wrapperState) && g.controlled && s.type === 'number' && ee(s, 'number', s.value)), g = n ? wi(n) : window, e) { case 'focusin': (Yr(g) || g.contentEditable === 'true') && (vn = g, gn = n, yn = null); break; case 'focusout': yn = gn = vn = null; break; case 'mousedown': bn = !0; break; case 'contextmenu': case 'mouseup': case 'dragend': bn = !1, wn(o, r, i); break; case 'selectionchange': if (mn) break; case 'keydown': case 'keyup': wn(o, r, i); } let y; if (Or)e: { switch (e) { case 'compositionstart': var b = 'onCompositionStart'; break e; case 'compositionend': b = 'onCompositionEnd'; break e; case 'compositionupdate': b = 'onCompositionUpdate'; break e; }b = void 0; } else Ur ? Fr(e, r) && (b = 'onCompositionEnd') : e === 'keydown' && r.keyCode === 229 && (b = 'onCompositionStart'); b && (Nr && r.locale !== 'ko' && (Ur || b !== 'onCompositionStart' ? b === 'onCompositionEnd' && Ur && (y = er()) : (Qt = 'value' in (Kt = i) ? Kt.value : Kt.textContent, Ur = !0)), (g = Wn(n, b)).length > 0 && (b = new br(b, e, null, r, i), o.push({ event: b, listeners: g }), y ? b.data = y : (y = Br(r)) !== null && (b.data = y))), (y = zr ? (function (e, t) { switch (e) { case 'compositionend': return Br(t); case 'keypress': return t.which !== 32 ? null : (jr = !0, Lr); case 'textInput': return (e = t.data) === Lr && jr ? null : e; default: return null; } }(e, r)) : (function (e, t) { if (Ur) return e === 'compositionend' || !Or && Fr(e, t) ? (e = er(), Jt = Qt = Kt = null, Ur = !1, e) : null; switch (e) { case 'paste': default: return null; case 'keypress': if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && t.char.length > 1) return t.char; if (t.which) return String.fromCharCode(t.which); } return null; case 'compositionend': return Nr && t.locale !== 'ko' ? null : t.data; } }(e, r))) && ((n = Wn(n, 'onBeforeInput')).length > 0 && (i = new br('onBeforeInput', 'beforeinput', null, r, i), o.push({ event: i, listeners: n }), i.data = y)); }jn(o, t); })); } function qn(e, t, r) { return { instance: e, listener: t, currentTarget: r }; } function Wn(e, t) { for (var r = `${t}Capture`, n = []; e !== null;) { let i = e; let a = i.stateNode; i.tag === 5 && a !== null && (i = a, (a = Ie(e, r)) != null && n.unshift(qn(e, a, i)), (a = Ie(e, t)) != null && n.push(qn(e, a, i))), e = e.return; } return n; } function Xn(e) { if (e === null) return null; do { e = e.return; } while (e && e.tag !== 5); return e || null; } function Gn(e, t, r, n, i) { for (var a = t._reactName, o = []; r !== null && r !== n;) { let s = r; let u = s.alternate; const l = s.stateNode; if (u !== null && u === n) break; s.tag === 5 && l !== null && (s = l, i ? (u = Ie(r, a)) != null && o.unshift(qn(r, u, s)) : i || (u = Ie(r, a)) != null && o.push(qn(r, u, s))), r = r.return; }o.length !== 0 && e.push({ event: t, listeners: o }); } const $n = /\r\n?/g; const Zn = /\u0000|\uFFFD/g; function Kn(e) { return (typeof e === 'string' ? e : `${e}`).replace($n, '\n').replace(Zn, ''); } function Qn(e, t, r) { if (t = Kn(t), Kn(e) !== t && r) throw Error(a(425)); } function Jn() {} let ei = null; let ti = null; function ri(e, t) { return e === 'textarea' || e === 'noscript' || typeof t.children === 'string' || typeof t.children === 'number' || typeof t.dangerouslySetInnerHTML === 'object' && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null; } const ni = typeof setTimeout === 'function' ? setTimeout : void 0; const ii = typeof clearTimeout === 'function' ? clearTimeout : void 0; const ai = typeof Promise === 'function' ? Promise : void 0; const oi = typeof queueMicrotask === 'function' ? queueMicrotask : typeof ai !== 'undefined' ? function (e) { return ai.resolve(null).then(e).catch(si); } : ni; function si(e) { setTimeout((() => { throw e; })); } function ui(e, t) { let r = t; let n = 0; do { const i = r.nextSibling; if (e.removeChild(r), i && i.nodeType === 8) if ((r = i.data) === '/$') { if (n === 0) return e.removeChild(i), void Vt(t); n--; } else r !== '$' && r !== '$?' && r !== '$!' || n++; r = i; } while (r); Vt(t); } function li(e) { for (;e != null; e = e.nextSibling) { let t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if ((t = e.data) === '$' || t === '$!' || t === '$?') break; if (t === '/$') return null; } } return e; } function ci(e) { e = e.previousSibling; for (let t = 0; e;) { if (e.nodeType === 8) { const r = e.data; if (r === '$' || r === '$!' || r === '$?') { if (t === 0) return e; t--; } else r === '/$' && t++; }e = e.previousSibling; } return null; } const hi = Math.random().toString(36).slice(2); const fi = `__reactFiber$${hi}`; const di = `__reactProps$${hi}`; var pi = `__reactContainer$${hi}`; var mi = `__reactEvents$${hi}`; const vi = `__reactListeners$${hi}`; const gi = `__reactHandles$${hi}`; function yi(e) { let t = e[fi]; if (t) return t; for (let r = e.parentNode; r;) { if (t = r[pi] || r[fi]) { if (r = t.alternate, t.child !== null || r !== null && r.child !== null) for (e = ci(e); e !== null;) { if (r = e[fi]) return r; e = ci(e); } return t; }r = (e = r).parentNode; } return null; } function bi(e) { return !(e = e[fi] || e[pi]) || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e; } function wi(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(a(33)); } function ki(e) { return e[di] || null; } const xi = []; let _i = -1; function Si(e) { return { current: e }; } function Mi(e) { _i < 0 || (e.current = xi[_i], xi[_i] = null, _i--); } function Ei(e, t) { _i++, xi[_i] = e.current, e.current = t; } const Ci = {}; const Pi = Si(Ci); const Ai = Si(!1); let Ti = Ci; function Ri(e, t) { const r = e.type.contextTypes; if (!r) return Ci; const n = e.stateNode; if (n && n.__reactInternalMemoizedUnmaskedChildContext === t) return n.__reactInternalMemoizedMaskedChildContext; let i; const a = {}; for (i in r)a[i] = t[i]; return n && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = a), a; } function Ii(e) { return (e = e.childContextTypes) !== null && void 0 !== e; } function Oi() { Mi(Ai), Mi(Pi); } function Di(e, t, r) { if (Pi.current !== Ci) throw Error(a(168)); Ei(Pi, t), Ei(Ai, r); } function zi(e, t, r) { let n = e.stateNode; if (t = t.childContextTypes, typeof n.getChildContext !== 'function') return r; for (const i in n = n.getChildContext()) if (!(i in t)) throw Error(a(108, Y(e) || 'Unknown', i)); return { ...r, ...n }; } function Ni(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Ci, Ti = Pi.current, Ei(Pi, e), Ei(Ai, Ai.current), !0; } function Li(e, t, r) { const n = e.stateNode; if (!n) throw Error(a(169)); r ? (e = zi(e, t, Ti), n.__reactInternalMemoizedMergedChildContext = e, Mi(Ai), Mi(Pi), Ei(Pi, e)) : Mi(Ai), Ei(Ai, r); } let ji = null; let Fi = !1; let Bi = !1; function Ui(e) { ji === null ? ji = [e] : ji.push(e); } function Vi() { if (!Bi && ji !== null) { Bi = !0; let e = 0; const t = bt; try { const r = ji; for (bt = 1; e < r.length; e++) { let n = r[e]; do { n = n(!0); } while (n !== null); }ji = null, Fi = !1; } catch (i) { throw ji !== null && (ji = ji.slice(e + 1)), Xe(Je, Vi), i; } finally { bt = t, Bi = !1; } } return null; } const Yi = []; let Hi = 0; let qi = null; let Wi = 0; const Xi = []; let Gi = 0; let $i = null; let Zi = 1; let Ki = ''; function Qi(e, t) { Yi[Hi++] = Wi, Yi[Hi++] = qi, qi = e, Wi = t; } function Ji(e, t, r) { Xi[Gi++] = Zi, Xi[Gi++] = Ki, Xi[Gi++] = $i, $i = e; let n = Zi; e = Ki; let i = 32 - ot(n) - 1; n &= ~(1 << i), r += 1; let a = 32 - ot(t) + i; if (a > 30) { const o = i - i % 5; a = (n & (1 << o) - 1).toString(32), n >>= o, i -= o, Zi = 1 << 32 - ot(t) + i | r << i | n, Ki = a + e; } else Zi = 1 << a | r << i | n, Ki = e; } function ea(e) { e.return !== null && (Qi(e, 1), Ji(e, 1, 0)); } function ta(e) { for (;e === qi;)qi = Yi[--Hi], Yi[Hi] = null, Wi = Yi[--Hi], Yi[Hi] = null; for (;e === $i;)$i = Xi[--Gi], Xi[Gi] = null, Ki = Xi[--Gi], Xi[Gi] = null, Zi = Xi[--Gi], Xi[Gi] = null; } let ra = null; let na = null; let ia = !1; let aa = null; function oa(e, t) { const r = Il(5, null, null, 0); r.elementType = 'DELETED', r.stateNode = t, r.return = e, (t = e.deletions) === null ? (e.deletions = [r], e.flags |= 16) : t.push(r); } function sa(e, t) { switch (e.tag) { case 5: var r = e.type; return (t = t.nodeType !== 1 || r.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) !== null && (e.stateNode = t, ra = e, na = li(t.firstChild), !0); case 6: return (t = e.pendingProps === '' || t.nodeType !== 3 ? null : t) !== null && (e.stateNode = t, ra = e, na = null, !0); case 13: return (t = t.nodeType !== 8 ? null : t) !== null && (r = $i !== null ? { id: Zi, overflow: Ki } : null, e.memoizedState = { dehydrated: t, treeContext: r, retryLane: 1073741824 }, (r = Il(18, null, null, 0)).stateNode = t, r.return = e, e.child = r, ra = e, na = null, !0); default: return !1; } } function ua(e) { return (1 & e.mode) !== 0 && (128 & e.flags) === 0; } function la(e) { if (ia) { let t = na; if (t) { const r = t; if (!sa(e, t)) { if (ua(e)) throw Error(a(418)); t = li(r.nextSibling); const n = ra; t && sa(e, t) ? oa(n, r) : (e.flags = -4097 & e.flags | 2, ia = !1, ra = e); } } else { if (ua(e)) throw Error(a(418)); e.flags = -4097 & e.flags | 2, ia = !1, ra = e; } } } function ca(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; ra = e; } function ha(e) { if (e !== ra) return !1; if (!ia) return ca(e), ia = !0, !1; let t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = (t = e.type) !== 'head' && t !== 'body' && !ri(e.type, e.memoizedProps)), t && (t = na)) { if (ua(e)) throw fa(), Error(a(418)); for (;t;)oa(e, t), t = li(t.nextSibling); } if (ca(e), e.tag === 13) { if (!(e = (e = e.memoizedState) !== null ? e.dehydrated : null)) throw Error(a(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { const r = e.data; if (r === '/$') { if (t === 0) { na = li(e.nextSibling); break e; }t--; } else r !== '$' && r !== '$!' && r !== '$?' || t++; }e = e.nextSibling; }na = null; } } else na = ra ? li(e.stateNode.nextSibling) : null; return !0; } function fa() { for (let e = na; e;)e = li(e.nextSibling); } function da() { na = ra = null, ia = !1; } function pa(e) { aa === null ? aa = [e] : aa.push(e); } const ma = w.ReactCurrentBatchConfig; function va(e, t) { if (e && e.defaultProps) { for (const r in t = { ...t }, e = e.defaultProps) void 0 === t[r] && (t[r] = e[r]); return t; } return t; } const ga = Si(null); let ya = null; let ba = null; let wa = null; function ka() { wa = ba = ya = null; } function xa(e) { const t = ga.current; Mi(ga), e._currentValue = t; } function _a(e, t, r) { for (;e !== null;) { const n = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, n !== null && (n.childLanes |= t)) : n !== null && (n.childLanes & t) !== t && (n.childLanes |= t), e === r) break; e = e.return; } } function Sa(e, t) { ya = e, wa = ba = null, (e = e.dependencies) !== null && e.firstContext !== null && ((e.lanes & t) !== 0 && (ws = !0), e.firstContext = null); } function Ma(e) { const t = e._currentValue; if (wa !== e) if (e = { context: e, memoizedValue: t, next: null }, ba === null) { if (ya === null) throw Error(a(308)); ba = e, ya.dependencies = { lanes: 0, firstContext: e }; } else ba = ba.next = e; return t; } let Ea = null; function Ca(e) { Ea === null ? Ea = [e] : Ea.push(e); } function Pa(e, t, r, n) { const i = t.interleaved; return i === null ? (r.next = r, Ca(t)) : (r.next = i.next, i.next = r), t.interleaved = r, Aa(e, n); } function Aa(e, t) { e.lanes |= t; let r = e.alternate; for (r !== null && (r.lanes |= t), r = e, e = e.return; e !== null;)e.childLanes |= t, (r = e.alternate) !== null && (r.childLanes |= t), r = e, e = e.return; return r.tag === 3 ? r.stateNode : null; } let Ta = !1; function Ra(e) {
        e.updateQueue = {
          baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null,
        };
      } function Ia(e, t) {
        e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
          baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects,
        });
      } function Oa(e, t) {
        return {
          eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null,
        };
      } function Da(e, t, r) { let n = e.updateQueue; if (n === null) return null; if (n = n.shared, (2 & Au) !== 0) { var i = n.pending; return i === null ? t.next = t : (t.next = i.next, i.next = t), n.pending = t, Aa(e, r); } return (i = n.interleaved) === null ? (t.next = t, Ca(n)) : (t.next = i.next, i.next = t), n.interleaved = t, Aa(e, r); } function za(e, t, r) { if ((t = t.updateQueue) !== null && (t = t.shared, (4194240 & r) !== 0)) { let n = t.lanes; r |= n &= e.pendingLanes, t.lanes = r, yt(e, r); } } function Na(e, t) {
        let r = e.updateQueue; let n = e.alternate; if (n !== null && r === (n = n.updateQueue)) {
          let i = null; let a = null; if ((r = r.firstBaseUpdate) !== null) {
            do {
              const o = {
                eventTime: r.eventTime, lane: r.lane, tag: r.tag, payload: r.payload, callback: r.callback, next: null,
              }; a === null ? i = a = o : a = a.next = o, r = r.next;
            } while (r !== null); a === null ? i = a = t : a = a.next = t;
          } else i = a = t; return r = {
            baseState: n.baseState, firstBaseUpdate: i, lastBaseUpdate: a, shared: n.shared, effects: n.effects,
          }, void (e.updateQueue = r);
        }(e = r.lastBaseUpdate) === null ? r.firstBaseUpdate = t : e.next = t, r.lastBaseUpdate = t;
      } function La(e, t, r, n) {
        let i = e.updateQueue; Ta = !1; let a = i.firstBaseUpdate; let o = i.lastBaseUpdate; let s = i.shared.pending; if (s !== null) { i.shared.pending = null; var u = s; var l = u.next; u.next = null, o === null ? a = l : o.next = l, o = u; var c = e.alternate; c !== null && ((s = (c = c.updateQueue).lastBaseUpdate) !== o && (s === null ? c.firstBaseUpdate = l : s.next = l, c.lastBaseUpdate = u)); } if (a !== null) {
          let h = i.baseState; for (o = 0, c = l = u = null, s = a; ;) {
            let f = s.lane; let d = s.eventTime; if ((n & f) === f) {
              c !== null && (c = c.next = {
                eventTime: d, lane: 0, tag: s.tag, payload: s.payload, callback: s.callback, next: null,
              }); e: { let p = e; const m = s; switch (f = t, d = r, m.tag) { case 1: if (typeof (p = m.payload) === 'function') { h = p.call(d, h, f); break e; }h = p; break e; case 3: p.flags = -65537 & p.flags | 128; case 0: if ((f = typeof (p = m.payload) === 'function' ? p.call(d, h, f) : p) === null || void 0 === f) break e; h = { ...h, ...f }; break e; case 2: Ta = !0; } }s.callback !== null && s.lane !== 0 && (e.flags |= 64, (f = i.effects) === null ? i.effects = [s] : f.push(s));
            } else {
              d = {
                eventTime: d, lane: f, tag: s.tag, payload: s.payload, callback: s.callback, next: null,
              }, c === null ? (l = c = d, u = h) : c = c.next = d, o |= f;
            } if ((s = s.next) === null) { if ((s = i.shared.pending) === null) break; s = (f = s).next, f.next = null, i.lastBaseUpdate = f, i.shared.pending = null; }
          } if (c === null && (u = h), i.baseState = u, i.firstBaseUpdate = l, i.lastBaseUpdate = c, (t = i.shared.interleaved) !== null) { i = t; do { o |= i.lane, i = i.next; } while (i !== t); } else a === null && (i.shared.lanes = 0); Lu |= o, e.lanes = o, e.memoizedState = h;
        }
      } function ja(e, t, r) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { let n = e[t]; const i = n.callback; if (i !== null) { if (n.callback = null, n = r, typeof i !== 'function') throw Error(a(191, i)); i.call(n); } } } const Fa = (new n.Component()).refs; function Ba(e, t, r, n) { r = (r = r(n, t = e.memoizedState)) === null || void 0 === r ? t : ({ ...t, ...r }), e.memoizedState = r, e.lanes === 0 && (e.updateQueue.baseState = r); } const Ua = {
        isMounted(e) { return !!(e = e._reactInternals) && Ve(e) === e; }, enqueueSetState(e, t, r) { e = e._reactInternals; const n = tl(); const i = rl(e); const a = Oa(n, i); a.payload = t, void 0 !== r && r !== null && (a.callback = r), (t = Da(e, a, i)) !== null && (nl(t, e, i, n), za(t, e, i)); }, enqueueReplaceState(e, t, r) { e = e._reactInternals; const n = tl(); const i = rl(e); const a = Oa(n, i); a.tag = 1, a.payload = t, void 0 !== r && r !== null && (a.callback = r), (t = Da(e, a, i)) !== null && (nl(t, e, i, n), za(t, e, i)); }, enqueueForceUpdate(e, t) { e = e._reactInternals; const r = tl(); const n = rl(e); const i = Oa(r, n); i.tag = 2, void 0 !== t && t !== null && (i.callback = t), (t = Da(e, i, n)) !== null && (nl(t, e, n, r), za(t, e, n)); },
      }; function Va(e, t, r, n, i, a, o) { return typeof (e = e.stateNode).shouldComponentUpdate === 'function' ? e.shouldComponentUpdate(n, a, o) : !t.prototype || !t.prototype.isPureReactComponent || (!un(r, n) || !un(i, a)); } function Ya(e, t, r) { let n = !1; let i = Ci; let a = t.contextType; return typeof a === 'object' && a !== null ? a = Ma(a) : (i = Ii(t) ? Ti : Pi.current, a = (n = (n = t.contextTypes) !== null && void 0 !== n) ? Ri(e, i) : Ci), t = new t(r, a), e.memoizedState = t.state !== null && void 0 !== t.state ? t.state : null, t.updater = Ua, e.stateNode = t, t._reactInternals = e, n && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = a), t; } function Ha(e, t, r, n) { e = t.state, typeof t.componentWillReceiveProps === 'function' && t.componentWillReceiveProps(r, n), typeof t.UNSAFE_componentWillReceiveProps === 'function' && t.UNSAFE_componentWillReceiveProps(r, n), t.state !== e && Ua.enqueueReplaceState(t, t.state, null); } function qa(e, t, r, n) { const i = e.stateNode; i.props = r, i.state = e.memoizedState, i.refs = Fa, Ra(e); let a = t.contextType; typeof a === 'object' && a !== null ? i.context = Ma(a) : (a = Ii(t) ? Ti : Pi.current, i.context = Ri(e, a)), i.state = e.memoizedState, typeof (a = t.getDerivedStateFromProps) === 'function' && (Ba(e, t, a, r), i.state = e.memoizedState), typeof t.getDerivedStateFromProps === 'function' || typeof i.getSnapshotBeforeUpdate === 'function' || typeof i.UNSAFE_componentWillMount !== 'function' && typeof i.componentWillMount !== 'function' || (t = i.state, typeof i.componentWillMount === 'function' && i.componentWillMount(), typeof i.UNSAFE_componentWillMount === 'function' && i.UNSAFE_componentWillMount(), t !== i.state && Ua.enqueueReplaceState(i, i.state, null), La(e, r, i, n), i.state = e.memoizedState), typeof i.componentDidMount === 'function' && (e.flags |= 4194308); } function Wa(e, t, r) { if ((e = r.ref) !== null && typeof e !== 'function' && typeof e !== 'object') { if (r._owner) { if (r = r._owner) { if (r.tag !== 1) throw Error(a(309)); var n = r.stateNode; } if (!n) throw Error(a(147, e)); const i = n; const o = `${e}`; return t !== null && t.ref !== null && typeof t.ref === 'function' && t.ref._stringRef === o ? t.ref : (t = function (e) { let t = i.refs; t === Fa && (t = i.refs = {}), e === null ? delete t[o] : t[o] = e; }, t._stringRef = o, t); } if (typeof e !== 'string') throw Error(a(284)); if (!r._owner) throw Error(a(290, e)); } return e; } function Xa(e, t) { throw e = Object.prototype.toString.call(t), Error(a(31, e === '[object Object]' ? `object with keys {${Object.keys(t).join(', ')}}` : e)); } function Ga(e) { return (0, e._init)(e._payload); } function $a(e) { function t(t, r) { if (e) { const n = t.deletions; n === null ? (t.deletions = [r], t.flags |= 16) : n.push(r); } } function r(r, n) { if (!e) return null; for (;n !== null;)t(r, n), n = n.sibling; return null; } function n(e, t) { for (e = new Map(); t !== null;)t.key !== null ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling; return e; } function i(e, t) { return (e = Dl(e, t)).index = 0, e.sibling = null, e; } function o(t, r, n) { return t.index = n, e ? (n = t.alternate) !== null ? (n = n.index) < r ? (t.flags |= 2, r) : n : (t.flags |= 2, r) : (t.flags |= 1048576, r); } function s(t) { return e && t.alternate === null && (t.flags |= 2), t; } function u(e, t, r, n) { return t === null || t.tag !== 6 ? ((t = jl(r, e.mode, n)).return = e, t) : ((t = i(t, r)).return = e, t); } function l(e, t, r, n) { const a = r.type; return a === _ ? h(e, t, r.props.children, n, r.key) : t !== null && (t.elementType === a || typeof a === 'object' && a !== null && a.$$typeof === I && Ga(a) === t.type) ? ((n = i(t, r.props)).ref = Wa(e, t, r), n.return = e, n) : ((n = zl(r.type, r.key, r.props, null, e.mode, n)).ref = Wa(e, t, r), n.return = e, n); } function c(e, t, r, n) { return t === null || t.tag !== 4 || t.stateNode.containerInfo !== r.containerInfo || t.stateNode.implementation !== r.implementation ? ((t = Fl(r, e.mode, n)).return = e, t) : ((t = i(t, r.children || [])).return = e, t); } function h(e, t, r, n, a) { return t === null || t.tag !== 7 ? ((t = Nl(r, e.mode, n, a)).return = e, t) : ((t = i(t, r)).return = e, t); } function f(e, t, r) { if (typeof t === 'string' && t !== '' || typeof t === 'number') return (t = jl(`${t}`, e.mode, r)).return = e, t; if (typeof t === 'object' && t !== null) { switch (t.$$typeof) { case k: return (r = zl(t.type, t.key, t.props, null, e.mode, r)).ref = Wa(e, null, t), r.return = e, r; case x: return (t = Fl(t, e.mode, r)).return = e, t; case I: return f(e, (0, t._init)(t._payload), r); } if (te(t) || z(t)) return (t = Nl(t, e.mode, r, null)).return = e, t; Xa(e, t); } return null; } function d(e, t, r, n) { let i = t !== null ? t.key : null; if (typeof r === 'string' && r !== '' || typeof r === 'number') return i !== null ? null : u(e, t, `${r}`, n); if (typeof r === 'object' && r !== null) { switch (r.$$typeof) { case k: return r.key === i ? l(e, t, r, n) : null; case x: return r.key === i ? c(e, t, r, n) : null; case I: return d(e, t, (i = r._init)(r._payload), n); } if (te(r) || z(r)) return i !== null ? null : h(e, t, r, n, null); Xa(e, r); } return null; } function p(e, t, r, n, i) { if (typeof n === 'string' && n !== '' || typeof n === 'number') return u(t, e = e.get(r) || null, `${n}`, i); if (typeof n === 'object' && n !== null) { switch (n.$$typeof) { case k: return l(t, e = e.get(n.key === null ? r : n.key) || null, n, i); case x: return c(t, e = e.get(n.key === null ? r : n.key) || null, n, i); case I: return p(e, t, r, (0, n._init)(n._payload), i); } if (te(n) || z(n)) return h(t, e = e.get(r) || null, n, i, null); Xa(t, n); } return null; } function m(i, a, s, u) { for (var l = null, c = null, h = a, m = a = 0, v = null; h !== null && m < s.length; m++) { h.index > m ? (v = h, h = null) : v = h.sibling; const g = d(i, h, s[m], u); if (g === null) { h === null && (h = v); break; }e && h && g.alternate === null && t(i, h), a = o(g, a, m), c === null ? l = g : c.sibling = g, c = g, h = v; } if (m === s.length) return r(i, h), ia && Qi(i, m), l; if (h === null) { for (;m < s.length; m++)(h = f(i, s[m], u)) !== null && (a = o(h, a, m), c === null ? l = h : c.sibling = h, c = h); return ia && Qi(i, m), l; } for (h = n(i, h); m < s.length; m++)(v = p(h, i, m, s[m], u)) !== null && (e && v.alternate !== null && h.delete(v.key === null ? m : v.key), a = o(v, a, m), c === null ? l = v : c.sibling = v, c = v); return e && h.forEach(((e) => t(i, e))), ia && Qi(i, m), l; } function v(i, s, u, l) { let c = z(u); if (typeof c !== 'function') throw Error(a(150)); if ((u = c.call(u)) == null) throw Error(a(151)); for (var h = c = null, m = s, v = s = 0, g = null, y = u.next(); m !== null && !y.done; v++, y = u.next()) { m.index > v ? (g = m, m = null) : g = m.sibling; const b = d(i, m, y.value, l); if (b === null) { m === null && (m = g); break; }e && m && b.alternate === null && t(i, m), s = o(b, s, v), h === null ? c = b : h.sibling = b, h = b, m = g; } if (y.done) return r(i, m), ia && Qi(i, v), c; if (m === null) { for (;!y.done; v++, y = u.next())(y = f(i, y.value, l)) !== null && (s = o(y, s, v), h === null ? c = y : h.sibling = y, h = y); return ia && Qi(i, v), c; } for (m = n(i, m); !y.done; v++, y = u.next())(y = p(m, i, v, y.value, l)) !== null && (e && y.alternate !== null && m.delete(y.key === null ? v : y.key), s = o(y, s, v), h === null ? c = y : h.sibling = y, h = y); return e && m.forEach(((e) => t(i, e))), ia && Qi(i, v), c; } return function e(n, a, o, u) { if (typeof o === 'object' && o !== null && o.type === _ && o.key === null && (o = o.props.children), typeof o === 'object' && o !== null) { switch (o.$$typeof) { case k: e: { for (var l = o.key, c = a; c !== null;) { if (c.key === l) { if ((l = o.type) === _) { if (c.tag === 7) { r(n, c.sibling), (a = i(c, o.props.children)).return = n, n = a; break e; } } else if (c.elementType === l || typeof l === 'object' && l !== null && l.$$typeof === I && Ga(l) === c.type) { r(n, c.sibling), (a = i(c, o.props)).ref = Wa(n, c, o), a.return = n, n = a; break e; }r(n, c); break; }t(n, c), c = c.sibling; }o.type === _ ? ((a = Nl(o.props.children, n.mode, u, o.key)).return = n, n = a) : ((u = zl(o.type, o.key, o.props, null, n.mode, u)).ref = Wa(n, a, o), u.return = n, n = u); } return s(n); case x: e: { for (c = o.key; a !== null;) { if (a.key === c) { if (a.tag === 4 && a.stateNode.containerInfo === o.containerInfo && a.stateNode.implementation === o.implementation) { r(n, a.sibling), (a = i(a, o.children || [])).return = n, n = a; break e; }r(n, a); break; }t(n, a), a = a.sibling; }(a = Fl(o, n.mode, u)).return = n, n = a; } return s(n); case I: return e(n, a, (c = o._init)(o._payload), u); } if (te(o)) return m(n, a, o, u); if (z(o)) return v(n, a, o, u); Xa(n, o); } return typeof o === 'string' && o !== '' || typeof o === 'number' ? (o = `${o}`, a !== null && a.tag === 6 ? (r(n, a.sibling), (a = i(a, o)).return = n, n = a) : (r(n, a), (a = jl(o, n.mode, u)).return = n, n = a), s(n)) : r(n, a); }; } const Za = $a(!0); const Ka = $a(!1); const Qa = {}; const Ja = Si(Qa); const eo = Si(Qa); const to = Si(Qa); function ro(e) { if (e === Qa) throw Error(a(174)); return e; } function no(e, t) { switch (Ei(to, t), Ei(eo, e), Ei(Ja, Qa), e = t.nodeType) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : ue(null, ''); break; default: t = ue(t = (e = e === 8 ? t.parentNode : t).namespaceURI || null, e = e.tagName); }Mi(Ja), Ei(Ja, t); } function io() { Mi(Ja), Mi(eo), Mi(to); } function ao(e) { ro(to.current); const t = ro(Ja.current); const r = ue(t, e.type); t !== r && (Ei(eo, e), Ei(Ja, r)); } function oo(e) { eo.current === e && (Mi(Ja), Mi(eo)); } const so = Si(0); function uo(e) { for (let t = e; t !== null;) { if (t.tag === 13) { let r = t.memoizedState; if (r !== null && ((r = r.dehydrated) === null || r.data === '$?' || r.data === '$!')) return t; } else if (t.tag === 19 && void 0 !== t.memoizedProps.revealOrder) { if ((128 & t.flags) !== 0) return t; } else if (t.child !== null) { t.child.return = t, t = t.child; continue; } if (t === e) break; for (;t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return; }t.sibling.return = t.return, t = t.sibling; } return null; } const lo = []; function co() { for (let e = 0; e < lo.length; e++)lo[e]._workInProgressVersionPrimary = null; lo.length = 0; } const ho = w.ReactCurrentDispatcher; const fo = w.ReactCurrentBatchConfig; let po = 0; let mo = null; let vo = null; let go = null; let yo = !1; let bo = !1; let wo = 0; let ko = 0; function xo() { throw Error(a(321)); } function _o(e, t) { if (t === null) return !1; for (let r = 0; r < t.length && r < e.length; r++) if (!sn(e[r], t[r])) return !1; return !0; } function So(e, t, r, n, i, o) { if (po = o, mo = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, ho.current = e === null || e.memoizedState === null ? ss : us, e = r(n, i), bo) { o = 0; do { if (bo = !1, wo = 0, o >= 25) throw Error(a(301)); o += 1, go = vo = null, t.updateQueue = null, ho.current = ls, e = r(n, i); } while (bo); } if (ho.current = os, t = vo !== null && vo.next !== null, po = 0, go = vo = mo = null, yo = !1, t) throw Error(a(300)); return e; } function Mo() { const e = wo !== 0; return wo = 0, e; } function Eo() {
        const e = {
          memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null,
        }; return go === null ? mo.memoizedState = go = e : go = go.next = e, go;
      } function Co() {
        if (vo === null) { var e = mo.alternate; e = e !== null ? e.memoizedState : null; } else e = vo.next; const t = go === null ? mo.memoizedState : go.next; if (t !== null)go = t, vo = e; else {
          if (e === null) throw Error(a(310)); e = {
            memoizedState: (vo = e).memoizedState, baseState: vo.baseState, baseQueue: vo.baseQueue, queue: vo.queue, next: null,
          }, go === null ? mo.memoizedState = go = e : go = go.next = e;
        } return go;
      } function Po(e, t) { return typeof t === 'function' ? t(e) : t; } function Ao(e) {
        const t = Co(); const r = t.queue; if (r === null) throw Error(a(311)); r.lastRenderedReducer = e; let n = vo; let i = n.baseQueue; let o = r.pending; if (o !== null) { if (i !== null) { var s = i.next; i.next = o.next, o.next = s; }n.baseQueue = i = o, r.pending = null; } if (i !== null) {
          o = i.next, n = n.baseState; let u = s = null; let l = null; let c = o; do {
            const h = c.lane; if ((po & h) === h) {
              l !== null && (l = l.next = {
                lane: 0, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null,
              }), n = c.hasEagerState ? c.eagerState : e(n, c.action);
            } else {
              const f = {
                lane: h, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null,
              }; l === null ? (u = l = f, s = n) : l = l.next = f, mo.lanes |= h, Lu |= h;
            }c = c.next;
          } while (c !== null && c !== o); l === null ? s = n : l.next = u, sn(n, t.memoizedState) || (ws = !0), t.memoizedState = n, t.baseState = s, t.baseQueue = l, r.lastRenderedState = n;
        } if ((e = r.interleaved) !== null) { i = e; do { o = i.lane, mo.lanes |= o, Lu |= o, i = i.next; } while (i !== e); } else i === null && (r.lanes = 0); return [t.memoizedState, r.dispatch];
      } function To(e) { const t = Co(); const r = t.queue; if (r === null) throw Error(a(311)); r.lastRenderedReducer = e; const n = r.dispatch; let i = r.pending; let o = t.memoizedState; if (i !== null) { r.pending = null; let s = i = i.next; do { o = e(o, s.action), s = s.next; } while (s !== i); sn(o, t.memoizedState) || (ws = !0), t.memoizedState = o, t.baseQueue === null && (t.baseState = o), r.lastRenderedState = o; } return [o, n]; } function Ro() {} function Io(e, t) { const r = mo; let n = Co(); const i = t(); const o = !sn(n.memoizedState, i); if (o && (n.memoizedState = i, ws = !0), n = n.queue, Ho(zo.bind(null, r, n, e), [e]), n.getSnapshot !== t || o || go !== null && 1 & go.memoizedState.tag) { if (r.flags |= 2048, Fo(9, Do.bind(null, r, n, i, t), void 0, null), Tu === null) throw Error(a(349)); (30 & po) !== 0 || Oo(r, t, i); } return i; } function Oo(e, t, r) { e.flags |= 16384, e = { getSnapshot: t, value: r }, (t = mo.updateQueue) === null ? (t = { lastEffect: null, stores: null }, mo.updateQueue = t, t.stores = [e]) : (r = t.stores) === null ? t.stores = [e] : r.push(e); } function Do(e, t, r, n) { t.value = r, t.getSnapshot = n, No(t) && Lo(e); } function zo(e, t, r) { return r((() => { No(t) && Lo(e); })); } function No(e) { const t = e.getSnapshot; e = e.value; try { const r = t(); return !sn(e, r); } catch (n) { return !0; } } function Lo(e) { const t = Aa(e, 1); t !== null && nl(t, e, 1, -1); } function jo(e) {
        const t = Eo(); return typeof e === 'function' && (e = e()), t.memoizedState = t.baseState = e, e = {
          pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Po, lastRenderedState: e,
        }, t.queue = e, e = e.dispatch = rs.bind(null, mo, e), [t.memoizedState, e];
      } function Fo(e, t, r, n) {
        return e = {
          tag: e, create: t, destroy: r, deps: n, next: null,
        }, (t = mo.updateQueue) === null ? (t = { lastEffect: null, stores: null }, mo.updateQueue = t, t.lastEffect = e.next = e) : (r = t.lastEffect) === null ? t.lastEffect = e.next = e : (n = r.next, r.next = e, e.next = n, t.lastEffect = e), e;
      } function Bo() { return Co().memoizedState; } function Uo(e, t, r, n) { const i = Eo(); mo.flags |= e, i.memoizedState = Fo(1 | t, r, void 0, void 0 === n ? null : n); } function Vo(e, t, r, n) { const i = Co(); n = void 0 === n ? null : n; let a = void 0; if (vo !== null) { const o = vo.memoizedState; if (a = o.destroy, n !== null && _o(n, o.deps)) return void (i.memoizedState = Fo(t, r, a, n)); }mo.flags |= e, i.memoizedState = Fo(1 | t, r, a, n); } function Yo(e, t) { return Uo(8390656, 8, e, t); } function Ho(e, t) { return Vo(2048, 8, e, t); } function qo(e, t) { return Vo(4, 2, e, t); } function Wo(e, t) { return Vo(4, 4, e, t); } function Xo(e, t) { return typeof t === 'function' ? (e = e(), t(e), function () { t(null); }) : t !== null && void 0 !== t ? (e = e(), t.current = e, function () { t.current = null; }) : void 0; } function Go(e, t, r) { return r = r !== null && void 0 !== r ? r.concat([e]) : null, Vo(4, 4, Xo.bind(null, t, e), r); } function $o() {} function Zo(e, t) { const r = Co(); t = void 0 === t ? null : t; const n = r.memoizedState; return n !== null && t !== null && _o(t, n[1]) ? n[0] : (r.memoizedState = [e, t], e); } function Ko(e, t) { const r = Co(); t = void 0 === t ? null : t; const n = r.memoizedState; return n !== null && t !== null && _o(t, n[1]) ? n[0] : (e = e(), r.memoizedState = [e, t], e); } function Qo(e, t, r) { return (21 & po) === 0 ? (e.baseState && (e.baseState = !1, ws = !0), e.memoizedState = r) : (sn(r, t) || (r = mt(), mo.lanes |= r, Lu |= r, e.baseState = !0), t); } function Jo(e, t) { const r = bt; bt = r !== 0 && r < 4 ? r : 4, e(!0); const n = fo.transition; fo.transition = {}; try { e(!1), t(); } finally { bt = r, fo.transition = n; } } function es() { return Co().memoizedState; } function ts(e, t, r) {
        const n = rl(e); if (r = {
          lane: n, action: r, hasEagerState: !1, eagerState: null, next: null,
        }, ns(e))is(t, r); else if ((r = Pa(e, t, r, n)) !== null) { nl(r, e, n, tl()), as(r, t, n); }
      } function rs(e, t, r) {
        const n = rl(e); let i = {
          lane: n, action: r, hasEagerState: !1, eagerState: null, next: null,
        }; if (ns(e))is(t, i); else { let a = e.alternate; if (e.lanes === 0 && (a === null || a.lanes === 0) && (a = t.lastRenderedReducer) !== null) try { const o = t.lastRenderedState; const s = a(o, r); if (i.hasEagerState = !0, i.eagerState = s, sn(s, o)) { const u = t.interleaved; return u === null ? (i.next = i, Ca(t)) : (i.next = u.next, u.next = i), void (t.interleaved = i); } } catch (l) {}(r = Pa(e, t, i, n)) !== null && (nl(r, e, n, i = tl()), as(r, t, n)); }
      } function ns(e) { const t = e.alternate; return e === mo || t !== null && t === mo; } function is(e, t) { bo = yo = !0; const r = e.pending; r === null ? t.next = t : (t.next = r.next, r.next = t), e.pending = t; } function as(e, t, r) { if ((4194240 & r) !== 0) { let n = t.lanes; r |= n &= e.pendingLanes, t.lanes = r, yt(e, r); } } var os = {
        readContext: Ma, useCallback: xo, useContext: xo, useEffect: xo, useImperativeHandle: xo, useInsertionEffect: xo, useLayoutEffect: xo, useMemo: xo, useReducer: xo, useRef: xo, useState: xo, useDebugValue: xo, useDeferredValue: xo, useTransition: xo, useMutableSource: xo, useSyncExternalStore: xo, useId: xo, unstable_isNewReconciler: !1,
      }; var ss = {
        readContext: Ma,
        useCallback(e, t) { return Eo().memoizedState = [e, void 0 === t ? null : t], e; },
        useContext: Ma,
        useEffect: Yo,
        useImperativeHandle(e, t, r) { return r = r !== null && void 0 !== r ? r.concat([e]) : null, Uo(4194308, 4, Xo.bind(null, t, e), r); },
        useLayoutEffect(e, t) { return Uo(4194308, 4, e, t); },
        useInsertionEffect(e, t) { return Uo(4, 2, e, t); },
        useMemo(e, t) { const r = Eo(); return t = void 0 === t ? null : t, e = e(), r.memoizedState = [e, t], e; },
        useReducer(e, t, r) {
          const n = Eo(); return t = void 0 !== r ? r(t) : t, n.memoizedState = n.baseState = t, e = {
            pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t,
          }, n.queue = e, e = e.dispatch = ts.bind(null, mo, e), [n.memoizedState, e];
        },
        useRef(e) { return e = { current: e }, Eo().memoizedState = e; },
        useState: jo,
        useDebugValue: $o,
        useDeferredValue(e) { return Eo().memoizedState = e; },
        useTransition() { let e = jo(!1); const t = e[0]; return e = Jo.bind(null, e[1]), Eo().memoizedState = e, [t, e]; },
        useMutableSource() {},
        useSyncExternalStore(e, t, r) { const n = mo; const i = Eo(); if (ia) { if (void 0 === r) throw Error(a(407)); r = r(); } else { if (r = t(), Tu === null) throw Error(a(349)); (30 & po) !== 0 || Oo(n, t, r); }i.memoizedState = r; const o = { value: r, getSnapshot: t }; return i.queue = o, Yo(zo.bind(null, n, o, e), [e]), n.flags |= 2048, Fo(9, Do.bind(null, n, o, r, t), void 0, null), r; },
        useId() { const e = Eo(); let t = Tu.identifierPrefix; if (ia) { var r = Ki; t = `:${t}R${r = (Zi & ~(1 << 32 - ot(Zi) - 1)).toString(32) + r}`, (r = wo++) > 0 && (t += `H${r.toString(32)}`), t += ':'; } else t = `:${t}r${(r = ko++).toString(32)}:`; return e.memoizedState = t; },
        unstable_isNewReconciler: !1,
      }; var us = {
        readContext: Ma, useCallback: Zo, useContext: Ma, useEffect: Ho, useImperativeHandle: Go, useInsertionEffect: qo, useLayoutEffect: Wo, useMemo: Ko, useReducer: Ao, useRef: Bo, useState() { return Ao(Po); }, useDebugValue: $o, useDeferredValue(e) { return Qo(Co(), vo.memoizedState, e); }, useTransition() { return [Ao(Po)[0], Co().memoizedState]; }, useMutableSource: Ro, useSyncExternalStore: Io, useId: es, unstable_isNewReconciler: !1,
      }; var ls = {
        readContext: Ma, useCallback: Zo, useContext: Ma, useEffect: Ho, useImperativeHandle: Go, useInsertionEffect: qo, useLayoutEffect: Wo, useMemo: Ko, useReducer: To, useRef: Bo, useState() { return To(Po); }, useDebugValue: $o, useDeferredValue(e) { const t = Co(); return vo === null ? t.memoizedState = e : Qo(t, vo.memoizedState, e); }, useTransition() { return [To(Po)[0], Co().memoizedState]; }, useMutableSource: Ro, useSyncExternalStore: Io, useId: es, unstable_isNewReconciler: !1,
      }; function cs(e, t) {
        try { let r = ''; let n = t; do { r += U(n), n = n.return; } while (n); var i = r; } catch (a) { i = `\nError generating stack: ${a.message}\n${a.stack}`; } return {
          value: e, source: t, stack: i, digest: null,
        };
      } function hs(e, t, r) {
        return {
          value: e, source: null, stack: r != null ? r : null, digest: t != null ? t : null,
        };
      } function fs(e, t) { try { console.error(t.value); } catch (r) { setTimeout((() => { throw r; })); } } const ds = typeof WeakMap === 'function' ? WeakMap : Map; function ps(e, t, r) { (r = Oa(-1, r)).tag = 3, r.payload = { element: null }; const n = t.value; return r.callback = function () { qu || (qu = !0, Wu = n), fs(0, t); }, r; } function ms(e, t, r) { (r = Oa(-1, r)).tag = 3; const n = e.type.getDerivedStateFromError; if (typeof n === 'function') { const i = t.value; r.payload = function () { return n(i); }, r.callback = function () { fs(0, t); }; } const a = e.stateNode; return a !== null && typeof a.componentDidCatch === 'function' && (r.callback = function () { fs(0, t), typeof n !== 'function' && (Xu === null ? Xu = new Set([this]) : Xu.add(this)); const e = t.stack; this.componentDidCatch(t.value, { componentStack: e !== null ? e : '' }); }), r; } function vs(e, t, r) { let n = e.pingCache; if (n === null) { n = e.pingCache = new ds(); var i = new Set(); n.set(t, i); } else void 0 === (i = n.get(t)) && (i = new Set(), n.set(t, i)); i.has(r) || (i.add(r), e = El.bind(null, e, t, r), t.then(e, e)); } function gs(e) { do { var t; if ((t = e.tag === 13) && (t = (t = e.memoizedState) === null || t.dehydrated !== null), t) return e; e = e.return; } while (e !== null); return null; } function ys(e, t, r, n, i) { return (1 & e.mode) === 0 ? (e === t ? e.flags |= 65536 : (e.flags |= 128, r.flags |= 131072, r.flags &= -52805, r.tag === 1 && (r.alternate === null ? r.tag = 17 : ((t = Oa(-1, 1)).tag = 2, Da(r, t, 1))), r.lanes |= 1), e) : (e.flags |= 65536, e.lanes = i, e); } const bs = w.ReactCurrentOwner; var ws = !1; function ks(e, t, r, n) { t.child = e === null ? Ka(t, null, r, n) : Za(t, e.child, r, n); } function xs(e, t, r, n, i) { r = r.render; const a = t.ref; return Sa(t, i), n = So(e, t, r, n, a, i), r = Mo(), e === null || ws ? (ia && r && ea(t), t.flags |= 1, ks(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, qs(e, t, i)); } function _s(e, t, r, n, i) { if (e === null) { var a = r.type; return typeof a !== 'function' || Ol(a) || void 0 !== a.defaultProps || r.compare !== null || void 0 !== r.defaultProps ? ((e = zl(r.type, null, n, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = a, Ss(e, t, a, n, i)); } if (a = e.child, (e.lanes & i) === 0) { const o = a.memoizedProps; if ((r = (r = r.compare) !== null ? r : un)(o, n) && e.ref === t.ref) return qs(e, t, i); } return t.flags |= 1, (e = Dl(a, n)).ref = t.ref, e.return = t, t.child = e; } function Ss(e, t, r, n, i) { if (e !== null) { const a = e.memoizedProps; if (un(a, n) && e.ref === t.ref) { if (ws = !1, t.pendingProps = n = a, (e.lanes & i) === 0) return t.lanes = e.lanes, qs(e, t, i); (131072 & e.flags) !== 0 && (ws = !0); } } return Cs(e, t, r, n, i); } function Ms(e, t, r) { let n = t.pendingProps; const i = n.children; const a = e !== null ? e.memoizedState : null; if (n.mode === 'hidden') if ((1 & t.mode) === 0)t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ei(Du, Ou), Ou |= r; else { if ((1073741824 & r) === 0) return e = a !== null ? a.baseLanes | r : r, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Ei(Du, Ou), Ou |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, n = a !== null ? a.baseLanes : r, Ei(Du, Ou), Ou |= n; } else a !== null ? (n = a.baseLanes | r, t.memoizedState = null) : n = r, Ei(Du, Ou), Ou |= n; return ks(e, t, i, r), t.child; } function Es(e, t) { const r = t.ref; (e === null && r !== null || e !== null && e.ref !== r) && (t.flags |= 512, t.flags |= 2097152); } function Cs(e, t, r, n, i) { let a = Ii(r) ? Ti : Pi.current; return a = Ri(t, a), Sa(t, i), r = So(e, t, r, n, a, i), n = Mo(), e === null || ws ? (ia && n && ea(t), t.flags |= 1, ks(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, qs(e, t, i)); } function Ps(e, t, r, n, i) { if (Ii(r)) { var a = !0; Ni(t); } else a = !1; if (Sa(t, i), t.stateNode === null)Hs(e, t), Ya(t, r, n), qa(t, r, n, i), n = !0; else if (e === null) { var o = t.stateNode; var s = t.memoizedProps; o.props = s; var u = o.context; var l = r.contextType; typeof l === 'object' && l !== null ? l = Ma(l) : l = Ri(t, l = Ii(r) ? Ti : Pi.current); var c = r.getDerivedStateFromProps; var h = typeof c === 'function' || typeof o.getSnapshotBeforeUpdate === 'function'; h || typeof o.UNSAFE_componentWillReceiveProps !== 'function' && typeof o.componentWillReceiveProps !== 'function' || (s !== n || u !== l) && Ha(t, o, n, l), Ta = !1; var f = t.memoizedState; o.state = f, La(t, n, o, i), u = t.memoizedState, s !== n || f !== u || Ai.current || Ta ? (typeof c === 'function' && (Ba(t, r, c, n), u = t.memoizedState), (s = Ta || Va(t, r, s, n, f, u, l)) ? (h || typeof o.UNSAFE_componentWillMount !== 'function' && typeof o.componentWillMount !== 'function' || (typeof o.componentWillMount === 'function' && o.componentWillMount(), typeof o.UNSAFE_componentWillMount === 'function' && o.UNSAFE_componentWillMount()), typeof o.componentDidMount === 'function' && (t.flags |= 4194308)) : (typeof o.componentDidMount === 'function' && (t.flags |= 4194308), t.memoizedProps = n, t.memoizedState = u), o.props = n, o.state = u, o.context = l, n = s) : (typeof o.componentDidMount === 'function' && (t.flags |= 4194308), n = !1); } else { o = t.stateNode, Ia(e, t), s = t.memoizedProps, l = t.type === t.elementType ? s : va(t.type, s), o.props = l, h = t.pendingProps, f = o.context, typeof (u = r.contextType) === 'object' && u !== null ? u = Ma(u) : u = Ri(t, u = Ii(r) ? Ti : Pi.current); const d = r.getDerivedStateFromProps; (c = typeof d === 'function' || typeof o.getSnapshotBeforeUpdate === 'function') || typeof o.UNSAFE_componentWillReceiveProps !== 'function' && typeof o.componentWillReceiveProps !== 'function' || (s !== h || f !== u) && Ha(t, o, n, u), Ta = !1, f = t.memoizedState, o.state = f, La(t, n, o, i); let p = t.memoizedState; s !== h || f !== p || Ai.current || Ta ? (typeof d === 'function' && (Ba(t, r, d, n), p = t.memoizedState), (l = Ta || Va(t, r, l, n, f, p, u) || !1) ? (c || typeof o.UNSAFE_componentWillUpdate !== 'function' && typeof o.componentWillUpdate !== 'function' || (typeof o.componentWillUpdate === 'function' && o.componentWillUpdate(n, p, u), typeof o.UNSAFE_componentWillUpdate === 'function' && o.UNSAFE_componentWillUpdate(n, p, u)), typeof o.componentDidUpdate === 'function' && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate === 'function' && (t.flags |= 1024)) : (typeof o.componentDidUpdate !== 'function' || s === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate !== 'function' || s === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), t.memoizedProps = n, t.memoizedState = p), o.props = n, o.state = p, o.context = u, n = l) : (typeof o.componentDidUpdate !== 'function' || s === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate !== 'function' || s === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), n = !1); } return As(e, t, r, n, a, i); } function As(e, t, r, n, i, a) { Es(e, t); const o = (128 & t.flags) !== 0; if (!n && !o) return i && Li(t, r, !1), qs(e, t, a); n = t.stateNode, bs.current = t; const s = o && typeof r.getDerivedStateFromError !== 'function' ? null : n.render(); return t.flags |= 1, e !== null && o ? (t.child = Za(t, e.child, null, a), t.child = Za(t, null, s, a)) : ks(e, t, s, a), t.memoizedState = n.state, i && Li(t, r, !0), t.child; } function Ts(e) { const t = e.stateNode; t.pendingContext ? Di(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Di(0, t.context, !1), no(e, t.containerInfo); } function Rs(e, t, r, n, i) { return da(), pa(i), t.flags |= 256, ks(e, t, r, n), t.child; } let Is; let Os; let Ds; let zs; const Ns = { dehydrated: null, treeContext: null, retryLane: 0 }; function Ls(e) { return { baseLanes: e, cachePool: null, transitions: null }; } function js(e, t, r) { let n; let i = t.pendingProps; let o = so.current; let s = !1; let u = (128 & t.flags) !== 0; if ((n = u) || (n = (e === null || e.memoizedState !== null) && (2 & o) !== 0), n ? (s = !0, t.flags &= -129) : e !== null && e.memoizedState === null || (o |= 1), Ei(so, 1 & o), e === null) return la(t), (e = t.memoizedState) !== null && (e = e.dehydrated) !== null ? ((1 & t.mode) === 0 ? t.lanes = 1 : e.data === '$!' ? t.lanes = 8 : t.lanes = 1073741824, null) : (u = i.children, e = i.fallback, s ? (i = t.mode, s = t.child, u = { mode: 'hidden', children: u }, (1 & i) === 0 && s !== null ? (s.childLanes = 0, s.pendingProps = u) : s = Ll(u, i, 0, null), e = Nl(e, i, r, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = Ls(r), t.memoizedState = Ns, e) : Fs(t, u)); if ((o = e.memoizedState) !== null && (n = o.dehydrated) !== null) return (function (e, t, r, n, i, o, s) { if (r) return 256 & t.flags ? (t.flags &= -257, Bs(e, t, s, n = hs(Error(a(422))))) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (o = n.fallback, i = t.mode, n = Ll({ mode: 'visible', children: n.children }, i, 0, null), (o = Nl(o, i, s, null)).flags |= 2, n.return = t, o.return = t, n.sibling = o, t.child = n, (1 & t.mode) !== 0 && Za(t, e.child, null, s), t.child.memoizedState = Ls(s), t.memoizedState = Ns, o); if ((1 & t.mode) === 0) return Bs(e, t, s, null); if (i.data === '$!') { if (n = i.nextSibling && i.nextSibling.dataset) var u = n.dgst; return n = u, Bs(e, t, s, n = hs(o = Error(a(419)), n, void 0)); } if (u = (s & e.childLanes) !== 0, ws || u) { if ((n = Tu) !== null) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0; }(i = (i & (n.suspendedLanes | s)) !== 0 ? 0 : i) !== 0 && i !== o.retryLane && (o.retryLane = i, Aa(e, i), nl(n, e, i, -1)); } return vl(), Bs(e, t, s, n = hs(Error(a(421)))); } return i.data === '$?' ? (t.flags |= 128, t.child = e.child, t = Pl.bind(null, e), i._reactRetry = t, null) : (e = o.treeContext, na = li(i.nextSibling), ra = t, ia = !0, aa = null, e !== null && (Xi[Gi++] = Zi, Xi[Gi++] = Ki, Xi[Gi++] = $i, Zi = e.id, Ki = e.overflow, $i = t), t = Fs(t, n.children), t.flags |= 4096, t); }(e, t, u, i, n, o, r)); if (s) { s = i.fallback, u = t.mode, n = (o = e.child).sibling; const l = { mode: 'hidden', children: i.children }; return (1 & u) === 0 && t.child !== o ? ((i = t.child).childLanes = 0, i.pendingProps = l, t.deletions = null) : (i = Dl(o, l)).subtreeFlags = 14680064 & o.subtreeFlags, n !== null ? s = Dl(n, s) : (s = Nl(s, u, r, null)).flags |= 2, s.return = t, i.return = t, i.sibling = s, t.child = i, i = s, s = t.child, u = (u = e.child.memoizedState) === null ? Ls(r) : { baseLanes: u.baseLanes | r, cachePool: null, transitions: u.transitions }, s.memoizedState = u, s.childLanes = e.childLanes & ~r, t.memoizedState = Ns, i; } return e = (s = e.child).sibling, i = Dl(s, { mode: 'visible', children: i.children }), (1 & t.mode) === 0 && (i.lanes = r), i.return = t, i.sibling = null, e !== null && ((r = t.deletions) === null ? (t.deletions = [e], t.flags |= 16) : r.push(e)), t.child = i, t.memoizedState = null, i; } function Fs(e, t) { return (t = Ll({ mode: 'visible', children: t }, e.mode, 0, null)).return = e, e.child = t; } function Bs(e, t, r, n) { return n !== null && pa(n), Za(t, e.child, null, r), (e = Fs(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e; } function Us(e, t, r) { e.lanes |= t; const n = e.alternate; n !== null && (n.lanes |= t), _a(e.return, t, r); } function Vs(e, t, r, n, i) {
        const a = e.memoizedState; a === null ? e.memoizedState = {
          isBackwards: t, rendering: null, renderingStartTime: 0, last: n, tail: r, tailMode: i,
        } : (a.isBackwards = t, a.rendering = null, a.renderingStartTime = 0, a.last = n, a.tail = r, a.tailMode = i);
      } function Ys(e, t, r) { let n = t.pendingProps; let i = n.revealOrder; const a = n.tail; if (ks(e, t, n.children, r), (2 & (n = so.current)) !== 0)n = 1 & n | 2, t.flags |= 128; else { if (e !== null && (128 & e.flags) !== 0)e:for (e = t.child; e !== null;) { if (e.tag === 13)e.memoizedState !== null && Us(e, r, t); else if (e.tag === 19)Us(e, r, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue; } if (e === t) break; for (;e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return; }e.sibling.return = e.return, e = e.sibling; }n &= 1; } if (Ei(so, n), (1 & t.mode) === 0)t.memoizedState = null; else switch (i) { case 'forwards': for (r = t.child, i = null; r !== null;)(e = r.alternate) !== null && uo(e) === null && (i = r), r = r.sibling; (r = i) === null ? (i = t.child, t.child = null) : (i = r.sibling, r.sibling = null), Vs(t, !1, i, r, a); break; case 'backwards': for (r = null, i = t.child, t.child = null; i !== null;) { if ((e = i.alternate) !== null && uo(e) === null) { t.child = i; break; }e = i.sibling, i.sibling = r, r = i, i = e; }Vs(t, !0, r, null, a); break; case 'together': Vs(t, !1, null, null, void 0); break; default: t.memoizedState = null; } return t.child; } function Hs(e, t) { (1 & t.mode) === 0 && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2); } function qs(e, t, r) { if (e !== null && (t.dependencies = e.dependencies), Lu |= t.lanes, (r & t.childLanes) === 0) return null; if (e !== null && t.child !== e.child) throw Error(a(153)); if (t.child !== null) { for (r = Dl(e = t.child, e.pendingProps), t.child = r, r.return = t; e.sibling !== null;)e = e.sibling, (r = r.sibling = Dl(e, e.pendingProps)).return = t; r.sibling = null; } return t.child; } function Ws(e, t) { if (!ia) switch (e.tailMode) { case 'hidden': t = e.tail; for (var r = null; t !== null;)t.alternate !== null && (r = t), t = t.sibling; r === null ? e.tail = null : r.sibling = null; break; case 'collapsed': r = e.tail; for (var n = null; r !== null;)r.alternate !== null && (n = r), r = r.sibling; n === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : n.sibling = null; } } function Xs(e) { const t = e.alternate !== null && e.alternate.child === e.child; let r = 0; let n = 0; if (t) for (var i = e.child; i !== null;)r |= i.lanes | i.childLanes, n |= 14680064 & i.subtreeFlags, n |= 14680064 & i.flags, i.return = e, i = i.sibling; else for (i = e.child; i !== null;)r |= i.lanes | i.childLanes, n |= i.subtreeFlags, n |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= n, e.childLanes = r, t; } function Gs(e, t, r) { let n = t.pendingProps; switch (ta(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Xs(t), null; case 1: case 17: return Ii(t.type) && Oi(), Xs(t), null; case 3: return n = t.stateNode, io(), Mi(Ai), Mi(Pi), co(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), e !== null && e.child !== null || (ha(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && (256 & t.flags) === 0 || (t.flags |= 1024, aa !== null && (sl(aa), aa = null))), Os(e, t), Xs(t), null; case 5: oo(t); var i = ro(to.current); if (r = t.type, e !== null && t.stateNode != null)Ds(e, t, r, n, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!n) { if (t.stateNode === null) throw Error(a(166)); return Xs(t), null; } if (e = ro(Ja.current), ha(t)) { n = t.stateNode, r = t.type; var o = t.memoizedProps; switch (n[fi] = t, n[di] = o, e = (1 & t.mode) !== 0, r) { case 'dialog': Fn('cancel', n), Fn('close', n); break; case 'iframe': case 'object': case 'embed': Fn('load', n); break; case 'video': case 'audio': for (i = 0; i < zn.length; i++)Fn(zn[i], n); break; case 'source': Fn('error', n); break; case 'img': case 'image': case 'link': Fn('error', n), Fn('load', n); break; case 'details': Fn('toggle', n); break; case 'input': Z(n, o), Fn('invalid', n); break; case 'select': n._wrapperState = { wasMultiple: !!o.multiple }, Fn('invalid', n); break; case 'textarea': ie(n, o), Fn('invalid', n); } for (var u in ye(r, o), i = null, o) if (o.hasOwnProperty(u)) { var l = o[u]; u === 'children' ? typeof l === 'string' ? n.textContent !== l && (!0 !== o.suppressHydrationWarning && Qn(n.textContent, l, e), i = ['children', l]) : typeof l === 'number' && n.textContent !== `${l}` && (!0 !== o.suppressHydrationWarning && Qn(n.textContent, l, e), i = ['children', `${l}`]) : s.hasOwnProperty(u) && l != null && u === 'onScroll' && Fn('scroll', n); } switch (r) { case 'input': W(n), J(n, o, !0); break; case 'textarea': W(n), oe(n); break; case 'select': case 'option': break; default: typeof o.onClick === 'function' && (n.onclick = Jn); }n = i, t.updateQueue = n, n !== null && (t.flags |= 4); } else { u = i.nodeType === 9 ? i : i.ownerDocument, e === 'http://www.w3.org/1999/xhtml' && (e = se(r)), e === 'http://www.w3.org/1999/xhtml' ? r === 'script' ? ((e = u.createElement('div')).innerHTML = '<script><\/script>', e = e.removeChild(e.firstChild)) : typeof n.is === 'string' ? e = u.createElement(r, { is: n.is }) : (e = u.createElement(r), r === 'select' && (u = e, n.multiple ? u.multiple = !0 : n.size && (u.size = n.size))) : e = u.createElementNS(e, r), e[fi] = t, e[di] = n, Is(e, t, !1, !1), t.stateNode = e; e: { switch (u = be(r, n), r) { case 'dialog': Fn('cancel', e), Fn('close', e), i = n; break; case 'iframe': case 'object': case 'embed': Fn('load', e), i = n; break; case 'video': case 'audio': for (i = 0; i < zn.length; i++)Fn(zn[i], e); i = n; break; case 'source': Fn('error', e), i = n; break; case 'img': case 'image': case 'link': Fn('error', e), Fn('load', e), i = n; break; case 'details': Fn('toggle', e), i = n; break; case 'input': Z(e, n), i = $(e, n), Fn('invalid', e); break; case 'option': default: i = n; break; case 'select': e._wrapperState = { wasMultiple: !!n.multiple }, i = { ...n, value: void 0 }, Fn('invalid', e); break; case 'textarea': ie(e, n), i = ne(e, n), Fn('invalid', e); } for (o in ye(r, i), l = i) if (l.hasOwnProperty(o)) { let c = l[o]; o === 'style' ? ve(e, c) : o === 'dangerouslySetInnerHTML' ? (c = c ? c.__html : void 0) != null && he(e, c) : o === 'children' ? typeof c === 'string' ? (r !== 'textarea' || c !== '') && fe(e, c) : typeof c === 'number' && fe(e, `${c}`) : o !== 'suppressContentEditableWarning' && o !== 'suppressHydrationWarning' && o !== 'autoFocus' && (s.hasOwnProperty(o) ? c != null && o === 'onScroll' && Fn('scroll', e) : c != null && b(e, o, c, u)); } switch (r) { case 'input': W(e), J(e, n, !1); break; case 'textarea': W(e), oe(e); break; case 'option': n.value != null && e.setAttribute('value', `${H(n.value)}`); break; case 'select': e.multiple = !!n.multiple, (o = n.value) != null ? re(e, !!n.multiple, o, !1) : n.defaultValue != null && re(e, !!n.multiple, n.defaultValue, !0); break; default: typeof i.onClick === 'function' && (e.onclick = Jn); } switch (r) { case 'button': case 'input': case 'select': case 'textarea': n = !!n.autoFocus; break e; case 'img': n = !0; break e; default: n = !1; } }n && (t.flags |= 4); }t.ref !== null && (t.flags |= 512, t.flags |= 2097152); } return Xs(t), null; case 6: if (e && t.stateNode != null)zs(e, t, e.memoizedProps, n); else { if (typeof n !== 'string' && t.stateNode === null) throw Error(a(166)); if (r = ro(to.current), ro(Ja.current), ha(t)) { if (n = t.stateNode, r = t.memoizedProps, n[fi] = t, (o = n.nodeValue !== r) && (e = ra) !== null) switch (e.tag) { case 3: Qn(n.nodeValue, r, (1 & e.mode) !== 0); break; case 5: !0 !== e.memoizedProps.suppressHydrationWarning && Qn(n.nodeValue, r, (1 & e.mode) !== 0); }o && (t.flags |= 4); } else (n = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(n))[fi] = t, t.stateNode = n; } return Xs(t), null; case 13: if (Mi(so), n = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (ia && na !== null && (1 & t.mode) !== 0 && (128 & t.flags) === 0)fa(), da(), t.flags |= 98560, o = !1; else if (o = ha(t), n !== null && n.dehydrated !== null) { if (e === null) { if (!o) throw Error(a(318)); if (!(o = (o = t.memoizedState) !== null ? o.dehydrated : null)) throw Error(a(317)); o[fi] = t; } else da(), (128 & t.flags) === 0 && (t.memoizedState = null), t.flags |= 4; Xs(t), o = !1; } else aa !== null && (sl(aa), aa = null), o = !0; if (!o) return 65536 & t.flags ? t : null; } return (128 & t.flags) !== 0 ? (t.lanes = r, t) : ((n = n !== null) !== (e !== null && e.memoizedState !== null) && n && (t.child.flags |= 8192, (1 & t.mode) !== 0 && (e === null || (1 & so.current) !== 0 ? zu === 0 && (zu = 3) : vl())), t.updateQueue !== null && (t.flags |= 4), Xs(t), null); case 4: return io(), Os(e, t), e === null && Vn(t.stateNode.containerInfo), Xs(t), null; case 10: return xa(t.type._context), Xs(t), null; case 19: if (Mi(so), (o = t.memoizedState) === null) return Xs(t), null; if (n = (128 & t.flags) !== 0, (u = o.rendering) === null) if (n)Ws(o, !1); else { if (zu !== 0 || e !== null && (128 & e.flags) !== 0) for (e = t.child; e !== null;) { if ((u = uo(e)) !== null) { for (t.flags |= 128, Ws(o, !1), (n = u.updateQueue) !== null && (t.updateQueue = n, t.flags |= 4), t.subtreeFlags = 0, n = r, r = t.child; r !== null;)e = n, (o = r).flags &= 14680066, (u = o.alternate) === null ? (o.childLanes = 0, o.lanes = e, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = u.childLanes, o.lanes = u.lanes, o.child = u.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = u.memoizedProps, o.memoizedState = u.memoizedState, o.updateQueue = u.updateQueue, o.type = u.type, e = u.dependencies, o.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), r = r.sibling; return Ei(so, 1 & so.current | 2), t.child; }e = e.sibling; }o.tail !== null && Ke() > Yu && (t.flags |= 128, n = !0, Ws(o, !1), t.lanes = 4194304); } else { if (!n) if ((e = uo(u)) !== null) { if (t.flags |= 128, n = !0, (r = e.updateQueue) !== null && (t.updateQueue = r, t.flags |= 4), Ws(o, !0), o.tail === null && o.tailMode === 'hidden' && !u.alternate && !ia) return Xs(t), null; } else 2 * Ke() - o.renderingStartTime > Yu && r !== 1073741824 && (t.flags |= 128, n = !0, Ws(o, !1), t.lanes = 4194304); o.isBackwards ? (u.sibling = t.child, t.child = u) : ((r = o.last) !== null ? r.sibling = u : t.child = u, o.last = u); } return o.tail !== null ? (t = o.tail, o.rendering = t, o.tail = t.sibling, o.renderingStartTime = Ke(), t.sibling = null, r = so.current, Ei(so, n ? 1 & r | 2 : 1 & r), t) : (Xs(t), null); case 22: case 23: return fl(), n = t.memoizedState !== null, e !== null && e.memoizedState !== null !== n && (t.flags |= 8192), n && (1 & t.mode) !== 0 ? (1073741824 & Ou) !== 0 && (Xs(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Xs(t), null; case 24: case 25: return null; } throw Error(a(156, t.tag)); } function $s(e, t) { switch (ta(t), t.tag) { case 1: return Ii(t.type) && Oi(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 3: return io(), Mi(Ai), Mi(Pi), co(), (65536 & (e = t.flags)) !== 0 && (128 & e) === 0 ? (t.flags = -65537 & e | 128, t) : null; case 5: return oo(t), null; case 13: if (Mi(so), (e = t.memoizedState) !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(a(340)); da(); } return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 19: return Mi(so), null; case 4: return io(), null; case 10: return xa(t.type._context), null; case 22: case 23: return fl(), null; default: return null; } }Is = function (e, t) { for (let r = t.child; r !== null;) { if (r.tag === 5 || r.tag === 6)e.appendChild(r.stateNode); else if (r.tag !== 4 && r.child !== null) { r.child.return = r, r = r.child; continue; } if (r === t) break; for (;r.sibling === null;) { if (r.return === null || r.return === t) return; r = r.return; }r.sibling.return = r.return, r = r.sibling; } }, Os = function () {}, Ds = function (e, t, r, n) { let i = e.memoizedProps; if (i !== n) { e = t.stateNode, ro(Ja.current); let a; let o = null; switch (r) { case 'input': i = $(e, i), n = $(e, n), o = []; break; case 'select': i = { ...i, value: void 0 }, n = { ...n, value: void 0 }, o = []; break; case 'textarea': i = ne(e, i), n = ne(e, n), o = []; break; default: typeof i.onClick !== 'function' && typeof n.onClick === 'function' && (e.onclick = Jn); } for (c in ye(r, n), r = null, i) if (!n.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null) if (c === 'style') { var u = i[c]; for (a in u)u.hasOwnProperty(a) && (r || (r = {}), r[a] = ''); } else c !== 'dangerouslySetInnerHTML' && c !== 'children' && c !== 'suppressContentEditableWarning' && c !== 'suppressHydrationWarning' && c !== 'autoFocus' && (s.hasOwnProperty(c) ? o || (o = []) : (o = o || []).push(c, null)); for (c in n) { let l = n[c]; if (u = i != null ? i[c] : void 0, n.hasOwnProperty(c) && l !== u && (l != null || u != null)) if (c === 'style') if (u) { for (a in u)!u.hasOwnProperty(a) || l && l.hasOwnProperty(a) || (r || (r = {}), r[a] = ''); for (a in l)l.hasOwnProperty(a) && u[a] !== l[a] && (r || (r = {}), r[a] = l[a]); } else r || (o || (o = []), o.push(c, r)), r = l; else c === 'dangerouslySetInnerHTML' ? (l = l ? l.__html : void 0, u = u ? u.__html : void 0, l != null && u !== l && (o = o || []).push(c, l)) : c === 'children' ? typeof l !== 'string' && typeof l !== 'number' || (o = o || []).push(c, `${l}`) : c !== 'suppressContentEditableWarning' && c !== 'suppressHydrationWarning' && (s.hasOwnProperty(c) ? (l != null && c === 'onScroll' && Fn('scroll', e), o || u === l || (o = [])) : (o = o || []).push(c, l)); }r && (o = o || []).push('style', r); var c = o; (t.updateQueue = c) && (t.flags |= 4); } }, zs = function (e, t, r, n) { r !== n && (t.flags |= 4); }; let Zs = !1; let Ks = !1; const Qs = typeof WeakSet === 'function' ? WeakSet : Set; let Js = null; function eu(e, t) { const r = e.ref; if (r !== null) if (typeof r === 'function') try { r(null); } catch (n) { Ml(e, t, n); } else r.current = null; } function tu(e, t, r) { try { r(); } catch (n) { Ml(e, t, n); } } let ru = !1; function nu(e, t, r) { let n = t.updateQueue; if ((n = n !== null ? n.lastEffect : null) !== null) { let i = n = n.next; do { if ((i.tag & e) === e) { const a = i.destroy; i.destroy = void 0, void 0 !== a && tu(t, r, a); }i = i.next; } while (i !== n); } } function iu(e, t) { if ((t = (t = t.updateQueue) !== null ? t.lastEffect : null) !== null) { let r = t = t.next; do { if ((r.tag & e) === e) { const n = r.create; r.destroy = n(); }r = r.next; } while (r !== t); } } function au(e) { const t = e.ref; if (t !== null) { const r = e.stateNode; e.tag, e = r, typeof t === 'function' ? t(e) : t.current = e; } } function ou(e) { let t = e.alternate; t !== null && (e.alternate = null, ou(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && ((t = e.stateNode) !== null && (delete t[fi], delete t[di], delete t[mi], delete t[vi], delete t[gi])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null; } function su(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4; } function uu(e) { e:for (;;) { for (;e.sibling === null;) { if (e.return === null || su(e.return)) return null; e = e.return; } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (2 & e.flags) continue e; if (e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child; } if (!(2 & e.flags)) return e.stateNode; } } function lu(e, t, r) { const n = e.tag; if (n === 5 || n === 6)e = e.stateNode, t ? r.nodeType === 8 ? r.parentNode.insertBefore(e, t) : r.insertBefore(e, t) : (r.nodeType === 8 ? (t = r.parentNode).insertBefore(e, r) : (t = r).appendChild(e), (r = r._reactRootContainer) !== null && void 0 !== r || t.onclick !== null || (t.onclick = Jn)); else if (n !== 4 && (e = e.child) !== null) for (lu(e, t, r), e = e.sibling; e !== null;)lu(e, t, r), e = e.sibling; } function cu(e, t, r) { const n = e.tag; if (n === 5 || n === 6)e = e.stateNode, t ? r.insertBefore(e, t) : r.appendChild(e); else if (n !== 4 && (e = e.child) !== null) for (cu(e, t, r), e = e.sibling; e !== null;)cu(e, t, r), e = e.sibling; } let hu = null; let fu = !1; function du(e, t, r) { for (r = r.child; r !== null;)pu(e, t, r), r = r.sibling; } function pu(e, t, r) { if (at && typeof at.onCommitFiberUnmount === 'function') try { at.onCommitFiberUnmount(it, r); } catch (s) {} switch (r.tag) { case 5: Ks || eu(r, t); case 6: var n = hu; var i = fu; hu = null, du(e, t, r), fu = i, (hu = n) !== null && (fu ? (e = hu, r = r.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(r) : e.removeChild(r)) : hu.removeChild(r.stateNode)); break; case 18: hu !== null && (fu ? (e = hu, r = r.stateNode, e.nodeType === 8 ? ui(e.parentNode, r) : e.nodeType === 1 && ui(e, r), Vt(e)) : ui(hu, r.stateNode)); break; case 4: n = hu, i = fu, hu = r.stateNode.containerInfo, fu = !0, du(e, t, r), hu = n, fu = i; break; case 0: case 11: case 14: case 15: if (!Ks && ((n = r.updateQueue) !== null && (n = n.lastEffect) !== null)) { i = n = n.next; do { let a = i; const o = a.destroy; a = a.tag, void 0 !== o && ((2 & a) !== 0 || (4 & a) !== 0) && tu(r, t, o), i = i.next; } while (i !== n); }du(e, t, r); break; case 1: if (!Ks && (eu(r, t), typeof (n = r.stateNode).componentWillUnmount === 'function')) try { n.props = r.memoizedProps, n.state = r.memoizedState, n.componentWillUnmount(); } catch (s) { Ml(r, t, s); }du(e, t, r); break; case 21: du(e, t, r); break; case 22: 1 & r.mode ? (Ks = (n = Ks) || r.memoizedState !== null, du(e, t, r), Ks = n) : du(e, t, r); break; default: du(e, t, r); } } function mu(e) { const t = e.updateQueue; if (t !== null) { e.updateQueue = null; let r = e.stateNode; r === null && (r = e.stateNode = new Qs()), t.forEach(((t) => { const n = Al.bind(null, e, t); r.has(t) || (r.add(t), t.then(n, n)); })); } } function vu(e, t) { const r = t.deletions; if (r !== null) for (let n = 0; n < r.length; n++) { const i = r[n]; try { const o = e; const s = t; let u = s; e:for (;u !== null;) { switch (u.tag) { case 5: hu = u.stateNode, fu = !1; break e; case 3: case 4: hu = u.stateNode.containerInfo, fu = !0; break e; }u = u.return; } if (hu === null) throw Error(a(160)); pu(o, s, i), hu = null, fu = !1; const l = i.alternate; l !== null && (l.return = null), i.return = null; } catch (c) { Ml(i, t, c); } } if (12854 & t.subtreeFlags) for (t = t.child; t !== null;)gu(t, e), t = t.sibling; } function gu(e, t) { let r = e.alternate; let n = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (vu(t, e), yu(e), 4 & n) { try { nu(3, e, e.return), iu(3, e); } catch (v) { Ml(e, e.return, v); } try { nu(5, e, e.return); } catch (v) { Ml(e, e.return, v); } } break; case 1: vu(t, e), yu(e), 512 & n && r !== null && eu(r, r.return); break; case 5: if (vu(t, e), yu(e), 512 & n && r !== null && eu(r, r.return), 32 & e.flags) { var i = e.stateNode; try { fe(i, ''); } catch (v) { Ml(e, e.return, v); } } if (4 & n && (i = e.stateNode) != null) { var o = e.memoizedProps; var s = r !== null ? r.memoizedProps : o; var u = e.type; var l = e.updateQueue; if (e.updateQueue = null, l !== null) try { u === 'input' && o.type === 'radio' && o.name != null && K(i, o), be(u, s); var c = be(u, o); for (s = 0; s < l.length; s += 2) { var h = l[s]; var f = l[s + 1]; h === 'style' ? ve(i, f) : h === 'dangerouslySetInnerHTML' ? he(i, f) : h === 'children' ? fe(i, f) : b(i, h, f, c); } switch (u) { case 'input': Q(i, o); break; case 'textarea': ae(i, o); break; case 'select': var d = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!o.multiple; var p = o.value; p != null ? re(i, !!o.multiple, p, !1) : d !== !!o.multiple && (o.defaultValue != null ? re(i, !!o.multiple, o.defaultValue, !0) : re(i, !!o.multiple, o.multiple ? [] : '', !1)); }i[di] = o; } catch (v) { Ml(e, e.return, v); } } break; case 6: if (vu(t, e), yu(e), 4 & n) { if (e.stateNode === null) throw Error(a(162)); i = e.stateNode, o = e.memoizedProps; try { i.nodeValue = o; } catch (v) { Ml(e, e.return, v); } } break; case 3: if (vu(t, e), yu(e), 4 & n && r !== null && r.memoizedState.isDehydrated) try { Vt(t.containerInfo); } catch (v) { Ml(e, e.return, v); } break; case 4: default: vu(t, e), yu(e); break; case 13: vu(t, e), yu(e), 8192 & (i = e.child).flags && (o = i.memoizedState !== null, i.stateNode.isHidden = o, !o || i.alternate !== null && i.alternate.memoizedState !== null || (Vu = Ke())), 4 & n && mu(e); break; case 22: if (h = r !== null && r.memoizedState !== null, 1 & e.mode ? (Ks = (c = Ks) || h, vu(t, e), Ks = c) : vu(t, e), yu(e), 8192 & n) { if (c = e.memoizedState !== null, (e.stateNode.isHidden = c) && !h && (1 & e.mode) !== 0) for (Js = e, h = e.child; h !== null;) { for (f = Js = h; Js !== null;) { switch (p = (d = Js).child, d.tag) { case 0: case 11: case 14: case 15: nu(4, d, d.return); break; case 1: eu(d, d.return); var m = d.stateNode; if (typeof m.componentWillUnmount === 'function') { n = d, r = d.return; try { t = n, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount(); } catch (v) { Ml(n, r, v); } } break; case 5: eu(d, d.return); break; case 22: if (d.memoizedState !== null) { xu(f); continue; } }p !== null ? (p.return = d, Js = p) : xu(f); }h = h.sibling; }e:for (h = null, f = e; ;) { if (f.tag === 5) { if (h === null) { h = f; try { i = f.stateNode, c ? typeof (o = i.style).setProperty === 'function' ? o.setProperty('display', 'none', 'important') : o.display = 'none' : (u = f.stateNode, s = void 0 !== (l = f.memoizedProps.style) && l !== null && l.hasOwnProperty('display') ? l.display : null, u.style.display = me('display', s)); } catch (v) { Ml(e, e.return, v); } } } else if (f.tag === 6) { if (h === null) try { f.stateNode.nodeValue = c ? '' : f.memoizedProps; } catch (v) { Ml(e, e.return, v); } } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === e) && f.child !== null) { f.child.return = f, f = f.child; continue; } if (f === e) break; for (;f.sibling === null;) { if (f.return === null || f.return === e) break e; h === f && (h = null), f = f.return; }h === f && (h = null), f.sibling.return = f.return, f = f.sibling; } } break; case 19: vu(t, e), yu(e), 4 & n && mu(e); case 21: } } function yu(e) { const t = e.flags; if (2 & t) { try { e: { for (let r = e.return; r !== null;) { if (su(r)) { var n = r; break e; }r = r.return; } throw Error(a(160)); } switch (n.tag) { case 5: var i = n.stateNode; 32 & n.flags && (fe(i, ''), n.flags &= -33), cu(e, uu(e), i); break; case 3: case 4: var o = n.stateNode.containerInfo; lu(e, uu(e), o); break; default: throw Error(a(161)); } } catch (s) { Ml(e, e.return, s); }e.flags &= -3; }4096 & t && (e.flags &= -4097); } function bu(e, t, r) { Js = e, wu(e, t, r); } function wu(e, t, r) { for (let n = (1 & e.mode) !== 0; Js !== null;) { const i = Js; let a = i.child; if (i.tag === 22 && n) { let o = i.memoizedState !== null || Zs; if (!o) { let s = i.alternate; let u = s !== null && s.memoizedState !== null || Ks; s = Zs; const l = Ks; if (Zs = o, (Ks = u) && !l) for (Js = i; Js !== null;)u = (o = Js).child, o.tag === 22 && o.memoizedState !== null ? _u(i) : u !== null ? (u.return = o, Js = u) : _u(i); for (;a !== null;)Js = a, wu(a, t, r), a = a.sibling; Js = i, Zs = s, Ks = l; }ku(e); } else (8772 & i.subtreeFlags) !== 0 && a !== null ? (a.return = i, Js = a) : ku(e); } } function ku(e) { for (;Js !== null;) { const t = Js; if ((8772 & t.flags) !== 0) { var r = t.alternate; try { if ((8772 & t.flags) !== 0) switch (t.tag) { case 0: case 11: case 15: Ks || iu(5, t); break; case 1: var n = t.stateNode; if (4 & t.flags && !Ks) if (r === null)n.componentDidMount(); else { const i = t.elementType === t.type ? r.memoizedProps : va(t.type, r.memoizedProps); n.componentDidUpdate(i, r.memoizedState, n.__reactInternalSnapshotBeforeUpdate); } var o = t.updateQueue; o !== null && ja(t, o, n); break; case 3: var s = t.updateQueue; if (s !== null) { if (r = null, t.child !== null) switch (t.child.tag) { case 5: case 1: r = t.child.stateNode; }ja(t, s, r); } break; case 5: var u = t.stateNode; if (r === null && 4 & t.flags) { r = u; const l = t.memoizedProps; switch (t.type) { case 'button': case 'input': case 'select': case 'textarea': l.autoFocus && r.focus(); break; case 'img': l.src && (r.src = l.src); } } break; case 6: case 4: case 12: case 19: case 17: case 21: case 22: case 23: case 25: break; case 13: if (t.memoizedState === null) { const c = t.alternate; if (c !== null) { const h = c.memoizedState; if (h !== null) { const f = h.dehydrated; f !== null && Vt(f); } } } break; default: throw Error(a(163)); }Ks || 512 & t.flags && au(t); } catch (d) { Ml(t, t.return, d); } } if (t === e) { Js = null; break; } if ((r = t.sibling) !== null) { r.return = t.return, Js = r; break; }Js = t.return; } } function xu(e) { for (;Js !== null;) { const t = Js; if (t === e) { Js = null; break; } const r = t.sibling; if (r !== null) { r.return = t.return, Js = r; break; }Js = t.return; } } function _u(e) { for (;Js !== null;) { const t = Js; try { switch (t.tag) { case 0: case 11: case 15: var r = t.return; try { iu(4, t); } catch (u) { Ml(t, r, u); } break; case 1: var n = t.stateNode; if (typeof n.componentDidMount === 'function') { const i = t.return; try { n.componentDidMount(); } catch (u) { Ml(t, i, u); } } var a = t.return; try { au(t); } catch (u) { Ml(t, a, u); } break; case 5: var o = t.return; try { au(t); } catch (u) { Ml(t, o, u); } } } catch (u) { Ml(t, t.return, u); } if (t === e) { Js = null; break; } const s = t.sibling; if (s !== null) { s.return = t.return, Js = s; break; }Js = t.return; } } let Su; const Mu = Math.ceil; const Eu = w.ReactCurrentDispatcher; const Cu = w.ReactCurrentOwner; const Pu = w.ReactCurrentBatchConfig; var Au = 0; var Tu = null; let Ru = null; let Iu = 0; var Ou = 0; var Du = Si(0); var zu = 0; let Nu = null; var Lu = 0; let ju = 0; let Fu = 0; let Bu = null; let Uu = null; var Vu = 0; var Yu = 1 / 0; let Hu = null; var qu = !1; var Wu = null; var Xu = null; let Gu = !1; let $u = null; let Zu = 0; let Ku = 0; let Qu = null; let Ju = -1; let el = 0; function tl() { return (6 & Au) !== 0 ? Ke() : Ju !== -1 ? Ju : Ju = Ke(); } function rl(e) { return (1 & e.mode) === 0 ? 1 : (2 & Au) !== 0 && Iu !== 0 ? Iu & -Iu : ma.transition !== null ? (el === 0 && (el = mt()), el) : (e = bt) !== 0 ? e : e = void 0 === (e = window.event) ? 16 : Zt(e.type); } function nl(e, t, r, n) { if (Ku > 50) throw Ku = 0, Qu = null, Error(a(185)); gt(e, r, n), (2 & Au) !== 0 && e === Tu || (e === Tu && ((2 & Au) === 0 && (ju |= r), zu === 4 && ul(e, Iu)), il(e, n), r === 1 && Au === 0 && (1 & t.mode) === 0 && (Yu = Ke() + 500, Fi && Vi())); } function il(e, t) { let r = e.callbackNode; !(function (e, t) { for (let r = e.suspendedLanes, n = e.pingedLanes, i = e.expirationTimes, a = e.pendingLanes; a > 0;) { const o = 31 - ot(a); const s = 1 << o; const u = i[o]; u === -1 ? (s & r) !== 0 && (s & n) === 0 || (i[o] = dt(s, t)) : u <= t && (e.expiredLanes |= s), a &= ~s; } }(e, t)); const n = ft(e, e === Tu ? Iu : 0); if (n === 0)r !== null && Ge(r), e.callbackNode = null, e.callbackPriority = 0; else if (t = n & -n, e.callbackPriority !== t) { if (r != null && Ge(r), t === 1)e.tag === 0 ? (function (e) { Fi = !0, Ui(e); }(ll.bind(null, e))) : Ui(ll.bind(null, e)), oi((() => { (6 & Au) === 0 && Vi(); })), r = null; else { switch (wt(n)) { case 1: r = Je; break; case 4: r = et; break; case 16: default: r = tt; break; case 536870912: r = nt; }r = Tl(r, al.bind(null, e)); }e.callbackPriority = t, e.callbackNode = r; } } function al(e, t) { if (Ju = -1, el = 0, (6 & Au) !== 0) throw Error(a(327)); let r = e.callbackNode; if (_l() && e.callbackNode !== r) return null; let n = ft(e, e === Tu ? Iu : 0); if (n === 0) return null; if ((30 & n) !== 0 || (n & e.expiredLanes) !== 0 || t)t = gl(e, n); else { t = n; var i = Au; Au |= 2; var o = ml(); for (Tu === e && Iu === t || (Hu = null, Yu = Ke() + 500, dl(e, t)); ;) try { bl(); break; } catch (u) { pl(e, u); }ka(), Eu.current = o, Au = i, Ru !== null ? t = 0 : (Tu = null, Iu = 0, t = zu); } if (t !== 0) { if (t === 2 && ((i = pt(e)) !== 0 && (n = i, t = ol(e, i))), t === 1) throw r = Nu, dl(e, 0), ul(e, n), il(e, Ke()), r; if (t === 6)ul(e, n); else { if (i = e.current.alternate, (30 & n) === 0 && !(function (e) { for (let t = e; ;) { if (16384 & t.flags) { var r = t.updateQueue; if (r !== null && (r = r.stores) !== null) for (let n = 0; n < r.length; n++) { let i = r[n]; const a = i.getSnapshot; i = i.value; try { if (!sn(a(), i)) return !1; } catch (s) { return !1; } } } if (r = t.child, 16384 & t.subtreeFlags && r !== null)r.return = t, t = r; else { if (t === e) break; for (;t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return; }t.sibling.return = t.return, t = t.sibling; } } return !0; }(i)) && ((t = gl(e, n)) === 2 && ((o = pt(e)) !== 0 && (n = o, t = ol(e, o))), t === 1)) throw r = Nu, dl(e, 0), ul(e, n), il(e, Ke()), r; switch (e.finishedWork = i, e.finishedLanes = n, t) { case 0: case 1: throw Error(a(345)); case 2: case 5: xl(e, Uu, Hu); break; case 3: if (ul(e, n), (130023424 & n) === n && (t = Vu + 500 - Ke()) > 10) { if (ft(e, 0) !== 0) break; if (((i = e.suspendedLanes) & n) !== n) { tl(), e.pingedLanes |= e.suspendedLanes & i; break; }e.timeoutHandle = ni(xl.bind(null, e, Uu, Hu), t); break; }xl(e, Uu, Hu); break; case 4: if (ul(e, n), (4194240 & n) === n) break; for (t = e.eventTimes, i = -1; n > 0;) { let s = 31 - ot(n); o = 1 << s, (s = t[s]) > i && (i = s), n &= ~o; } if (n = i, (n = ((n = Ke() - n) < 120 ? 120 : n < 480 ? 480 : n < 1080 ? 1080 : n < 1920 ? 1920 : n < 3e3 ? 3e3 : n < 4320 ? 4320 : 1960 * Mu(n / 1960)) - n) > 10) { e.timeoutHandle = ni(xl.bind(null, e, Uu, Hu), n); break; }xl(e, Uu, Hu); break; default: throw Error(a(329)); } } } return il(e, Ke()), e.callbackNode === r ? al.bind(null, e) : null; } function ol(e, t) { const r = Bu; return e.current.memoizedState.isDehydrated && (dl(e, t).flags |= 256), (e = gl(e, t)) !== 2 && (t = Uu, Uu = r, t !== null && sl(t)), e; } function sl(e) { Uu === null ? Uu = e : Uu.push.apply(Uu, e); } function ul(e, t) { for (t &= ~Fu, t &= ~ju, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; t > 0;) { const r = 31 - ot(t); const n = 1 << r; e[r] = -1, t &= ~n; } } function ll(e) { if ((6 & Au) !== 0) throw Error(a(327)); _l(); let t = ft(e, 0); if ((1 & t) === 0) return il(e, Ke()), null; let r = gl(e, t); if (e.tag !== 0 && r === 2) { const n = pt(e); n !== 0 && (t = n, r = ol(e, n)); } if (r === 1) throw r = Nu, dl(e, 0), ul(e, t), il(e, Ke()), r; if (r === 6) throw Error(a(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, xl(e, Uu, Hu), il(e, Ke()), null; } function cl(e, t) { const r = Au; Au |= 1; try { return e(t); } finally { (Au = r) === 0 && (Yu = Ke() + 500, Fi && Vi()); } } function hl(e) { $u !== null && $u.tag === 0 && (6 & Au) === 0 && _l(); const t = Au; Au |= 1; const r = Pu.transition; const n = bt; try { if (Pu.transition = null, bt = 1, e) return e(); } finally { bt = n, Pu.transition = r, (6 & (Au = t)) === 0 && Vi(); } } function fl() { Ou = Du.current, Mi(Du); } function dl(e, t) { e.finishedWork = null, e.finishedLanes = 0; let r = e.timeoutHandle; if (r !== -1 && (e.timeoutHandle = -1, ii(r)), Ru !== null) for (r = Ru.return; r !== null;) { var n = r; switch (ta(n), n.tag) { case 1: (n = n.type.childContextTypes) !== null && void 0 !== n && Oi(); break; case 3: io(), Mi(Ai), Mi(Pi), co(); break; case 5: oo(n); break; case 4: io(); break; case 13: case 19: Mi(so); break; case 10: xa(n.type._context); break; case 22: case 23: fl(); }r = r.return; } if (Tu = e, Ru = e = Dl(e.current, null), Iu = Ou = t, zu = 0, Nu = null, Fu = ju = Lu = 0, Uu = Bu = null, Ea !== null) { for (t = 0; t < Ea.length; t++) if ((n = (r = Ea[t]).interleaved) !== null) { r.interleaved = null; const i = n.next; const a = r.pending; if (a !== null) { const o = a.next; a.next = i, n.next = o; }r.pending = n; }Ea = null; } return e; } function pl(e, t) { for (;;) { let r = Ru; try { if (ka(), ho.current = os, yo) { for (let n = mo.memoizedState; n !== null;) { const i = n.queue; i !== null && (i.pending = null), n = n.next; }yo = !1; } if (po = 0, go = vo = mo = null, bo = !1, wo = 0, Cu.current = null, r === null || r.return === null) { zu = 1, Nu = t, Ru = null; break; }e: { let o = e; const s = r.return; let u = r; let l = t; if (t = Iu, u.flags |= 32768, l !== null && typeof l === 'object' && typeof l.then === 'function') { const c = l; const h = u; const f = h.tag; if ((1 & h.mode) === 0 && (f === 0 || f === 11 || f === 15)) { const d = h.alternate; d ? (h.updateQueue = d.updateQueue, h.memoizedState = d.memoizedState, h.lanes = d.lanes) : (h.updateQueue = null, h.memoizedState = null); } const p = gs(s); if (p !== null) { p.flags &= -257, ys(p, s, u, 0, t), 1 & p.mode && vs(o, c, t), l = c; const m = (t = p).updateQueue; if (m === null) { const v = new Set(); v.add(l), t.updateQueue = v; } else m.add(l); break e; } if ((1 & t) === 0) { vs(o, c, t), vl(); break e; }l = Error(a(426)); } else if (ia && 1 & u.mode) { const g = gs(s); if (g !== null) { (65536 & g.flags) === 0 && (g.flags |= 256), ys(g, s, u, 0, t), pa(cs(l, u)); break e; } }o = l = cs(l, u), zu !== 4 && (zu = 2), Bu === null ? Bu = [o] : Bu.push(o), o = s; do { switch (o.tag) { case 3: o.flags |= 65536, t &= -t, o.lanes |= t, Na(o, ps(0, l, t)); break e; case 1: u = l; var y = o.type; var b = o.stateNode; if ((128 & o.flags) === 0 && (typeof y.getDerivedStateFromError === 'function' || b !== null && typeof b.componentDidCatch === 'function' && (Xu === null || !Xu.has(b)))) { o.flags |= 65536, t &= -t, o.lanes |= t, Na(o, ms(o, u, t)); break e; } }o = o.return; } while (o !== null); }kl(r); } catch (w) { t = w, Ru === r && r !== null && (Ru = r = r.return); continue; } break; } } function ml() { const e = Eu.current; return Eu.current = os, e === null ? os : e; } function vl() { zu !== 0 && zu !== 3 && zu !== 2 || (zu = 4), Tu === null || (268435455 & Lu) === 0 && (268435455 & ju) === 0 || ul(Tu, Iu); } function gl(e, t) { const r = Au; Au |= 2; const n = ml(); for (Tu === e && Iu === t || (Hu = null, dl(e, t)); ;) try { yl(); break; } catch (i) { pl(e, i); } if (ka(), Au = r, Eu.current = n, Ru !== null) throw Error(a(261)); return Tu = null, Iu = 0, zu; } function yl() { for (;Ru !== null;)wl(Ru); } function bl() { for (;Ru !== null && !$e();)wl(Ru); } function wl(e) { const t = Su(e.alternate, e, Ou); e.memoizedProps = e.pendingProps, t === null ? kl(e) : Ru = t, Cu.current = null; } function kl(e) { let t = e; do { let r = t.alternate; if (e = t.return, (32768 & t.flags) === 0) { if ((r = Gs(r, t, Ou)) !== null) return void (Ru = r); } else { if ((r = $s(r, t)) !== null) return r.flags &= 32767, void (Ru = r); if (e === null) return zu = 6, void (Ru = null); e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; } if ((t = t.sibling) !== null) return void (Ru = t); Ru = t = e; } while (t !== null); zu === 0 && (zu = 5); } function xl(e, t, r) { const n = bt; const i = Pu.transition; try { Pu.transition = null, bt = 1, (function (e, t, r, n) { do { _l(); } while ($u !== null); if ((6 & Au) !== 0) throw Error(a(327)); r = e.finishedWork; let i = e.finishedLanes; if (r === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, r === e.current) throw Error(a(177)); e.callbackNode = null, e.callbackPriority = 0; let o = r.lanes | r.childLanes; if ((function (e, t) { let r = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; const n = e.eventTimes; for (e = e.expirationTimes; r > 0;) { const i = 31 - ot(r); const a = 1 << i; t[i] = 0, n[i] = -1, e[i] = -1, r &= ~a; } }(e, o)), e === Tu && (Ru = Tu = null, Iu = 0), (2064 & r.subtreeFlags) === 0 && (2064 & r.flags) === 0 || Gu || (Gu = !0, Tl(tt, (() => (_l(), null)))), o = (15990 & r.flags) !== 0, (15990 & r.subtreeFlags) !== 0 || o) { o = Pu.transition, Pu.transition = null; const s = bt; bt = 1; const u = Au; Au |= 4, Cu.current = null, (function (e, t) { if (ei = Ht, dn(e = fn())) { if ('selectionStart' in e) var r = { start: e.selectionStart, end: e.selectionEnd }; else e: { let n = (r = (r = e.ownerDocument) && r.defaultView || window).getSelection && r.getSelection(); if (n && n.rangeCount !== 0) { r = n.anchorNode; const i = n.anchorOffset; const o = n.focusNode; n = n.focusOffset; try { r.nodeType, o.nodeType; } catch (k) { r = null; break e; } let s = 0; let u = -1; let l = -1; let c = 0; let h = 0; let f = e; let d = null; t:for (;;) { for (var p; f !== r || i !== 0 && f.nodeType !== 3 || (u = s + i), f !== o || n !== 0 && f.nodeType !== 3 || (l = s + n), f.nodeType === 3 && (s += f.nodeValue.length), (p = f.firstChild) !== null;)d = f, f = p; for (;;) { if (f === e) break t; if (d === r && ++c === i && (u = s), d === o && ++h === n && (l = s), (p = f.nextSibling) !== null) break; d = (f = d).parentNode; }f = p; }r = u === -1 || l === -1 ? null : { start: u, end: l }; } else r = null; }r = r || { start: 0, end: 0 }; } else r = null; for (ti = { focusedElem: e, selectionRange: r }, Ht = !1, Js = t; Js !== null;) if (e = (t = Js).child, (1028 & t.subtreeFlags) !== 0 && e !== null)e.return = t, Js = e; else for (;Js !== null;) { t = Js; try { var m = t.alternate; if ((1024 & t.flags) !== 0) switch (t.tag) { case 0: case 11: case 15: case 5: case 6: case 4: case 17: break; case 1: if (m !== null) { const v = m.memoizedProps; const g = m.memoizedState; const y = t.stateNode; const b = y.getSnapshotBeforeUpdate(t.elementType === t.type ? v : va(t.type, v), g); y.__reactInternalSnapshotBeforeUpdate = b; } break; case 3: var w = t.stateNode.containerInfo; w.nodeType === 1 ? w.textContent = '' : w.nodeType === 9 && w.documentElement && w.removeChild(w.documentElement); break; default: throw Error(a(163)); } } catch (k) { Ml(t, t.return, k); } if ((e = t.sibling) !== null) { e.return = t.return, Js = e; break; }Js = t.return; }m = ru, ru = !1; }(e, r)), gu(r, e), pn(ti), Ht = !!ei, ti = ei = null, e.current = r, bu(r, e, i), Ze(), Au = u, bt = s, Pu.transition = o; } else e.current = r; if (Gu && (Gu = !1, $u = e, Zu = i), o = e.pendingLanes, o === 0 && (Xu = null), (function (e) { if (at && typeof at.onCommitFiberRoot === 'function') try { at.onCommitFiberRoot(it, e, void 0, (128 & e.current.flags) === 128); } catch (t) {} }(r.stateNode)), il(e, Ke()), t !== null) for (n = e.onRecoverableError, r = 0; r < t.length; r++)i = t[r], n(i.value, { componentStack: i.stack, digest: i.digest }); if (qu) throw qu = !1, e = Wu, Wu = null, e; (1 & Zu) !== 0 && e.tag !== 0 && _l(), o = e.pendingLanes, (1 & o) !== 0 ? e === Qu ? Ku++ : (Ku = 0, Qu = e) : Ku = 0, Vi(); }(e, t, r, n)); } finally { Pu.transition = i, bt = n; } return null; } function _l() { if ($u !== null) { let e = wt(Zu); const t = Pu.transition; const r = bt; try { if (Pu.transition = null, bt = e < 16 ? 16 : e, $u === null) var n = !1; else { if (e = $u, $u = null, Zu = 0, (6 & Au) !== 0) throw Error(a(331)); const i = Au; for (Au |= 4, Js = e.current; Js !== null;) { let o = Js; var s = o.child; if ((16 & Js.flags) !== 0) { var u = o.deletions; if (u !== null) { for (let l = 0; l < u.length; l++) { const c = u[l]; for (Js = c; Js !== null;) { let h = Js; switch (h.tag) { case 0: case 11: case 15: nu(8, h, o); } const f = h.child; if (f !== null)f.return = h, Js = f; else for (;Js !== null;) { const d = (h = Js).sibling; const p = h.return; if (ou(h), h === c) { Js = null; break; } if (d !== null) { d.return = p, Js = d; break; }Js = p; } } } const m = o.alternate; if (m !== null) { let v = m.child; if (v !== null) { m.child = null; do { const g = v.sibling; v.sibling = null, v = g; } while (v !== null); } }Js = o; } } if ((2064 & o.subtreeFlags) !== 0 && s !== null)s.return = o, Js = s; else for (;Js !== null;) { if ((2048 & (o = Js).flags) !== 0) switch (o.tag) { case 0: case 11: case 15: nu(9, o, o.return); } const y = o.sibling; if (y !== null) { y.return = o.return, Js = y; break; }Js = o.return; } } const b = e.current; for (Js = b; Js !== null;) { const w = (s = Js).child; if ((2064 & s.subtreeFlags) !== 0 && w !== null)w.return = s, Js = w; else for (s = b; Js !== null;) { if ((2048 & (u = Js).flags) !== 0) try { switch (u.tag) { case 0: case 11: case 15: iu(9, u); } } catch (x) { Ml(u, u.return, x); } if (u === s) { Js = null; break; } const k = u.sibling; if (k !== null) { k.return = u.return, Js = k; break; }Js = u.return; } } if (Au = i, Vi(), at && typeof at.onPostCommitFiberRoot === 'function') try { at.onPostCommitFiberRoot(it, e); } catch (x) {}n = !0; } return n; } finally { bt = r, Pu.transition = t; } } return !1; } function Sl(e, t, r) { e = Da(e, t = ps(0, t = cs(r, t), 1), 1), t = tl(), e !== null && (gt(e, 1, t), il(e, t)); } function Ml(e, t, r) { if (e.tag === 3)Sl(e, e, r); else for (;t !== null;) { if (t.tag === 3) { Sl(t, e, r); break; } if (t.tag === 1) { const n = t.stateNode; if (typeof t.type.getDerivedStateFromError === 'function' || typeof n.componentDidCatch === 'function' && (Xu === null || !Xu.has(n))) { t = Da(t, e = ms(t, e = cs(r, e), 1), 1), e = tl(), t !== null && (gt(t, 1, e), il(t, e)); break; } }t = t.return; } } function El(e, t, r) { const n = e.pingCache; n !== null && n.delete(t), t = tl(), e.pingedLanes |= e.suspendedLanes & r, Tu === e && (Iu & r) === r && (zu === 4 || zu === 3 && (130023424 & Iu) === Iu && Ke() - Vu < 500 ? dl(e, 0) : Fu |= r), il(e, t); } function Cl(e, t) { t === 0 && ((1 & e.mode) === 0 ? t = 1 : (t = ct, (130023424 & (ct <<= 1)) === 0 && (ct = 4194304))); const r = tl(); (e = Aa(e, t)) !== null && (gt(e, t, r), il(e, r)); } function Pl(e) { const t = e.memoizedState; let r = 0; t !== null && (r = t.retryLane), Cl(e, r); } function Al(e, t) { let r = 0; switch (e.tag) { case 13: var n = e.stateNode; var i = e.memoizedState; i !== null && (r = i.retryLane); break; case 19: n = e.stateNode; break; default: throw Error(a(314)); }n !== null && n.delete(t), Cl(e, r); } function Tl(e, t) { return Xe(e, t); } function Rl(e, t, r, n) { this.tag = e, this.key = r, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = n, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null; } function Il(e, t, r, n) { return new Rl(e, t, r, n); } function Ol(e) { return !(!(e = e.prototype) || !e.isReactComponent); } function Dl(e, t) { let r = e.alternate; return r === null ? ((r = Il(e.tag, t, e.key, e.mode)).elementType = e.elementType, r.type = e.type, r.stateNode = e.stateNode, r.alternate = e, e.alternate = r) : (r.pendingProps = t, r.type = e.type, r.flags = 0, r.subtreeFlags = 0, r.deletions = null), r.flags = 14680064 & e.flags, r.childLanes = e.childLanes, r.lanes = e.lanes, r.child = e.child, r.memoizedProps = e.memoizedProps, r.memoizedState = e.memoizedState, r.updateQueue = e.updateQueue, t = e.dependencies, r.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, r.sibling = e.sibling, r.index = e.index, r.ref = e.ref, r; } function zl(e, t, r, n, i, o) { let s = 2; if (n = e, typeof e === 'function')Ol(e) && (s = 1); else if (typeof e === 'string')s = 5; else e:switch (e) { case _: return Nl(r.children, i, o, t); case S: s = 8, i |= 8; break; case M: return (e = Il(12, r, t, 2 | i)).elementType = M, e.lanes = o, e; case A: return (e = Il(13, r, t, i)).elementType = A, e.lanes = o, e; case T: return (e = Il(19, r, t, i)).elementType = T, e.lanes = o, e; case O: return Ll(r, i, o, t); default: if (typeof e === 'object' && e !== null) switch (e.$$typeof) { case E: s = 10; break e; case C: s = 9; break e; case P: s = 11; break e; case R: s = 14; break e; case I: s = 16, n = null; break e; } throw Error(a(130, e == null ? e : typeof e, '')); } return (t = Il(s, r, t, i)).elementType = e, t.type = n, t.lanes = o, t; } function Nl(e, t, r, n) { return (e = Il(7, e, n, t)).lanes = r, e; } function Ll(e, t, r, n) { return (e = Il(22, e, n, t)).elementType = O, e.lanes = r, e.stateNode = { isHidden: !1 }, e; } function jl(e, t, r) { return (e = Il(6, e, null, t)).lanes = r, e; } function Fl(e, t, r) { return (t = Il(4, e.children !== null ? e.children : [], e.key, t)).lanes = r, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t; } function Bl(e, t, r, n, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = vt(0), this.expirationTimes = vt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = vt(0), this.identifierPrefix = n, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null; } function Ul(e, t, r, n, i, a, o, s, u) {
        return e = new Bl(e, t, r, s, u), t === 1 ? (t = 1, !0 === a && (t |= 8)) : t = 0, a = Il(3, null, null, t), e.current = a, a.stateNode = e, a.memoizedState = {
          element: n, isDehydrated: r, cache: null, transitions: null, pendingSuspenseBoundaries: null,
        }, Ra(a), e;
      } function Vl(e) { if (!e) return Ci; e: { if (Ve(e = e._reactInternals) !== e || e.tag !== 1) throw Error(a(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Ii(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e; } }t = t.return; } while (t !== null); throw Error(a(171)); } if (e.tag === 1) { const r = e.type; if (Ii(r)) return zi(e, r, t); } return t; } function Yl(e, t, r, n, i, a, o, s, u) { return (e = Ul(r, n, !0, e, 0, a, 0, s, u)).context = Vl(null), r = e.current, (a = Oa(n = tl(), i = rl(r))).callback = void 0 !== t && t !== null ? t : null, Da(r, a, i), e.current.lanes = i, gt(e, i, n), il(e, n), e; } function Hl(e, t, r, n) { const i = t.current; const a = tl(); const o = rl(i); return r = Vl(r), t.context === null ? t.context = r : t.pendingContext = r, (t = Oa(a, o)).payload = { element: e }, (n = void 0 === n ? null : n) !== null && (t.callback = n), (e = Da(i, t, o)) !== null && (nl(e, i, o, a), za(e, i, o)), o; } function ql(e) { return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null; } function Wl(e, t) { if ((e = e.memoizedState) !== null && e.dehydrated !== null) { const r = e.retryLane; e.retryLane = r !== 0 && r < t ? r : t; } } function Xl(e, t) { Wl(e, t), (e = e.alternate) && Wl(e, t); }Su = function (e, t, r) {
        if (e !== null) if (e.memoizedProps !== t.pendingProps || Ai.current)ws = !0; else { if ((e.lanes & r) === 0 && (128 & t.flags) === 0) return ws = !1, (function (e, t, r) { switch (t.tag) { case 3: Ts(t), da(); break; case 5: ao(t); break; case 1: Ii(t.type) && Ni(t); break; case 4: no(t, t.stateNode.containerInfo); break; case 10: var n = t.type._context; var i = t.memoizedProps.value; Ei(ga, n._currentValue), n._currentValue = i; break; case 13: if ((n = t.memoizedState) !== null) return n.dehydrated !== null ? (Ei(so, 1 & so.current), t.flags |= 128, null) : (r & t.child.childLanes) !== 0 ? js(e, t, r) : (Ei(so, 1 & so.current), (e = qs(e, t, r)) !== null ? e.sibling : null); Ei(so, 1 & so.current); break; case 19: if (n = (r & t.childLanes) !== 0, (128 & e.flags) !== 0) { if (n) return Ys(e, t, r); t.flags |= 128; } if ((i = t.memoizedState) !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), Ei(so, so.current), n) break; return null; case 22: case 23: return t.lanes = 0, Ms(e, t, r); } return qs(e, t, r); }(e, t, r)); ws = (131072 & e.flags) !== 0; } else ws = !1, ia && (1048576 & t.flags) !== 0 && Ji(t, Wi, t.index); switch (t.lanes = 0, t.tag) {
          case 2: var n = t.type; Hs(e, t), e = t.pendingProps; var i = Ri(t, Pi.current); Sa(t, r), i = So(null, t, n, e, i, r); var o = Mo(); return t.flags |= 1, typeof i === 'object' && i !== null && typeof i.render === 'function' && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Ii(n) ? (o = !0, Ni(t)) : o = !1, t.memoizedState = i.state !== null && void 0 !== i.state ? i.state : null, Ra(t), i.updater = Ua, t.stateNode = i, i._reactInternals = t, qa(t, n, e, r), t = As(null, t, n, !0, o, r)) : (t.tag = 0, ia && o && ea(t), ks(null, t, i, r), t = t.child), t; case 16: n = t.elementType; e: { switch (Hs(e, t), e = t.pendingProps, n = (i = n._init)(n._payload), t.type = n, i = t.tag = (function (e) { if (typeof e === 'function') return Ol(e) ? 1 : 0; if (void 0 !== e && e !== null) { if ((e = e.$$typeof) === P) return 11; if (e === R) return 14; } return 2; }(n)), e = va(n, e), i) { case 0: t = Cs(null, t, n, e, r); break e; case 1: t = Ps(null, t, n, e, r); break e; case 11: t = xs(null, t, n, e, r); break e; case 14: t = _s(null, t, n, va(n.type, e), r); break e; } throw Error(a(306, n, '')); } return t; case 0: return n = t.type, i = t.pendingProps, Cs(e, t, n, i = t.elementType === n ? i : va(n, i), r); case 1: return n = t.type, i = t.pendingProps, Ps(e, t, n, i = t.elementType === n ? i : va(n, i), r); case 3: e: {
            if (Ts(t), e === null) throw Error(a(387)); n = t.pendingProps, i = (o = t.memoizedState).element, Ia(e, t), La(t, n, null, r); var s = t.memoizedState; if (n = s.element, o.isDehydrated) {
              if (o = {
                element: n, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions,
              }, t.updateQueue.baseState = o, t.memoizedState = o, 256 & t.flags) { t = Rs(e, t, n, r, i = cs(Error(a(423)), t)); break e; } if (n !== i) { t = Rs(e, t, n, r, i = cs(Error(a(424)), t)); break e; } for (na = li(t.stateNode.containerInfo.firstChild), ra = t, ia = !0, aa = null, r = Ka(t, null, n, r), t.child = r; r;)r.flags = -3 & r.flags | 4096, r = r.sibling;
            } else { if (da(), n === i) { t = qs(e, t, r); break e; }ks(e, t, n, r); }t = t.child;
          } return t; case 5: return ao(t), e === null && la(t), n = t.type, i = t.pendingProps, o = e !== null ? e.memoizedProps : null, s = i.children, ri(n, i) ? s = null : o !== null && ri(n, o) && (t.flags |= 32), Es(e, t), ks(e, t, s, r), t.child; case 6: return e === null && la(t), null; case 13: return js(e, t, r); case 4: return no(t, t.stateNode.containerInfo), n = t.pendingProps, e === null ? t.child = Za(t, null, n, r) : ks(e, t, n, r), t.child; case 11: return n = t.type, i = t.pendingProps, xs(e, t, n, i = t.elementType === n ? i : va(n, i), r); case 7: return ks(e, t, t.pendingProps, r), t.child; case 8: case 12: return ks(e, t, t.pendingProps.children, r), t.child; case 10: e: { if (n = t.type._context, i = t.pendingProps, o = t.memoizedProps, s = i.value, Ei(ga, n._currentValue), n._currentValue = s, o !== null) if (sn(o.value, s)) { if (o.children === i.children && !Ai.current) { t = qs(e, t, r); break e; } } else for ((o = t.child) !== null && (o.return = t); o !== null;) { let u = o.dependencies; if (u !== null) { s = o.child; for (let l = u.firstContext; l !== null;) { if (l.context === n) { if (o.tag === 1) { (l = Oa(-1, r & -r)).tag = 2; let c = o.updateQueue; if (c !== null) { const h = (c = c.shared).pending; h === null ? l.next = l : (l.next = h.next, h.next = l), c.pending = l; } }o.lanes |= r, (l = o.alternate) !== null && (l.lanes |= r), _a(o.return, r, t), u.lanes |= r; break; }l = l.next; } } else if (o.tag === 10)s = o.type === t.type ? null : o.child; else if (o.tag === 18) { if ((s = o.return) === null) throw Error(a(341)); s.lanes |= r, (u = s.alternate) !== null && (u.lanes |= r), _a(s, r, t), s = o.sibling; } else s = o.child; if (s !== null)s.return = o; else for (s = o; s !== null;) { if (s === t) { s = null; break; } if ((o = s.sibling) !== null) { o.return = s.return, s = o; break; }s = s.return; }o = s; }ks(e, t, i.children, r), t = t.child; } return t; case 9: return i = t.type, n = t.pendingProps.children, Sa(t, r), n = n(i = Ma(i)), t.flags |= 1, ks(e, t, n, r), t.child; case 14: return i = va(n = t.type, t.pendingProps), _s(e, t, n, i = va(n.type, i), r); case 15: return Ss(e, t, t.type, t.pendingProps, r); case 17: return n = t.type, i = t.pendingProps, i = t.elementType === n ? i : va(n, i), Hs(e, t), t.tag = 1, Ii(n) ? (e = !0, Ni(t)) : e = !1, Sa(t, r), Ya(t, n, i), qa(t, n, i, r), As(null, t, n, !0, e, r); case 19: return Ys(e, t, r); case 22: return Ms(e, t, r);
        } throw Error(a(156, t.tag));
      }; const Gl = typeof reportError === 'function' ? reportError : function (e) { console.error(e); }; function $l(e) { this._internalRoot = e; } function Zl(e) { this._internalRoot = e; } function Kl(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11); } function Ql(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== ' react-mount-point-unstable ')); } function Jl() {} function ec(e, t, r, n, i) { const a = r._reactRootContainer; if (a) { var o = a; if (typeof i === 'function') { const s = i; i = function () { const e = ql(o); s.call(e); }; }Hl(t, o, e, i); } else o = (function (e, t, r, n, i) { if (i) { if (typeof n === 'function') { const a = n; n = function () { const e = ql(o); a.call(e); }; } var o = Yl(t, n, e, 0, null, !1, 0, '', Jl); return e._reactRootContainer = o, e[pi] = o.current, Vn(e.nodeType === 8 ? e.parentNode : e), hl(), o; } for (;i = e.lastChild;)e.removeChild(i); if (typeof n === 'function') { const s = n; n = function () { const e = ql(u); s.call(e); }; } var u = Ul(e, 0, !1, null, 0, !1, 0, '', Jl); return e._reactRootContainer = u, e[pi] = u.current, Vn(e.nodeType === 8 ? e.parentNode : e), hl((() => { Hl(t, u, r, n); })), u; }(r, t, e, i, n)); return ql(o); }Zl.prototype.render = $l.prototype.render = function (e) { const t = this._internalRoot; if (t === null) throw Error(a(409)); Hl(e, t, null, null); }, Zl.prototype.unmount = $l.prototype.unmount = function () { const e = this._internalRoot; if (e !== null) { this._internalRoot = null; const t = e.containerInfo; hl((() => { Hl(null, e, null, null); })), t[pi] = null; } }, Zl.prototype.unstable_scheduleHydration = function (e) { if (e) { const t = St(); e = { blockedOn: null, target: e, priority: t }; for (var r = 0; r < Ot.length && t !== 0 && t < Ot[r].priority; r++);Ot.splice(r, 0, e), r === 0 && Lt(e); } }, kt = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { const r = ht(t.pendingLanes); r !== 0 && (yt(t, 1 | r), il(t, Ke()), (6 & Au) === 0 && (Yu = Ke() + 500, Vi())); } break; case 13: hl((() => { const t = Aa(e, 1); if (t !== null) { const r = tl(); nl(t, e, 1, r); } })), Xl(e, 1); } }, xt = function (e) { if (e.tag === 13) { const t = Aa(e, 134217728); if (t !== null)nl(t, e, 134217728, tl()); Xl(e, 134217728); } }, _t = function (e) { if (e.tag === 13) { const t = rl(e); const r = Aa(e, t); if (r !== null)nl(r, e, t, tl()); Xl(e, t); } }, St = function () { return bt; }, Mt = function (e, t) { const r = bt; try { return bt = e, t(); } finally { bt = r; } }, xe = function (e, t, r) { switch (t) { case 'input': if (Q(e, r), t = r.name, r.type === 'radio' && t != null) { for (r = e; r.parentNode;)r = r.parentNode; for (r = r.querySelectorAll(`input[name=${JSON.stringify(`${t}`)}][type="radio"]`), t = 0; t < r.length; t++) { const n = r[t]; if (n !== e && n.form === e.form) { const i = ki(n); if (!i) throw Error(a(90)); X(n), Q(n, i); } } } break; case 'textarea': ae(e, r); break; case 'select': (t = r.value) != null && re(e, !!r.multiple, t, !1); } }, Pe = cl, Ae = hl; const tc = { usingClientEntryPoint: !1, Events: [bi, wi, ki, Ee, Ce, cl] }; const rc = {
        findFiberByHostInstance: yi, bundleType: 0, version: '18.2.0', rendererPackageName: 'react-dom',
      }; const nc = {
        bundleType: rc.bundleType, version: rc.version, rendererPackageName: rc.rendererPackageName, rendererConfig: rc.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: w.ReactCurrentDispatcher, findHostInstanceByFiber(e) { return (e = qe(e)) === null ? null : e.stateNode; }, findFiberByHostInstance: rc.findFiberByHostInstance || function () { return null; }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: '18.2.0-next-9e3b772b8-20220608',
      }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined') { const ic = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!ic.isDisabled && ic.supportsFiber) try { it = ic.inject(nc), at = ic; } catch (ce) {} }t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tc, t.createPortal = function (e, t) {
        const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; if (!Kl(t)) throw Error(a(200)); return (function (e, t, r) {
          const n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; return {
            $$typeof: x, key: n == null ? null : `${n}`, children: e, containerInfo: t, implementation: r,
          };
        }(e, t, null, r));
      }, t.createRoot = function (e, t) { if (!Kl(e)) throw Error(a(299)); let r = !1; let n = ''; let i = Gl; return t !== null && void 0 !== t && (!0 === t.unstable_strictMode && (r = !0), void 0 !== t.identifierPrefix && (n = t.identifierPrefix), void 0 !== t.onRecoverableError && (i = t.onRecoverableError)), t = Ul(e, 1, !1, null, 0, r, 0, n, i), e[pi] = t.current, Vn(e.nodeType === 8 ? e.parentNode : e), new $l(t); }, t.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; const t = e._reactInternals; if (void 0 === t) { if (typeof e.render === 'function') throw Error(a(188)); throw e = Object.keys(e).join(','), Error(a(268, e)); } return e = (e = qe(t)) === null ? null : e.stateNode; }, t.flushSync = function (e) { return hl(e); }, t.hydrate = function (e, t, r) { if (!Ql(t)) throw Error(a(200)); return ec(null, e, t, !0, r); }, t.hydrateRoot = function (e, t, r) { if (!Kl(e)) throw Error(a(405)); const n = r != null && r.hydratedSources || null; let i = !1; let o = ''; let s = Gl; if (r !== null && void 0 !== r && (!0 === r.unstable_strictMode && (i = !0), void 0 !== r.identifierPrefix && (o = r.identifierPrefix), void 0 !== r.onRecoverableError && (s = r.onRecoverableError)), t = Yl(t, null, e, 1, r != null ? r : null, i, 0, o, s), e[pi] = t.current, Vn(e), n) for (e = 0; e < n.length; e++)i = (i = (r = n[e])._getVersion)(r._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [r, i] : t.mutableSourceEagerHydrationData.push(r, i); return new Zl(t); }, t.render = function (e, t, r) { if (!Ql(t)) throw Error(a(200)); return ec(null, e, t, !1, r); }, t.unmountComponentAtNode = function (e) { if (!Ql(e)) throw Error(a(40)); return !!e._reactRootContainer && (hl((() => { ec(null, null, e, !1, (() => { e._reactRootContainer = null, e[pi] = null; })); })), !0); }, t.unstable_batchedUpdates = cl, t.unstable_renderSubtreeIntoContainer = function (e, t, r, n) { if (!Ql(r)) throw Error(a(200)); if (e == null || void 0 === e._reactInternals) throw Error(a(38)); return ec(e, t, r, !1, n); }, t.version = '18.2.0-next-9e3b772b8-20220608';
    },
    1250(e, t, r) {
      const n = r(4164); t.createRoot = n.createRoot, t.hydrateRoot = n.hydrateRoot;
    },
    4164(e, t, r) {
      !(function e() { if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE === 'function') try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e); } catch (t) { console.error(t); } }()), e.exports = r(4463);
    },
    4805(e, t, r) {
      let n; n = function (e) {
        return (function () {
          const t = {
            './node_modules/css-mediaquery/index.js': function (e, t) {
              t.match = function (e, t) { return s(e).some(((e) => { const r = e.inverse; const n = e.type === 'all' || t.type === e.type; if (n && r || !n && !r) return !1; const i = e.expressions.every(((e) => { const r = e.feature; const n = e.modifier; let i = e.value; let a = t[r]; if (!a) return !1; switch (r) { case 'orientation': case 'scan': return a.toLowerCase() === i.toLowerCase(); case 'width': case 'height': case 'device-width': case 'device-height': i = c(i), a = c(a); break; case 'resolution': i = l(i), a = l(a); break; case 'aspect-ratio': case 'device-aspect-ratio': case 'device-pixel-ratio': i = u(i), a = u(a); break; case 'grid': case 'color': case 'color-index': case 'monochrome': i = parseInt(i, 10) || 1, a = parseInt(a, 10) || 0; } switch (n) { case 'min': return a >= i; case 'max': return a <= i; default: return a === i; } })); return i && !r || !i && r; })); }, t.parse = s; const r = /(?:(only|not)?\s*([^\s\(\)]+)(?:\s*and)?\s*)?(.+)?/i; const n = /\(\s*([^\s\:\)]+)\s*(?:\:\s*([^\s\)]+))?\s*\)/; const i = /^(?:(min|max)-)?(.+)/; const a = /(em|rem|px|cm|mm|in|pt|pc)?$/; const o = /(dpi|dpcm|dppx)?$/; function s(e) { return e.split(',').map(((e) => { const t = (e = e.trim()).match(r); const a = t[1]; const o = t[2]; let s = t[3] || ''; const u = {}; return u.inverse = !!a && a.toLowerCase() === 'not', u.type = o ? o.toLowerCase() : 'all', s = s.match(/\([^\)]+\)/g) || [], u.expressions = s.map(((e) => { const t = e.match(n); const r = t[1].toLowerCase().match(i); return { modifier: r[1], feature: r[2], value: t[2] }; })), u; })); } function u(e) { let t; let r = Number(e); return r || (r = (t = e.match(/^(\d+)\s*\/\s*(\d+)$/))[1] / t[2]), r; } function l(e) { const t = parseFloat(e); switch (String(e).match(o)[1]) { case 'dpcm': return t / 2.54; case 'dppx': return 96 * t; default: return t; } } function c(e) { const t = parseFloat(e); switch (String(e).match(a)[1]) { case 'em': case 'rem': return 16 * t; case 'cm': return 96 * t / 2.54; case 'mm': return 96 * t / 2.54 / 10; case 'in': return 96 * t; case 'pt': return 72 * t; case 'pc': return 72 * t / 12; default: return t; } }
            },
            './node_modules/hyphenate-style-name/index.js': function (e, t, r) {
              r.r(t), r.d(t, { default() { return s; } }); const n = /[A-Z]/g; const i = /^ms-/; const a = {}; function o(e) { return `-${e.toLowerCase()}`; } var s = function (e) { if (a.hasOwnProperty(e)) return a[e]; const t = e.replace(n, o); return a[e] = i.test(t) ? `-${t}` : t; };
            },
            './node_modules/matchmediaquery/index.js': function (e, t, r) {
              const n = r('./node_modules/css-mediaquery/index.js').match; const i = typeof window !== 'undefined' ? window.matchMedia : null; function a(e, t, r) { const a = this; if (i && !r) { var o = i.call(window, e); this.matches = o.matches, this.media = o.media, o.addListener(s); } else this.matches = n(e, t), this.media = e; function s(e) { a.matches = e.matches, a.media = e.media; } this.addListener = function (e) { o && o.addListener(e); }, this.removeListener = function (e) { o && o.removeListener(e); }, this.dispose = function () { o && o.removeListener(s); }; }e.exports = function (e, t, r) { return new a(e, t, r); };
            },
            './node_modules/object-assign/index.js': function (e) {
              const t = Object.getOwnPropertySymbols; const r = Object.prototype.hasOwnProperty; const n = Object.prototype.propertyIsEnumerable; e.exports = (function () { try { if (!Object.assign) return !1; const e = new String('abc'); if (e[5] = 'de', Object.getOwnPropertyNames(e)[0] === '5') return !1; for (var t = {}, r = 0; r < 10; r++)t[`_${String.fromCharCode(r)}`] = r; if (Object.getOwnPropertyNames(t).map(((e) => t[e])).join('') !== '0123456789') return !1; const n = {}; return 'abcdefghijklmnopqrst'.split('').forEach(((e) => { n[e] = e; })), Object.keys({ ...n }).join('') === 'abcdefghijklmnopqrst'; } catch (i) { return !1; } }()) ? Object.assign : function (e, i) { for (var a, o, s = (function (e) { if (e === null || void 0 === e) throw new TypeError('Object.assign cannot be called with null or undefined'); return Object(e); }(e)), u = 1; u < arguments.length; u++) { for (const l in a = Object(arguments[u]))r.call(a, l) && (s[l] = a[l]); if (t) { o = t(a); for (let c = 0; c < o.length; c++)n.call(a, o[c]) && (s[o[c]] = a[o[c]]); } } return s; };
            },
            './node_modules/prop-types/checkPropTypes.js': function (e, t, r) {
              let n = function () {}; const i = r('./node_modules/prop-types/lib/ReactPropTypesSecret.js'); let a = {}; const o = r('./node_modules/prop-types/lib/has.js'); function s(e, t, r, s, u) { for (const l in e) if (o(e, l)) { var c; try { if (typeof e[l] !== 'function') { const h = Error(`${s || 'React class'}: ${r} type \`${l}\` is invalid; it must be a function, usually from the \`prop-types\` package, but received \`${typeof e[l]}\`.This often happens because of typos such as \`PropTypes.function\` instead of \`PropTypes.func\`.`); throw h.name = 'Invariant Violation', h; }c = e[l](t, l, s, r, null, i); } catch (d) { c = d; } if (!c || c instanceof Error || n(`${s || 'React class'}: type specification of ${r} \`${l}\` is invalid; the type checker function must return \`null\` or an \`Error\` but returned a ${typeof c}. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).`), c instanceof Error && !(c.message in a)) { a[c.message] = !0; const f = u ? u() : ''; n(`Failed ${r} type: ${c.message}${f != null ? f : ''}`); } } }n = function (e) { const t = `Warning: ${e}`; typeof console !== 'undefined' && console.error(t); try { throw new Error(t); } catch (r) {} }, s.resetWarningCache = function () { a = {}; }, e.exports = s;
            },
            './node_modules/prop-types/factoryWithTypeCheckers.js': function (e, t, r) {
              const n = r('./node_modules/react-is/index.js'); const i = r('./node_modules/object-assign/index.js'); const a = r('./node_modules/prop-types/lib/ReactPropTypesSecret.js'); const o = r('./node_modules/prop-types/lib/has.js'); const s = r('./node_modules/prop-types/checkPropTypes.js'); let u = function () {}; function l() { return null; }u = function (e) { const t = `Warning: ${e}`; typeof console !== 'undefined' && console.error(t); try { throw new Error(t); } catch (r) {} }, e.exports = function (e, t) {
                const r = typeof Symbol === 'function' && Symbol.iterator; const c = '@@iterator'; const h = '<<anonymous>>'; const f = {
                  array: v('array'), bigint: v('bigint'), bool: v('boolean'), func: v('function'), number: v('number'), object: v('object'), string: v('string'), symbol: v('symbol'), any: m(l), arrayOf(e) { return m(((t, r, n, i, o) => { if (typeof e !== 'function') return new p(`Property \`${o}\` of component \`${n}\` has invalid PropType notation inside arrayOf.`); const s = t[r]; if (!Array.isArray(s)) return new p(`Invalid ${i} \`${o}\` of type \`${b(s)}\` supplied to \`${n}\`, expected an array.`); for (let u = 0; u < s.length; u++) { const l = e(s, u, n, i, `${o }[${ u }]`, a); if (l instanceof Error) return l; } return null; })); }, element: m(((t, r, n, i, a) => { const o = t[r]; return e(o) ? null : new p(`Invalid ${i} \`${a}\` of type \`${b(o)}\` supplied to \`${n}\`, expected a single ReactElement.`); })), elementType: m(((e, t, r, i, a) => { const o = e[t]; return n.isValidElementType(o) ? null : new p(`Invalid ${i} \`${a}\` of type \`${b(o)}\` supplied to \`${r}\`, expected a single ReactElement type.`); })), instanceOf(e) { return m(((t, r, n, i, a) => { if (!(t[r] instanceof e)) { const o = e.name || h; return new p(`Invalid ${i} \`${a}\` of type \`${(s = t[r]).constructor && s.constructor.name ? s.constructor.name : h}\` supplied to \`${n}\`, expected instance of \`${o}\`.`); } let s; return null; })); }, node: m(((e, t, r, n, i) => (y(e[t]) ? null : new p(`Invalid ${n } \`${ i }\` supplied to \`${ r }\`, expected a ReactNode.`)))), objectOf(e) { return m(((t, r, n, i, s) => { if (typeof e !== 'function') return new p(`Property \`${s}\` of component \`${n}\` has invalid PropType notation inside objectOf.`); const u = t[r]; const l = b(u); if (l !== 'object') return new p(`Invalid ${i} \`${s}\` of type \`${l}\` supplied to \`${n}\`, expected an object.`); for (const c in u) if (o(u, c)) { const h = e(u, c, n, i, `${s }.${ c}`, a); if (h instanceof Error) return h; } return null; })); }, oneOf(e) { return Array.isArray(e) ? m(((t, r, n, i, a) => { for (var o = t[r], s = 0; s < e.length; s++) if (d(o, e[s])) return null; const u = JSON.stringify(e, ((e, t) => 'symbol' === w(t) ? String(t) : t)); return new p(`Invalid ${i} \`${a}\` of value \`${String(o)}\` supplied to \`${n}\`, expected one of ${u}.`); })) : (u(arguments.length > 1 ? `Invalid arguments supplied to oneOf, expected an array, got ${ arguments.length } arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).` : 'Invalid argument supplied to oneOf, expected an array.'), l); }, oneOfType(e) { if (!Array.isArray(e)) return u('Invalid argument supplied to oneOfType, expected an instance of array.'), l; for (let t = 0; t < e.length; t++) { const r = e[t]; if (typeof r !== 'function') return u(`Invalid argument supplied to oneOfType. Expected an array of check functions, but received ${k(r)} at index ${t}.`), l; } return m(((t, r, n, i, s) => { for (var u = [], l = 0; l < e.length; l++) { const c = (0, e[l])(t, r, n, i, s, a); if (c == null) return null; c.data && o(c.data, 'expectedType') && u.push(c.data.expectedType); } return new p(`Invalid ${i} \`${s}\` supplied to \`${n}\`${u.length > 0 ? `, expected one of type [${  u.join(', ')  }]` : '' }.`); })); }, shape(e) { return m(((t, r, n, i, o) => { const s = t[r]; const u = b(s); if (u !== 'object') return new p(`Invalid ${i} \`${o}\` of type \`${u}\` supplied to \`${n}\`, expected \`object\`.`); for (const l in e) { const c = e[l]; if (typeof c !== 'function') return g(n, i, o, l, w(c)); const h = c(s, l, n, i, `${o }.${ l}`, a); if (h) return h; } return null; })); }, exact(e) { return m(((t, r, n, s, u) => { const l = t[r]; const c = b(l); if (c !== 'object') return new p(`Invalid ${s} \`${u}\` of type \`${c}\` supplied to \`${n}\`, expected \`object\`.`); const h = i({}, t[r], e); for (const f in h) { const d = e[f]; if (o(e, f) && typeof d !== 'function') return g(n, s, u, f, w(d)); if (!d) return new p(`Invalid ${s} \`${u}\` key \`${f}\` supplied to \`${n}\`.\nBad object: ${JSON.stringify(t[r], null, '  ')}\nValid keys: ${JSON.stringify(Object.keys(e), null, '  ')}`); const m = d(l, f, n, s, `${u }.${ f}`, a); if (m) return m; } return null; })); },
                }; function d(e, t) { return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t; } function p(e, t) { this.message = e, this.data = t && typeof t === 'object' ? t : {}, this.stack = ''; } function m(e) { const r = {}; let n = 0; function i(i, o, s, l, c, f, d) { if (l = l || h, f = f || s, d !== a) { if (t) { const m = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types'); throw m.name = 'Invariant Violation', m; } if (typeof console !== 'undefined') { const v = `${l}:${s}`; !r[v] && n < 3 && (u(`You are manually calling a React.PropTypes validation function for the \`${f}\` prop on \`${l}\`. This is deprecated and will throw in the standalone \`prop-types\` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.`), r[v] = !0, n++); } } return o[s] == null ? i ? o[s] === null ? new p(`The ${c} \`${f}\` is marked as required in \`${l}\`, but its value is \`null\`.`) : new p(`The ${c} \`${f}\` is marked as required in \`${l}\`, but its value is \`undefined\`.`) : null : e(o, s, l, c, f); } const o = i.bind(null, !1); return o.isRequired = i.bind(null, !0), o; } function v(e) { return m(((t, r, n, i, a, o) => { const s = t[r]; return b(s) !== e ? new p(`Invalid ${i} \`${a}\` of type \`${w(s)}\` supplied to \`${n}\`, expected \`${e}\`.`, { expectedType: e }) : null; })); } function g(e, t, r, n, i) { return new p(`${e || 'React class'}: ${t} type \`${r}.${n}\` is invalid; it must be a function, usually from the \`prop-types\` package, but received \`${i}\`.`); } function y(t) { switch (typeof t) { case 'number': case 'string': case 'undefined': return !0; case 'boolean': return !t; case 'object': if (Array.isArray(t)) return t.every(y); if (t === null || e(t)) return !0; var n = (function (e) { const t = e && (r && e[r] || e[c]); if (typeof t === 'function') return t; }(t)); if (!n) return !1; var i; var a = n.call(t); if (n !== t.entries) { for (;!(i = a.next()).done;) if (!y(i.value)) return !1; } else for (;!(i = a.next()).done;) { const o = i.value; if (o && !y(o[1])) return !1; } return !0; default: return !1; } } function b(e) { const t = typeof e; return Array.isArray(e) ? 'array' : e instanceof RegExp ? 'object' : (function (e, t) { return e === 'symbol' || !!t && (t['@@toStringTag'] === 'Symbol' || typeof Symbol === 'function' && t instanceof Symbol); }(t, e)) ? 'symbol' : t; } function w(e) { if (typeof e === 'undefined' || e === null) return `${e}`; const t = b(e); if (t === 'object') { if (e instanceof Date) return 'date'; if (e instanceof RegExp) return 'regexp'; } return t; } function k(e) { const t = w(e); switch (t) { case 'array': case 'object': return `an ${t}`; case 'boolean': case 'date': case 'regexp': return `a ${t}`; default: return t; } } return p.prototype = Error.prototype, f.checkPropTypes = s, f.resetWarningCache = s.resetWarningCache, f.PropTypes = f, f;
              };
            },
            './node_modules/prop-types/index.js': function (e, t, r) { const n = r('./node_modules/react-is/index.js'); e.exports = r('./node_modules/prop-types/factoryWithTypeCheckers.js')(n.isElement, !0); },
            './node_modules/prop-types/lib/ReactPropTypesSecret.js': function (e) {
              e.exports = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
            },
            './node_modules/prop-types/lib/has.js': function (e) { e.exports = Function.call.bind(Object.prototype.hasOwnProperty); },
            './node_modules/react-is/cjs/react-is.development.js': function (e, t) {
              !(function () { const e = typeof Symbol === 'function' && Symbol.for; const r = e ? Symbol.for('react.element') : 60103; const n = e ? Symbol.for('react.portal') : 60106; const i = e ? Symbol.for('react.fragment') : 60107; const a = e ? Symbol.for('react.strict_mode') : 60108; const o = e ? Symbol.for('react.profiler') : 60114; const s = e ? Symbol.for('react.provider') : 60109; const u = e ? Symbol.for('react.context') : 60110; const l = e ? Symbol.for('react.async_mode') : 60111; const c = e ? Symbol.for('react.concurrent_mode') : 60111; const h = e ? Symbol.for('react.forward_ref') : 60112; const f = e ? Symbol.for('react.suspense') : 60113; const d = e ? Symbol.for('react.suspense_list') : 60120; const p = e ? Symbol.for('react.memo') : 60115; const m = e ? Symbol.for('react.lazy') : 60116; const v = e ? Symbol.for('react.block') : 60121; const g = e ? Symbol.for('react.fundamental') : 60117; const y = e ? Symbol.for('react.responder') : 60118; const b = e ? Symbol.for('react.scope') : 60119; function w(e) { if (typeof e === 'object' && e !== null) { const t = e.$$typeof; switch (t) { case r: var d = e.type; switch (d) { case l: case c: case i: case o: case a: case f: return d; default: var v = d && d.$$typeof; switch (v) { case u: case h: case m: case p: case s: return v; default: return t; } } case n: return t; } } } const k = l; const x = c; const _ = u; const S = s; const M = r; const E = h; const C = i; const P = m; const A = p; const T = n; const R = o; const I = a; const O = f; let D = !1; function z(e) { return w(e) === c; }t.AsyncMode = k, t.ConcurrentMode = x, t.ContextConsumer = _, t.ContextProvider = S, t.Element = M, t.ForwardRef = E, t.Fragment = C, t.Lazy = P, t.Memo = A, t.Portal = T, t.Profiler = R, t.StrictMode = I, t.Suspense = O, t.isAsyncMode = function (e) { return D || (D = !0, console.warn('The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.')), z(e) || w(e) === l; }, t.isConcurrentMode = z, t.isContextConsumer = function (e) { return w(e) === u; }, t.isContextProvider = function (e) { return w(e) === s; }, t.isElement = function (e) { return typeof e === 'object' && e !== null && e.$$typeof === r; }, t.isForwardRef = function (e) { return w(e) === h; }, t.isFragment = function (e) { return w(e) === i; }, t.isLazy = function (e) { return w(e) === m; }, t.isMemo = function (e) { return w(e) === p; }, t.isPortal = function (e) { return w(e) === n; }, t.isProfiler = function (e) { return w(e) === o; }, t.isStrictMode = function (e) { return w(e) === a; }, t.isSuspense = function (e) { return w(e) === f; }, t.isValidElementType = function (e) { return typeof e === 'string' || typeof e === 'function' || e === i || e === c || e === o || e === a || e === f || e === d || typeof e === 'object' && e !== null && (e.$$typeof === m || e.$$typeof === p || e.$$typeof === s || e.$$typeof === u || e.$$typeof === h || e.$$typeof === g || e.$$typeof === y || e.$$typeof === b || e.$$typeof === v); }, t.typeOf = w; }());
            },
            './node_modules/react-is/index.js': function (e, t, r) {
              e.exports = r('./node_modules/react-is/cjs/react-is.development.js');
            },
            './node_modules/shallow-equal/dist/index.esm.js': function (e, t, r) {
              function n(e, t) { if (e === t) return !0; if (!e || !t) return !1; const r = Object.keys(e); const n = Object.keys(t); const i = r.length; if (n.length !== i) return !1; for (let a = 0; a < i; a++) { const o = r[a]; if (e[o] !== t[o] || !Object.prototype.hasOwnProperty.call(t, o)) return !1; } return !0; } function i(e, t) { if (e === t) return !0; if (!e || !t) return !1; const r = e.length; if (t.length !== r) return !1; for (let n = 0; n < r; n++) if (e[n] !== t[n]) return !1; return !0; }r.r(t), r.d(t, { shallowEqualArrays() { return i; }, shallowEqualObjects() { return n; } });
            },
            './src/Component.ts': function (e, t, r) {
              const n = this && this.__rest || function (e, t) { const r = {}; for (var n in e)Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]); if (e != null && typeof Object.getOwnPropertySymbols === 'function') { let i = 0; for (n = Object.getOwnPropertySymbols(e); i < n.length; i++)t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]); } return r; }; const i = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e }; }; Object.defineProperty(t, '__esModule', { value: !0 }); const a = i(r('./src/useMediaQuery.ts')); t.default = function (e) { const t = e.children; const r = e.device; const i = e.onChange; const o = n(e, ['children', 'device', 'onChange']); const s = (0, a.default)(o, r, i); return typeof t === 'function' ? t(s) : s ? t : null; };
            },
            './src/Context.ts': function (e, t, r) {
              Object.defineProperty(t, '__esModule', { value: !0 }); const n = (0, r('react').createContext)(void 0); t.default = n;
            },
            './src/index.ts': function (e, t, r) {
              const n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e }; }; Object.defineProperty(t, '__esModule', { value: !0 }), t.Context = t.toQuery = t.useMediaQuery = t.default = void 0; const i = n(r('./src/useMediaQuery.ts')); t.useMediaQuery = i.default; const a = n(r('./src/Component.ts')); t.default = a.default; const o = n(r('./src/toQuery.ts')); t.toQuery = o.default; const s = n(r('./src/Context.ts')); t.Context = s.default;
            },
            './src/mediaQuery.ts': function (e, t, r) {
              var n = this && this.__assign || function () { return n = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) for (const i in t = arguments[r])Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e; }, n.apply(this, arguments); }; const i = this && this.__rest || function (e, t) { const r = {}; for (var n in e)Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]); if (e != null && typeof Object.getOwnPropertySymbols === 'function') { let i = 0; for (n = Object.getOwnPropertySymbols(e); i < n.length; i++)t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]); } return r; }; const a = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e }; }; Object.defineProperty(t, '__esModule', { value: !0 }); const o = a(r('./node_modules/prop-types/index.js')); const s = o.default.oneOfType([o.default.string, o.default.number]); const u = {
                all: o.default.bool, grid: o.default.bool, aural: o.default.bool, braille: o.default.bool, handheld: o.default.bool, print: o.default.bool, projection: o.default.bool, screen: o.default.bool, tty: o.default.bool, tv: o.default.bool, embossed: o.default.bool,
              }; const l = {
                orientation: o.default.oneOf(['portrait', 'landscape']), scan: o.default.oneOf(['progressive', 'interlace']), aspectRatio: o.default.string, deviceAspectRatio: o.default.string, height: s, deviceHeight: s, width: s, deviceWidth: s, color: o.default.bool, colorIndex: o.default.bool, monochrome: o.default.bool, resolution: s, type: Object.keys(u),
              }; const c = i(l, ['type']); const h = {
 minAspectRatio: o.default.string, maxAspectRatio: o.default.string, minDeviceAspectRatio: o.default.string, maxDeviceAspectRatio: o.default.string, minHeight: s, maxHeight: s, minDeviceHeight: s, maxDeviceHeight: s, minWidth: s, maxWidth: s, minDeviceWidth: s, maxDeviceWidth: s, minColor: o.default.number, maxColor: o.default.number, minColorIndex: o.default.number, maxColorIndex: o.default.number, minMonochrome: o.default.number, maxMonochrome: o.default.number, minResolution: s, maxResolution: s, ...c 
}; const f = { ...u, ...h }; t.default = {
                all: f, types: u, matchers: l, features: h,
              };
            },
            './src/toQuery.ts': function (e, t, r) {
              const n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e }; }; Object.defineProperty(t, '__esModule', { value: !0 }); const i = n(r('./node_modules/hyphenate-style-name/index.js')); const a = n(r('./src/mediaQuery.ts')); t.default = function (e) { const t = []; return Object.keys(a.default.all).forEach(((r) => { const n = e[r]; n != null && t.push(function (e, t) { const r = (0, i.default)(e); return typeof t === 'number' && (t = ''.concat(t, 'px')), !0 === t ? r : !1 === t ? 'not '.concat(r) : '('.concat(r, ': ').concat(t, ')'); }(r, n)); })), t.join(' and '); };
            },
            './src/useMediaQuery.ts': function (e, t, r) {
              const n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e }; }; Object.defineProperty(t, '__esModule', { value: !0 }); const i = r('react'); const a = n(r('./node_modules/matchmediaquery/index.js')); const o = n(r('./node_modules/hyphenate-style-name/index.js')); const s = r('./node_modules/shallow-equal/dist/index.esm.js'); const u = n(r('./src/toQuery.ts')); const l = n(r('./src/Context.ts')); const c = function (e) { if (e) return Object.keys(e).reduce(((t, r) => (t[(0, o.default)(r)] = e[r], t)), {}); }; const h = function () { const e = (0, i.useRef)(!1); return (0, i.useEffect)((() => { e.current = !0; }), []), e.current; }; const f = function (e) { const t = function () { return (function (e) { return e.query || (0, u.default)(e); }(e)); }; const r = (0, i.useState)(t); const n = r[0]; const a = r[1]; return (0, i.useEffect)((() => { const e = t(); n !== e && a(e); }), [e]), n; }; t.default = function (e, t, r) { const n = (function (e) { const t = (0, i.useContext)(l.default); const r = function () { return c(e) || c(t); }; const n = (0, i.useState)(r); const a = n[0]; const o = n[1]; return (0, i.useEffect)((() => { const e = r(); (0, s.shallowEqualObjects)(a, e) || o(e); }), [e, t]), a; }(t)); const o = f(e); if (!o) throw new Error('Invalid or missing MediaQuery!'); const u = (function (e, t) { const r = function () { return (0, a.default)(e, t || {}, !!t); }; const n = (0, i.useState)(r); const o = n[0]; const s = n[1]; const u = h(); return (0, i.useEffect)((() => { if (u) { const e = r(); return s(e), function () { e && e.dispose(); }; } }), [e, t]), o; }(o, n)); const d = (function (e) { const t = (0, i.useState)(e.matches); const r = t[0]; const n = t[1]; return (0, i.useEffect)((() => { const t = function (e) { n(e.matches); }; return e.addListener(t), n(e.matches), function () { e.removeListener(t); }; }), [e]), r; }(u)); const p = h(); return (0, i.useEffect)((() => { p && r && r(d); }), [d]), (0, i.useEffect)((() => function () { u && u.dispose(); }), []), d; };
            },
            react(t) {
              t.exports = e;
            },
          }; const r = {}; function n(e) { const i = r[e]; if (void 0 !== i) return i.exports; const a = r[e] = { exports: {} }; return t[e].call(a.exports, a, a.exports, n), a.exports; } return n.d = function (e, t) { for (const r in t)n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, { enumerable: !0, get: t[r] }); }, n.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t); }, n.r = function (e) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(e, '__esModule', { value: !0 }); }, n('./src/index.ts');
        }());
      }, e.exports = n(r(2791));
    },
    97(e, t, r) {
      let n; n = function (e) {
        return (function (e) { const t = {}; function r(n) { if (t[n]) return t[n].exports; const i = t[n] = { i: n, l: !1, exports: {} }; return e[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports; } return r.m = e, r.c = t, r.d = function (e, t, n) { r.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: n }); }, r.r = function (e) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(e, '__esModule', { value: !0 }); }, r.t = function (e, t) { if (1 & t && (e = r(e)), 8 & t) return e; if (4 & t && typeof e === 'object' && e && e.__esModule) return e; const n = Object.create(null); if (r.r(n), Object.defineProperty(n, 'default', { enumerable: !0, value: e }), 2 & t && typeof e !== 'string') for (const i in e)r.d(n, i, ((t) => e[t]).bind(null, i)); return n; }, r.n = function (e) { const t = e && e.__esModule ? function () { return e.default; } : function () { return e; }; return r.d(t, 'a', t), t; }, r.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t); }, r.p = '', r(r.s = './src/react-webcam.tsx'); }({
          './src/react-webcam.tsx': function (e, t, r) {
            r.r(t); const n = r('react'); const i = (function () { let e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t; } || function (e, t) { for (const r in t)t.hasOwnProperty(r) && (e[r] = t[r]); }, e(t, r); }; return function (t, r) { function n() { this.constructor = t; }e(t, r), t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n()); }; }()); let a = function () { return a = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) for (const i in t = arguments[r])Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e; }, a.apply(this, arguments); }; const o = function (e, t) { const r = {}; for (var n in e)Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]); if (e != null && typeof Object.getOwnPropertySymbols === 'function') { let i = 0; for (n = Object.getOwnPropertySymbols(e); i < n.length; i++)t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]); } return r; }; function s() { return !(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia); } typeof window !== 'undefined' && (void 0 === navigator.mediaDevices && (navigator.mediaDevices = {}), void 0 === navigator.mediaDevices.getUserMedia && (navigator.mediaDevices.getUserMedia = function (e) { const t = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia; return t ? new Promise(((r, n) => { t.call(navigator, e, r, n); })) : Promise.reject(new Error('getUserMedia is not implemented in this browser')); })); const u = (function (e) {
              function t(t) { const r = e.call(this, t) || this; return r.canvas = null, r.ctx = null, r.requestUserMediaId = 0, r.unmounted = !1, r.state = { hasUserMedia: !1 }, r; } return i(t, e), t.prototype.componentDidMount = function () { const e = this.state; const t = this.props; this.unmounted = !1, s() ? (e.hasUserMedia || this.requestUserMedia(), t.children && typeof t.children !== 'function' && console.warn('children must be a function')) : t.onUserMediaError('getUserMedia not supported'); }, t.prototype.componentDidUpdate = function (e) { const t = this.props; if (s()) { const r = JSON.stringify(e.audioConstraints) !== JSON.stringify(t.audioConstraints); const n = JSON.stringify(e.videoConstraints) !== JSON.stringify(t.videoConstraints); const i = e.minScreenshotWidth !== t.minScreenshotWidth; const a = e.minScreenshotHeight !== t.minScreenshotHeight; (n || i || a) && (this.canvas = null, this.ctx = null), (r || n) && (this.stopAndCleanup(), this.requestUserMedia()); } else t.onUserMediaError('getUserMedia not supported'); }, t.prototype.componentWillUnmount = function () { this.unmounted = !0, this.stopAndCleanup(); }, t.stopMediaStream = function (e) { e && (e.getVideoTracks && e.getAudioTracks ? (e.getVideoTracks().map(((t) => { e.removeTrack(t), t.stop(); })), e.getAudioTracks().map(((t) => { e.removeTrack(t), t.stop(); }))) : e.stop()); }, t.prototype.stopAndCleanup = function () { const e = this.state; e.hasUserMedia && (t.stopMediaStream(this.stream), e.src && window.URL.revokeObjectURL(e.src)); }, t.prototype.getScreenshot = function (e) { const t = this.state; const r = this.props; if (!t.hasUserMedia) return null; const n = this.getCanvas(e); return n && n.toDataURL(r.screenshotFormat, r.screenshotQuality); }, t.prototype.getCanvas = function (e) { const t = this.state; const r = this.props; if (!this.video) return null; if (!t.hasUserMedia || !this.video.videoHeight) return null; if (!this.ctx) { let n = this.video.videoWidth; let i = this.video.videoHeight; if (!this.props.forceScreenshotSourceSize) { const a = n / i; i = (n = r.minScreenshotWidth || this.video.clientWidth) / a, r.minScreenshotHeight && i < r.minScreenshotHeight && (n = (i = r.minScreenshotHeight) * a); } this.canvas = document.createElement('canvas'), this.canvas.width = (e === null || void 0 === e ? void 0 : e.width) || n, this.canvas.height = (e === null || void 0 === e ? void 0 : e.height) || i, this.ctx = this.canvas.getContext('2d'); } const o = this.ctx; const s = this.canvas; return o && s && (s.width = (e === null || void 0 === e ? void 0 : e.width) || s.width, s.height = (e === null || void 0 === e ? void 0 : e.height) || s.height, r.mirrored && (o.translate(s.width, 0), o.scale(-1, 1)), o.imageSmoothingEnabled = r.imageSmoothing, o.drawImage(this.video, 0, 0, (e === null || void 0 === e ? void 0 : e.width) || s.width, (e === null || void 0 === e ? void 0 : e.height) || s.height), r.mirrored && (o.scale(-1, 1), o.translate(-s.width, 0))), s; }, t.prototype.requestUserMedia = function () { const e = this; const r = this.props; const n = function (n, i) { const a = { video: typeof i === 'undefined' || i }; r.audio && (a.audio = typeof n === 'undefined' || n), e.requestUserMediaId++; const o = e.requestUserMediaId; navigator.mediaDevices.getUserMedia(a).then(((r) => { e.unmounted || o !== e.requestUserMediaId ? t.stopMediaStream(r) : e.handleUserMedia(null, r); })).catch(((t) => { e.handleUserMedia(t); })); }; if ('mediaDevices' in navigator)n(r.audioConstraints, r.videoConstraints); else { const i = function (e) { return { optional: [{ sourceId: e }] }; }; const a = function (e) { const t = e.deviceId; return typeof t === 'string' ? t : Array.isArray(t) && t.length > 0 ? t[0] : typeof t === 'object' && t.ideal ? t.ideal : null; }; MediaStreamTrack.getSources(((e) => { let t = null; let o = null; e.forEach(((e) => { e.kind === 'audio' ? t = e.id : e.kind === 'video' && (o = e.id); })); const s = a(r.audioConstraints); s && (t = s); const u = a(r.videoConstraints); u && (o = u), n(i(t), i(o)); })); } }, t.prototype.handleUserMedia = function (e, t) { const r = this.props; if (e || !t) return this.setState({ hasUserMedia: !1 }), void r.onUserMediaError(e); this.stream = t; try { this.video && (this.video.srcObject = t), this.setState({ hasUserMedia: !0 }); } catch (n) { this.setState({ hasUserMedia: !0, src: window.URL.createObjectURL(t) }); }r.onUserMedia(t); }, t.prototype.render = function () {
 const e = this; const t = this.state; const r = this.props; const i = r.audio; const s = (r.forceScreenshotSourceSize, r.onUserMedia, r.onUserMediaError, r.screenshotFormat, r.screenshotQuality, r.minScreenshotWidth, r.minScreenshotHeight, r.audioConstraints, r.videoConstraints, r.imageSmoothing, r.mirrored); const u = r.style; const l = void 0 === u ? {} : u; const c = r.children; const h = o(r, ['audio', 'forceScreenshotSourceSize', 'onUserMedia', 'onUserMediaError', 'screenshotFormat', 'screenshotQuality', 'minScreenshotWidth', 'minScreenshotHeight', 'audioConstraints', 'videoConstraints', 'imageSmoothing', 'mirrored', 'style', 'children']); const f = s ? ({ ...l, transform: `${l.transform || ""  } scaleX(-1)`}) : l; const d = { getScreenshot: this.getScreenshot.bind(this) }; return n.createElement(n.Fragment, null, n.createElement('video', {
                autoPlay: !0, src: t.src, muted: !i, playsInline: !0, ref(t) { e.video = t; }, style: f, ...h, 
}), c && c(d)); 
}, t.defaultProps = {
                audio: !1, forceScreenshotSourceSize: !1, imageSmoothing: !0, mirrored: !1, onUserMedia() {}, onUserMediaError() {}, screenshotFormat: 'image/webp', screenshotQuality: 0.92,
              }, t;
            }(n.Component)); t.default = u;
          },
          react(t, r) { t.exports = e; },
        })).default;
      }, e.exports = n(r(2791));
    },
    6374(e, t, r) {
      const n = r(2791); const i = Symbol.for('react.element'); const a = Symbol.for('react.fragment'); const o = Object.prototype.hasOwnProperty; const s = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner; const u = {
        key: !0, ref: !0, __self: !0, __source: !0,
      }; function l(e, t, r) {
        let n; const a = {}; let l = null; let c = null; for (n in void 0 !== r && (l = `${r}`), void 0 !== t.key && (l = `${t.key}`), void 0 !== t.ref && (c = t.ref), t)o.call(t, n) && !u.hasOwnProperty(n) && (a[n] = t[n]); if (e && e.defaultProps) for (n in t = e.defaultProps) void 0 === a[n] && (a[n] = t[n]); return {
          $$typeof: i, type: e, key: l, ref: c, props: a, _owner: s.current,
        };
      }t.Fragment = a, t.jsx = l, t.jsxs = l;
    },
    9117(e, t) {
      const r = Symbol.for('react.element'); const n = Symbol.for('react.portal'); const i = Symbol.for('react.fragment'); const a = Symbol.for('react.strict_mode'); const o = Symbol.for('react.profiler'); const s = Symbol.for('react.provider'); const u = Symbol.for('react.context'); const l = Symbol.for('react.forward_ref'); const c = Symbol.for('react.suspense'); const h = Symbol.for('react.memo'); const f = Symbol.for('react.lazy'); const d = Symbol.iterator; const p = {
        isMounted() { return !1; }, enqueueForceUpdate() {}, enqueueReplaceState() {}, enqueueSetState() {},
      }; const m = Object.assign; const v = {}; function g(e, t, r) { this.props = e, this.context = t, this.refs = v, this.updater = r || p; } function y() {} function b(e, t, r) { this.props = e, this.context = t, this.refs = v, this.updater = r || p; }g.prototype.isReactComponent = {}, g.prototype.setState = function (e, t) { if (typeof e !== 'object' && typeof e !== 'function' && e != null) throw Error('setState(...): takes an object of state variables to update or a function which returns an object of state variables.'); this.updater.enqueueSetState(this, e, t, 'setState'); }, g.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, 'forceUpdate'); }, y.prototype = g.prototype; const w = b.prototype = new y(); w.constructor = b, m(w, g.prototype), w.isPureReactComponent = !0; const k = Array.isArray; const x = Object.prototype.hasOwnProperty; const _ = { current: null }; const S = {
        key: !0, ref: !0, __self: !0, __source: !0,
      }; function M(e, t, n) {
        let i; const a = {}; let o = null; let s = null; if (t != null) for (i in void 0 !== t.ref && (s = t.ref), void 0 !== t.key && (o = `${t.key}`), t)x.call(t, i) && !S.hasOwnProperty(i) && (a[i] = t[i]); let u = arguments.length - 2; if (u === 1)a.children = n; else if (u > 1) { for (var l = Array(u), c = 0; c < u; c++)l[c] = arguments[c + 2]; a.children = l; } if (e && e.defaultProps) for (i in u = e.defaultProps) void 0 === a[i] && (a[i] = u[i]); return {
          $$typeof: r, type: e, key: o, ref: s, props: a, _owner: _.current,
        };
      } function E(e) { return typeof e === 'object' && e !== null && e.$$typeof === r; } const C = /\/+/g; function P(e, t) { return typeof e === 'object' && e !== null && e.key != null ? (function (e) { const t = { '=': '=0', ':': '=2' }; return `$${e.replace(/[=:]/g, ((e) => t[e]))}`; }(`${e.key}`)) : t.toString(36); } function A(e, t, i, a, o) {
        let s = typeof e; s !== 'undefined' && s !== 'boolean' || (e = null); let u = !1; if (e === null)u = !0; else switch (s) { case 'string': case 'number': u = !0; break; case 'object': switch (e.$$typeof) { case r: case n: u = !0; } } if (u) {
          return o = o(u = e), e = a === '' ? `.${P(u, 0)}` : a, k(o) ? (i = '', e != null && (i = `${e.replace(C, '$&/')}/`), A(o, t, i, '', ((e) => e))) : o != null && (E(o) && (o = (function (e, t) {
            return {
              $$typeof: r, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner,
            };
          }(o, i + (!o.key || u && u.key === o.key ? '' : `${(`${o.key}`).replace(C, '$&/')}/`) + e))), t.push(o)), 1;
        } if (u = 0, a = a === '' ? '.' : `${a}:`, k(e)) for (var l = 0; l < e.length; l++) { var c = a + P(s = e[l], l); u += A(s, t, i, c, o); } else if (c = (function (e) { return e === null || typeof e !== 'object' ? null : typeof (e = d && e[d] || e['@@iterator']) === 'function' ? e : null; }(e)), typeof c === 'function') for (e = c.call(e), l = 0; !(s = e.next()).done;)u += A(s = s.value, t, i, c = a + P(s, l++), o); else if (s === 'object') throw t = String(e), Error(`Objects are not valid as a React child (found: ${t === '[object Object]' ? `object with keys {${Object.keys(e).join(', ')}}` : t}). If you meant to render a collection of children, use an array instead.`); return u;
      } function T(e, t, r) { if (e == null) return e; const n = []; let i = 0; return A(e, n, '', '', ((e) => t.call(r, e, i++))), n; } function R(e) { if (e._status === -1) { let t = e._result; (t = t()).then(((t) => { e._status !== 0 && e._status !== -1 || (e._status = 1, e._result = t); }), ((t) => { e._status !== 0 && e._status !== -1 || (e._status = 2, e._result = t); })), e._status === -1 && (e._status = 0, e._result = t); } if (e._status === 1) return e._result.default; throw e._result; } const I = { current: null }; const O = { transition: null }; const D = { ReactCurrentDispatcher: I, ReactCurrentBatchConfig: O, ReactCurrentOwner: _ }; t.Children = {
        map: T, forEach(e, t, r) { T(e, (function () { t.apply(this, arguments); }), r); }, count(e) { let t = 0; return T(e, (() => { t++; })), t; }, toArray(e) { return T(e, ((e) => e)) || []; }, only(e) { if (!E(e)) throw Error('React.Children.only expected to receive a single React element child.'); return e; },
      }, t.Component = g, t.Fragment = i, t.Profiler = o, t.PureComponent = b, t.StrictMode = a, t.Suspense = c, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = D, t.cloneElement = function (e, t, n) {
        if (e === null || void 0 === e) throw Error(`React.cloneElement(...): The argument must be a React element, but you passed ${e}.`); const i = { ...e.props }; let a = e.key; let o = e.ref; let s = e._owner; if (t != null) { if (void 0 !== t.ref && (o = t.ref, s = _.current), void 0 !== t.key && (a = `${t.key}`), e.type && e.type.defaultProps) var u = e.type.defaultProps; for (l in t)x.call(t, l) && !S.hasOwnProperty(l) && (i[l] = void 0 === t[l] && void 0 !== u ? u[l] : t[l]); } var l = arguments.length - 2; if (l === 1)i.children = n; else if (l > 1) { u = Array(l); for (let c = 0; c < l; c++)u[c] = arguments[c + 2]; i.children = u; } return {
          $$typeof: r, type: e.type, key: a, ref: o, props: i, _owner: s,
        };
      }, t.createContext = function (e) {
        return (e = {
          $$typeof: u, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null,
        }).Provider = { $$typeof: s, _context: e }, e.Consumer = e;
      }, t.createElement = M, t.createFactory = function (e) { const t = M.bind(null, e); return t.type = e, t; }, t.createRef = function () { return { current: null }; }, t.forwardRef = function (e) { return { $$typeof: l, render: e }; }, t.isValidElement = E, t.lazy = function (e) { return { $$typeof: f, _payload: { _status: -1, _result: e }, _init: R }; }, t.memo = function (e, t) { return { $$typeof: h, type: e, compare: void 0 === t ? null : t }; }, t.startTransition = function (e) { const t = O.transition; O.transition = {}; try { e(); } finally { O.transition = t; } }, t.unstable_act = function () { throw Error('act(...) is not supported in production builds of React.'); }, t.useCallback = function (e, t) { return I.current.useCallback(e, t); }, t.useContext = function (e) { return I.current.useContext(e); }, t.useDebugValue = function () {}, t.useDeferredValue = function (e) { return I.current.useDeferredValue(e); }, t.useEffect = function (e, t) { return I.current.useEffect(e, t); }, t.useId = function () { return I.current.useId(); }, t.useImperativeHandle = function (e, t, r) { return I.current.useImperativeHandle(e, t, r); }, t.useInsertionEffect = function (e, t) { return I.current.useInsertionEffect(e, t); }, t.useLayoutEffect = function (e, t) { return I.current.useLayoutEffect(e, t); }, t.useMemo = function (e, t) { return I.current.useMemo(e, t); }, t.useReducer = function (e, t, r) { return I.current.useReducer(e, t, r); }, t.useRef = function (e) { return I.current.useRef(e); }, t.useState = function (e) { return I.current.useState(e); }, t.useSyncExternalStore = function (e, t, r) { return I.current.useSyncExternalStore(e, t, r); }, t.useTransition = function () { return I.current.useTransition(); }, t.version = '18.2.0';
    },
    2791(e, t, r) {
      e.exports = r(9117);
    },
    184(e, t, r) {
      e.exports = r(6374);
    },
    1794(e, t, r) {
      const n = r(3731); const i = r(6750); const a = r(6639); const o = r(3126); function s(e, t, r, n) { return function (r, i, a) { const o = e(e(t(i[1], a[0]), t(-a[1], i[0])), e(t(r[1], i[0]), t(-i[1], r[0]))); const s = e(t(r[1], a[0]), t(-a[1], r[0])); const u = n(o, s); return u[u.length - 1]; }; } function u(e, t, r, n) { return function (i, a, o, s) { const u = e(e(r(e(t(o[1], s[0]), t(-s[1], o[0])), a[2]), e(r(e(t(a[1], s[0]), t(-s[1], a[0])), -o[2]), r(e(t(a[1], o[0]), t(-o[1], a[0])), s[2]))), e(r(e(t(a[1], s[0]), t(-s[1], a[0])), i[2]), e(r(e(t(i[1], s[0]), t(-s[1], i[0])), -a[2]), r(e(t(i[1], a[0]), t(-a[1], i[0])), s[2])))); const l = e(e(r(e(t(o[1], s[0]), t(-s[1], o[0])), i[2]), e(r(e(t(i[1], s[0]), t(-s[1], i[0])), -o[2]), r(e(t(i[1], o[0]), t(-o[1], i[0])), s[2]))), e(r(e(t(a[1], o[0]), t(-o[1], a[0])), i[2]), e(r(e(t(i[1], o[0]), t(-o[1], i[0])), -a[2]), r(e(t(i[1], a[0]), t(-a[1], i[0])), o[2])))); const c = n(u, l); return c[c.length - 1]; }; } function l(e, t, r, n) { return function (i, a, o, s, u) { const l = e(e(e(r(e(r(e(t(s[1], u[0]), t(-u[1], s[0])), o[2]), e(r(e(t(o[1], u[0]), t(-u[1], o[0])), -s[2]), r(e(t(o[1], s[0]), t(-s[1], o[0])), u[2]))), a[3]), e(r(e(r(e(t(s[1], u[0]), t(-u[1], s[0])), a[2]), e(r(e(t(a[1], u[0]), t(-u[1], a[0])), -s[2]), r(e(t(a[1], s[0]), t(-s[1], a[0])), u[2]))), -o[3]), r(e(r(e(t(o[1], u[0]), t(-u[1], o[0])), a[2]), e(r(e(t(a[1], u[0]), t(-u[1], a[0])), -o[2]), r(e(t(a[1], o[0]), t(-o[1], a[0])), u[2]))), s[3]))), e(r(e(r(e(t(o[1], s[0]), t(-s[1], o[0])), a[2]), e(r(e(t(a[1], s[0]), t(-s[1], a[0])), -o[2]), r(e(t(a[1], o[0]), t(-o[1], a[0])), s[2]))), -u[3]), e(r(e(r(e(t(s[1], u[0]), t(-u[1], s[0])), a[2]), e(r(e(t(a[1], u[0]), t(-u[1], a[0])), -s[2]), r(e(t(a[1], s[0]), t(-s[1], a[0])), u[2]))), i[3]), r(e(r(e(t(s[1], u[0]), t(-u[1], s[0])), i[2]), e(r(e(t(i[1], u[0]), t(-u[1], i[0])), -s[2]), r(e(t(i[1], s[0]), t(-s[1], i[0])), u[2]))), -a[3])))), e(e(r(e(r(e(t(a[1], u[0]), t(-u[1], a[0])), i[2]), e(r(e(t(i[1], u[0]), t(-u[1], i[0])), -a[2]), r(e(t(i[1], a[0]), t(-a[1], i[0])), u[2]))), s[3]), e(r(e(r(e(t(a[1], s[0]), t(-s[1], a[0])), i[2]), e(r(e(t(i[1], s[0]), t(-s[1], i[0])), -a[2]), r(e(t(i[1], a[0]), t(-a[1], i[0])), s[2]))), -u[3]), r(e(r(e(t(o[1], s[0]), t(-s[1], o[0])), a[2]), e(r(e(t(a[1], s[0]), t(-s[1], a[0])), -o[2]), r(e(t(a[1], o[0]), t(-o[1], a[0])), s[2]))), i[3]))), e(r(e(r(e(t(o[1], s[0]), t(-s[1], o[0])), i[2]), e(r(e(t(i[1], s[0]), t(-s[1], i[0])), -o[2]), r(e(t(i[1], o[0]), t(-o[1], i[0])), s[2]))), -a[3]), e(r(e(r(e(t(a[1], s[0]), t(-s[1], a[0])), i[2]), e(r(e(t(i[1], s[0]), t(-s[1], i[0])), -a[2]), r(e(t(i[1], a[0]), t(-a[1], i[0])), s[2]))), o[3]), r(e(r(e(t(a[1], o[0]), t(-o[1], a[0])), i[2]), e(r(e(t(i[1], o[0]), t(-o[1], i[0])), -a[2]), r(e(t(i[1], a[0]), t(-a[1], i[0])), o[2]))), -s[3]))))); const c = e(e(e(r(e(r(e(t(s[1], u[0]), t(-u[1], s[0])), o[2]), e(r(e(t(o[1], u[0]), t(-u[1], o[0])), -s[2]), r(e(t(o[1], s[0]), t(-s[1], o[0])), u[2]))), i[3]), r(e(r(e(t(s[1], u[0]), t(-u[1], s[0])), i[2]), e(r(e(t(i[1], u[0]), t(-u[1], i[0])), -s[2]), r(e(t(i[1], s[0]), t(-s[1], i[0])), u[2]))), -o[3])), e(r(e(r(e(t(o[1], u[0]), t(-u[1], o[0])), i[2]), e(r(e(t(i[1], u[0]), t(-u[1], i[0])), -o[2]), r(e(t(i[1], o[0]), t(-o[1], i[0])), u[2]))), s[3]), r(e(r(e(t(o[1], s[0]), t(-s[1], o[0])), i[2]), e(r(e(t(i[1], s[0]), t(-s[1], i[0])), -o[2]), r(e(t(i[1], o[0]), t(-o[1], i[0])), s[2]))), -u[3]))), e(e(r(e(r(e(t(o[1], u[0]), t(-u[1], o[0])), a[2]), e(r(e(t(a[1], u[0]), t(-u[1], a[0])), -o[2]), r(e(t(a[1], o[0]), t(-o[1], a[0])), u[2]))), i[3]), r(e(r(e(t(o[1], u[0]), t(-u[1], o[0])), i[2]), e(r(e(t(i[1], u[0]), t(-u[1], i[0])), -o[2]), r(e(t(i[1], o[0]), t(-o[1], i[0])), u[2]))), -a[3])), e(r(e(r(e(t(a[1], u[0]), t(-u[1], a[0])), i[2]), e(r(e(t(i[1], u[0]), t(-u[1], i[0])), -a[2]), r(e(t(i[1], a[0]), t(-a[1], i[0])), u[2]))), o[3]), r(e(r(e(t(a[1], o[0]), t(-o[1], a[0])), i[2]), e(r(e(t(i[1], o[0]), t(-o[1], i[0])), -a[2]), r(e(t(i[1], a[0]), t(-a[1], i[0])), o[2]))), -u[3])))); const h = n(l, c); return h[h.length - 1]; }; } function c(e) { return (e === 3 ? s : e === 4 ? u : l)(i, n, a, o); } const h = c(3); const f = c(4); const d = [function () { return 0; }, function () { return 0; }, function (e, t) { return t[0] - e[0]; }, function (e, t, r) { let n; const i = (e[1] - r[1]) * (t[0] - r[0]); const a = (e[0] - r[0]) * (t[1] - r[1]); const o = i - a; if (i > 0) { if (a <= 0) return o; n = i + a; } else { if (!(i < 0)) return o; if (a >= 0) return o; n = -(i + a); } const s = 33306690738754716e-32 * n; return o >= s || o <= -s ? o : h(e, t, r); }, function (e, t, r, n) { const i = e[0] - n[0]; const a = t[0] - n[0]; const o = r[0] - n[0]; const s = e[1] - n[1]; const u = t[1] - n[1]; const l = r[1] - n[1]; const c = e[2] - n[2]; const h = t[2] - n[2]; const d = r[2] - n[2]; const p = a * l; const m = o * u; const v = o * s; const g = i * l; const y = i * u; const b = a * s; const w = c * (p - m) + h * (v - g) + d * (y - b); const k = 7771561172376103e-31 * ((Math.abs(p) + Math.abs(m)) * Math.abs(c) + (Math.abs(v) + Math.abs(g)) * Math.abs(h) + (Math.abs(y) + Math.abs(b)) * Math.abs(d)); return w > k || -w > k ? w : f(e, t, r, n); }]; function p(e) { let t = d[e.length]; return t || (t = d[e.length] = c(e.length)), t.apply(void 0, e); } function m(e, t, r, n, i, a, o) { return function (t, r, s, u, l) { switch (arguments.length) { case 0: case 1: return 0; case 2: return n(t, r); case 3: return i(t, r, s); case 4: return a(t, r, s, u); case 5: return o(t, r, s, u, l); } for (var c = new Array(arguments.length), h = 0; h < arguments.length; ++h)c[h] = arguments[h]; return e(c); }; }!(function () { for (;d.length <= 5;)d.push(c(d.length)); e.exports = m.apply(void 0, [p].concat(d)); for (let t = 0; t <= 5; ++t)e.exports[t] = d[t]; }());
    },
    9689(e, t, r) { e.exports = function (e, t) { for (var r = t[0], i = t[1], a = e.length, o = 1, s = a, u = 0, l = a - 1; u < s; l = u++) { const c = e[u]; const h = e[l]; const f = c[1]; const d = h[1]; if (d < f) { if (d < i && i < f) { if ((p = n(c, h, t)) === 0) return 0; o ^= p > 0 | 0; } else if (i === f) { if (f < e[(u + 1) % a][1]) { if ((p = n(c, h, t)) === 0) return 0; o ^= p > 0 | 0; } } } else if (f < d) { if (f < i && i < d) { if ((p = n(c, h, t)) === 0) return 0; o ^= p < 0 | 0; } else if (i === f) { if (e[(u + 1) % a][1] < f) { var p; if ((p = n(c, h, t)) === 0) return 0; o ^= p < 0 | 0; } } } else if (i === f) { let m = Math.min(c[0], h[0]); let v = Math.max(c[0], h[0]); if (u === 0) { for (;l > 0;) { const g = (l + a - 1) % a; if ((w = e[g])[1] !== i) break; var y = w[0]; m = Math.min(m, y), v = Math.max(v, y), l = g; } if (l === 0) return m <= r && r <= v ? 0 : 1; s = l + 1; } for (var b = e[(l + a - 1) % a][1]; u + 1 < s;) { var w; if ((w = e[u + 1])[1] !== i) break; y = w[0]; m = Math.min(m, y), v = Math.max(v, y), u += 1; } if (m <= r && r <= v) return 0; const k = e[(u + 1) % a][1]; r < m && b < i !== k < i && (o ^= 1); } } return 2 * o - 1; }; var n = r(1794); },
    6639(e, t, r) {
      const n = r(3731); const i = r(1764); e.exports = function (e, t) { const r = e.length; if (r === 1) { const a = n(e[0], t); return a[0] ? a : [a[1]]; } const o = new Array(2 * r); const s = [0.1, 0.1]; const u = [0.1, 0.1]; let l = 0; n(e[0], t, s), s[0] && (o[l++] = s[0]); for (let c = 1; c < r; ++c) { n(e[c], t, u); const h = s[1]; i(h, u[0], s), s[0] && (o[l++] = s[0]); const f = u[1]; const d = s[1]; const p = f + d; const m = d - (p - f); s[1] = p, m && (o[l++] = m); }s[1] && (o[l++] = s[1]); l === 0 && (o[l++] = 0); return o.length = l, o; };
    },
    3126(e) {
      e.exports = function (e, t) { const r = 0 | e.length; const n = 0 | t.length; if (r === 1 && n === 1) return (function (e, t) { const r = e + t; const n = r - e; const i = r - n; const a = t - n; const o = e - i; const s = o + a; if (s) return [s, r]; return [r]; }(e[0], -t[0])); let i; let a; const o = new Array(r + n); let s = 0; let u = 0; let l = 0; const c = Math.abs; let h = e[u]; let f = c(h); let d = -t[l]; let p = c(d); f < p ? (a = h, (u += 1) < r && (f = c(h = e[u]))) : (a = d, (l += 1) < n && (p = c(d = -t[l]))); u < r && f < p || l >= n ? (i = h, (u += 1) < r && (f = c(h = e[u]))) : (i = d, (l += 1) < n && (p = c(d = -t[l]))); let m; let v; let g = i + a; let y = g - i; let b = a - y; let w = b; let k = g; for (;u < r && l < n;)f < p ? (i = h, (u += 1) < r && (f = c(h = e[u]))) : (i = d, (l += 1) < n && (p = c(d = -t[l]))), (b = (a = w) - (y = (g = i + a) - i)) && (o[s++] = b), w = k - ((m = k + g) - (v = m - k)) + (g - v), k = m; for (;u < r;)(b = (a = w) - (y = (g = (i = h) + a) - i)) && (o[s++] = b), w = k - ((m = k + g) - (v = m - k)) + (g - v), k = m, (u += 1) < r && (h = e[u]); for (;l < n;)(b = (a = w) - (y = (g = (i = d) + a) - i)) && (o[s++] = b), w = k - ((m = k + g) - (v = m - k)) + (g - v), k = m, (l += 1) < n && (d = -t[l]); w && (o[s++] = w); k && (o[s++] = k); s || (o[s++] = 0); return o.length = s, o; };
    },
    6750(e) {
      e.exports = function (e, t) { const r = 0 | e.length; const n = 0 | t.length; if (r === 1 && n === 1) return (function (e, t) { const r = e + t; const n = r - e; const i = r - n; const a = t - n; const o = e - i; const s = o + a; if (s) return [s, r]; return [r]; }(e[0], t[0])); let i; let a; const o = new Array(r + n); let s = 0; let u = 0; let l = 0; const c = Math.abs; let h = e[u]; let f = c(h); let d = t[l]; let p = c(d); f < p ? (a = h, (u += 1) < r && (f = c(h = e[u]))) : (a = d, (l += 1) < n && (p = c(d = t[l]))); u < r && f < p || l >= n ? (i = h, (u += 1) < r && (f = c(h = e[u]))) : (i = d, (l += 1) < n && (p = c(d = t[l]))); let m; let v; let g = i + a; let y = g - i; let b = a - y; let w = b; let k = g; for (;u < r && l < n;)f < p ? (i = h, (u += 1) < r && (f = c(h = e[u]))) : (i = d, (l += 1) < n && (p = c(d = t[l]))), (b = (a = w) - (y = (g = i + a) - i)) && (o[s++] = b), w = k - ((m = k + g) - (v = m - k)) + (g - v), k = m; for (;u < r;)(b = (a = w) - (y = (g = (i = h) + a) - i)) && (o[s++] = b), w = k - ((m = k + g) - (v = m - k)) + (g - v), k = m, (u += 1) < r && (h = e[u]); for (;l < n;)(b = (a = w) - (y = (g = (i = d) + a) - i)) && (o[s++] = b), w = k - ((m = k + g) - (v = m - k)) + (g - v), k = m, (l += 1) < n && (d = t[l]); w && (o[s++] = w); k && (o[s++] = k); s || (o[s++] = 0); return o.length = s, o; };
    },
    6813(e, t) {
      function r(e, t) { let r = e.length; e.push(t); for (;r > 0;) { const n = r - 1 >>> 1; const i = e[n]; if (!(a(i, t) > 0)) break; e[n] = t, e[r] = i, r = n; } } function n(e) { return e.length === 0 ? null : e[0]; } function i(e) { if (e.length === 0) return null; const t = e[0]; const r = e.pop(); if (r !== t) { e[0] = r; for (let n = 0, i = e.length, o = i >>> 1; n < o;) { const s = 2 * (n + 1) - 1; const u = e[s]; const l = s + 1; const c = e[l]; if (a(u, r) < 0)l < i && a(c, u) < 0 ? (e[n] = c, e[l] = r, n = l) : (e[n] = u, e[s] = r, n = s); else { if (!(l < i && a(c, r) < 0)) break; e[n] = c, e[l] = r, n = l; } } } return t; } function a(e, t) { const r = e.sortIndex - t.sortIndex; return r !== 0 ? r : e.id - t.id; } if (typeof performance === 'object' && typeof performance.now === 'function') { const o = performance; t.unstable_now = function () { return o.now(); }; } else { const s = Date; const u = s.now(); t.unstable_now = function () { return s.now() - u; }; } const l = []; const c = []; let h = 1; let f = null; let d = 3; let p = !1; let m = !1; let v = !1; const g = typeof setTimeout === 'function' ? setTimeout : null; const y = typeof clearTimeout === 'function' ? clearTimeout : null; const b = typeof setImmediate !== 'undefined' ? setImmediate : null; function w(e) { for (let t = n(c); t !== null;) { if (t.callback === null)i(c); else { if (!(t.startTime <= e)) break; i(c), t.sortIndex = t.expirationTime, r(l, t); }t = n(c); } } function k(e) { if (v = !1, w(e), !m) if (n(l) !== null)m = !0, O(x); else { const t = n(c); t !== null && D(k, t.startTime - e); } } function x(e, r) { m = !1, v && (v = !1, y(E), E = -1), p = !0; const a = d; try { for (w(r), f = n(l); f !== null && (!(f.expirationTime > r) || e && !A());) { const o = f.callback; if (typeof o === 'function') { f.callback = null, d = f.priorityLevel; const s = o(f.expirationTime <= r); r = t.unstable_now(), typeof s === 'function' ? f.callback = s : f === n(l) && i(l), w(r); } else i(l); f = n(l); } if (f !== null) var u = !0; else { const h = n(c); h !== null && D(k, h.startTime - r), u = !1; } return u; } finally { f = null, d = a, p = !1; } } typeof navigator !== 'undefined' && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling); let _; let S = !1; let M = null; var E = -1; let C = 5; let P = -1; function A() { return !(t.unstable_now() - P < C); } function T() { if (M !== null) { const e = t.unstable_now(); P = e; let r = !0; try { r = M(!0, e); } finally { r ? _() : (S = !1, M = null); } } else S = !1; } if (typeof b === 'function')_ = function () { b(T); }; else if (typeof MessageChannel !== 'undefined') {
        const R = new MessageChannel(); const
          I = R.port2; R.port1.onmessage = T, _ = function () { I.postMessage(null); };
      } else _ = function () { g(T, 0); }; function O(e) { M = e, S || (S = !0, _()); } function D(e, r) { E = g((() => { e(t.unstable_now()); }), r); }t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (e) { e.callback = null; }, t.unstable_continueExecution = function () { m || p || (m = !0, O(x)); }, t.unstable_forceFrameRate = function (e) { e < 0 || e > 125 ? console.error('forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported') : C = e > 0 ? Math.floor(1e3 / e) : 5; }, t.unstable_getCurrentPriorityLevel = function () { return d; }, t.unstable_getFirstCallbackNode = function () { return n(l); }, t.unstable_next = function (e) { switch (d) { case 1: case 2: case 3: var t = 3; break; default: t = d; } const r = d; d = t; try { return e(); } finally { d = r; } }, t.unstable_pauseExecution = function () {}, t.unstable_requestPaint = function () {}, t.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3; } const r = d; d = e; try { return t(); } finally { d = r; } }, t.unstable_scheduleCallback = function (e, i, a) {
        const o = t.unstable_now(); switch (typeof a === 'object' && a !== null ? a = typeof (a = a.delay) === 'number' && a > 0 ? o + a : o : a = o, e) { case 1: var s = -1; break; case 2: s = 250; break; case 5: s = 1073741823; break; case 4: s = 1e4; break; default: s = 5e3; } return e = {
          id: h++, callback: i, priorityLevel: e, startTime: a, expirationTime: s = a + s, sortIndex: -1,
        }, a > o ? (e.sortIndex = a, r(c, e), n(l) === null && e === n(c) && (v ? (y(E), E = -1) : v = !0, D(k, a - o))) : (e.sortIndex = s, r(l, e), m || p || (m = !0, O(x))), e;
      }, t.unstable_shouldYield = A, t.unstable_wrapCallback = function (e) { const t = d; return function () { const r = d; d = t; try { return e.apply(this, arguments); } finally { d = r; } }; };
    },
    5296(e, t, r) {
      e.exports = r(6813);
    },
    9613(e) { e.exports = function (e, t, r, n) { let i = r ? r.call(n, e, t) : void 0; if (void 0 !== i) return !!i; if (e === t) return !0; if (typeof e !== 'object' || !e || typeof t !== 'object' || !t) return !1; const a = Object.keys(e); const o = Object.keys(t); if (a.length !== o.length) return !1; for (let s = Object.prototype.hasOwnProperty.bind(t), u = 0; u < a.length; u++) { const l = a[u]; if (!s(l)) return !1; const c = e[l]; const h = t[l]; if (!1 === (i = r ? r.call(n, c, h, l) : void 0) || void 0 === i && c !== h) return !1; } return !0; }; },
    3731(e) {
      e.exports = function (e, r, n) { const i = e * r; const a = t * e; const o = a - (a - e); const s = e - o; const u = t * r; const l = u - (u - r); const c = r - l; const h = s * c - (i - o * l - s * l - o * c); if (n) return n[0] = h, n[1] = i, n; return [h, i]; }; var t = +(2 ** 27 + 1);
    },
    1764(e) {
      e.exports = function (e, t, r) { const n = e + t; const i = n - e; const a = t - i; const o = e - (n - i); if (r) return r[0] = o + a, r[1] = n, r; return [o + a, n]; };
    },
    2024(e, t, r) {
      const n = r(4704).default; const i = r(8675); const a = navigator.hardwareConcurrency || 1; Function.prototype; function o(e, t) { if (typeof e !== 'string' && typeof e !== 'function') throw new TypeError('func argument must be a function'); if (void 0 === t && (t = {}), typeof t !== 'object' || t === null) throw new TypeError('options argument must be an object'); this._workerCode = e.toString(), void 0 === t.maxWorkers || t.maxWorkers === 'auto' ? this._numWorkers = Math.min(a - 1, 1) : t.maxWorkers > 0 ? this._numWorkers = Math.min(t.maxWorkers, a) : this._numWorkers = a, this._workers = new Map(), this._timeout = t.timeout || 0, this._terminateOnError = !!t.terminateOnError; let r = t.deps; typeof r === 'string' && (r = [r]), Array.isArray(r) || (r = void 0), this._id = 0, this._terminated = !1, this._working = 0, this._waiting = [], this._init(r); }o.prototype._init = function (e) { for (var t = i.newWorkerURL(this._workerCode, e), r = 0; r < this._numWorkers; r++) { const n = new Worker(t); n.onmessage = this._onmessage.bind(this, n), n.onerror = this._onerror.bind(this, n), n.running = !1, n.id = r, this._workers.set(n, null); }URL.revokeObjectURL(t); }, o.prototype._onerror = function (e, t) { if (!this._terminated) { this._working--, e.running = !1; const r = this._workers.get(e); r && r[1](t.message), this._workers.set(e, null), this._terminateOnError ? this.terminate() : this._exec(); } }, o.prototype._onmessage = function (e, t) { if (!this._terminated) { this._working--, e.running = !1; const r = this._workers.get(e); r && r[0](t.data.data), this._workers.set(e, null), this._exec(); } }, o.prototype._exec = function () { let e; const t = n(this._workers.keys()); try { for (t.s(); !(e = t.n()).done;) { const r = e.value; if (this._working === this._numWorkers || this._waiting.length === 0) return; if (!r.running) for (let i = 0; i < this._waiting.length; i++) { const a = this._waiting[i]; if (typeof a[4] !== 'number' || a[4] === r.id) { this._waiting.splice(i, 1), r.postMessage({ action: 'exec', event: a[0], args: a[1] }, a[2]), r.running = !0, r.time = Date.now(), this._workers.set(r, a[3]), this._working++; break; } } } } catch (o) { t.e(o); } finally { t.f(); } }, o.prototype.terminate = function () { if (!this._terminated) { let e; const t = n(this._workers); try { for (t.s(); !(e = t.n()).done;) { const r = e.value; r[0].terminate(), r[1] && r[1][1](new Error('Terminated')); } } catch (i) { t.e(i); } finally { t.f(); } this._workers.clear(), this._waiting = [], this._working = 0, this._terminated = !0; } }, o.prototype.postAll = function (e, t) { if (this._terminated) throw new Error('Cannot post (terminated)'); let r; const i = []; const a = n(this._workers.keys()); try { for (a.s(); !(r = a.n()).done;) { const o = r.value; i.push(this.post(e, t, [], o.id)); } } catch (s) { a.e(s); } finally { a.f(); } return Promise.all(i); }, o.prototype.post = function (e, t, r, n) { void 0 === t && (t = []), void 0 === r && (r = []), Array.isArray(t) || (t = [t]), Array.isArray(r) || (r = [r]); const i = this; return new Promise(((a, o) => { if (i._terminated) throw new Error('Cannot post (terminated)'); i._waiting.push([e, t, r, [a, o], n]), i._exec(); })); }, e.exports = o;
    },
    8675(e, t) {
      const r = function () { self.window = self; function e() { this._listeners = {}; }e.prototype.on = function (e, t) { if (this._listeners[e]) throw new RangeError(`there is already a listener for ${e}`); if (typeof t !== 'function') throw new TypeError('callback argument must be a function'); this._listeners[e] = t; }, e.prototype._send = function (e, t, r) { void 0 === r ? r = [] : Array.isArray(r) || (r = [r]), self.postMessage({ id: e, data: t }, r); }, e.prototype._trigger = function (e, t) { if (!this._listeners[e]) throw new Error(`event ${e} is not defined`); this._listeners[e].apply(null, t); }; const t = new e(); self.onmessage = function (e) { switch (e.data.action) { case 'exec': e.data.args.unshift(((r, n) => { t._send(e.data.id, r, n); })), t._trigger(e.data.event, e.data.args); break; case 'ping': t._send(e.data.id, 'pong'); break; default: throw new Error(`unexpected action: ${e.data.action}`); } }; }.toString().split('"CODE";'); t.newWorkerURL = function (e, t) { const n = new Blob(['(', r[0], `importScripts.apply(self, ${JSON.stringify(t)});\n`, '(', e, ')();', r[1], ')();'], { type: 'application/javascript' }); return URL.createObjectURL(n); };
    },
    3897(e) { e.exports = function (e, t) { (t == null || t > e.length) && (t = e.length); for (var r = 0, n = new Array(t); r < t; r++)n[r] = e[r]; return n; }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    3405(e, t, r) { const n = r(3897); e.exports = function (e) { if (Array.isArray(e)) return n(e); }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    6115(e) { e.exports = function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    6690(e) { e.exports = function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    9728(e, t, r) { const n = r(4062); function i(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, n(i.key), i); } }e.exports = function (e, t, r) { return t && i(e.prototype, t), r && i(e, r), Object.defineProperty(e, 'prototype', { writable: !1 }), e; }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    4704(e, t, r) {
      const n = r(6116); e.exports = function (e, t) {
        let r = typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']; if (!r) {
          if (Array.isArray(e) || (r = n(e)) || t && e && typeof e.length === 'number') {
            r && (e = r); let i = 0; const a = function () {}; return {
              s: a, n() { return i >= e.length ? { done: !0 } : { done: !1, value: e[i++] }; }, e(e) { throw e; }, f: a,
            };
          } throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
        } let o; let s = !0; let u = !1; return {
          s() { r = r.call(e); }, n() { const e = r.next(); return s = e.done, e; }, e(e) { u = !0, o = e; }, f() { try { s || r.return == null || r.return(); } finally { if (u) throw o; } },
        };
      }, e.exports.__esModule = !0, e.exports.default = e.exports;
    },
    6389(e, t, r) { const n = r(3808); const i = r(9617); const a = r(4993); e.exports = function (e) { const t = i(); return function () { let r; const i = n(e); if (t) { const o = n(this).constructor; r = Reflect.construct(i, arguments, o); } else r = i.apply(this, arguments); return a(this, r); }; }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    8416(e, t, r) {
      const n = r(4062); e.exports = function (e, t, r) {
        return (t = n(t)) in e ? Object.defineProperty(e, t, {
          value: r, enumerable: !0, configurable: !0, writable: !0,
        }) : e[t] = r, e;
      }, e.exports.__esModule = !0, e.exports.default = e.exports;
    },
    3808(e) { function t(r) { return e.exports = t = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) { return e.__proto__ || Object.getPrototypeOf(e); }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r); }e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports; },
    1655(e, t, r) { const n = r(6015); e.exports = function (e, t) { if (typeof t !== 'function' && t !== null) throw new TypeError('Super expression must either be null or a function'); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, 'prototype', { writable: !1 }), t && n(e, t); }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    9617(e) { e.exports = function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (() => {}))), !0; } catch (e) { return !1; } }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    9498(e) { e.exports = function (e) { if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) return Array.from(e); }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    2281(e) { e.exports = function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    2122(e, t, r) { const n = r(8416); function i(e, t) { const r = Object.keys(e); if (Object.getOwnPropertySymbols) { let n = Object.getOwnPropertySymbols(e); t && (n = n.filter(((t) => Object.getOwnPropertyDescriptor(e, t).enumerable))), r.push.apply(r, n); } return r; }e.exports = function (e) { for (let t = 1; t < arguments.length; t++) { var r = arguments[t] != null ? arguments[t] : {}; t % 2 ? i(Object(r), !0).forEach(((t) => { n(e, t, r[t]); })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : i(Object(r)).forEach(((t) => { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t)); })); } return e; }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    4993(e, t, r) { const n = r(8698).default; const i = r(6115); e.exports = function (e, t) { if (t && (n(t) === 'object' || typeof t === 'function')) return t; if (void 0 !== t) throw new TypeError('Derived constructors may only return object or undefined'); return i(e); }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    6015(e) { function t(r, n) { return e.exports = t = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) { return e.__proto__ = t, e; }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r, n); }e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports; },
    861(e, t, r) { const n = r(3405); const i = r(9498); const a = r(6116); const o = r(2281); e.exports = function (e) { return n(e) || i(e) || a(e) || o(); }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    5036(e, t, r) { const n = r(8698).default; e.exports = function (e, t) { if (n(e) != 'object' || !e) return e; const r = e[Symbol.toPrimitive]; if (void 0 !== r) { const i = r.call(e, t || 'default'); if (n(i) != 'object') return i; throw new TypeError('@@toPrimitive must return a primitive value.'); } return (t === 'string' ? String : Number)(e); }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    4062(e, t, r) { const n = r(8698).default; const i = r(5036); e.exports = function (e) { const t = i(e, 'string'); return n(t) == 'symbol' ? t : String(t); }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    8698(e) { function t(r) { return e.exports = t = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r); }e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports; },
    6116(e, t, r) { const n = r(3897); e.exports = function (e, t) { if (e) { if (typeof e === 'string') return n(e, t); let r = Object.prototype.toString.call(e).slice(8, -1); return r === 'Object' && e.constructor && (r = e.constructor.name), r === 'Map' || r === 'Set' ? Array.from(e) : r === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? n(e, t) : void 0; } }, e.exports.__esModule = !0, e.exports.default = e.exports; },
    5671(e, t, r) {
      function n(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }r.d(t, { Z() { return n; } });
    },
    3144(e, t, r) {
      r.d(t, { Z() { return a; } }); const n = r(9142); function i(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, (0, n.Z)(i.key), i); } } function a(e, t, r) { return t && i(e.prototype, t), r && i(e, r), Object.defineProperty(e, 'prototype', { writable: !1 }), e; }
    },
    9142(e, t, r) {
      r.d(t, { Z() { return i; } }); const n = r(1002); function i(e) { const t = (function (e, t) { if ((0, n.Z)(e) != 'object' || !e) return e; const r = e[Symbol.toPrimitive]; if (void 0 !== r) { const i = r.call(e, t || 'default'); if ((0, n.Z)(i) != 'object') return i; throw new TypeError('@@toPrimitive must return a primitive value.'); } return (t === 'string' ? String : Number)(e); }(e, 'string')); return (0, n.Z)(t) == 'symbol' ? t : String(t); }
    },
    1002(e, t, r) {
      function n(e) { return n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }, n(e); }r.d(t, { Z() { return n; } });
    },
    2898(e) {
      e.exports = { version: '1.0.1' };
    },
  }; const __webpack_module_cache__ = {}; function __webpack_require__(e) { const t = __webpack_module_cache__[e]; if (void 0 !== t) return t.exports; const r = __webpack_module_cache__[e] = { exports: {} }; return __webpack_modules__[e].call(r.exports, r, r.exports, __webpack_require__), r.exports; }__webpack_require__.n = function (e) { const t = e && e.__esModule ? function () { return e.default; } : function () { return e; }; return __webpack_require__.d(t, { a: t }), t; }, (function () { let e; const t = Object.getPrototypeOf ? function (e) { return Object.getPrototypeOf(e); } : function (e) { return e.__proto__; }; __webpack_require__.t = function (r, n) { if (1 & n && (r = this(r)), 8 & n) return r; if (typeof r === 'object' && r) { if (4 & n && r.__esModule) return r; if (16 & n && typeof r.then === 'function') return r; } const i = Object.create(null); __webpack_require__.r(i); const a = {}; e = e || [null, t({}), t([]), t(t)]; for (let o = 2 & n && r; typeof o === 'object' && !~e.indexOf(o); o = t(o))Object.getOwnPropertyNames(o).forEach(((e) => { a[e] = function () { return r[e]; }; })); return a.default = function () { return r; }, __webpack_require__.d(i, a), i; }; }()), __webpack_require__.d = function (e, t) { for (const r in t)__webpack_require__.o(t, r) && !__webpack_require__.o(e, r) && Object.defineProperty(e, r, { enumerable: !0, get: t[r] }); }, __webpack_require__.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t); }, __webpack_require__.r = function (e) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(e, '__esModule', { value: !0 }); }, __webpack_require__.p = '/', __webpack_require__.nc = void 0; const __webpack_exports__ = {}; !(function () {
    const e = {}; __webpack_require__.r(e), __webpack_require__.d(e, {
      CMYK() { return yb; }, GREY() { return pb; }, HSL() { return vb; }, HSV() { return gb; }, RGB() { return mb; },
    }); const t = {}; __webpack_require__.r(t), __webpack_require__.d(t, { tagsById() { return Eb; }, tagsByName() { return Cb; } }); const r = {}; __webpack_require__.r(r), __webpack_require__.d(r, { tagsById() { return Ab; }, tagsByName() { return Tb; } }); const n = {}; __webpack_require__.r(n), __webpack_require__.d(n, { tagsById() { return Ib; }, tagsByName() { return Ob; } }); const i = __webpack_require__(2791); const a = __webpack_require__.t(i, 2); const o = __webpack_require__(1250); const s = (__webpack_require__.p, __webpack_require__(1002)); function u() {
      u = function () { return t; }; let e; var t = {}; const r = Object.prototype; const n = r.hasOwnProperty; const i = Object.defineProperty || function (e, t, r) { e[t] = r.value; }; const a = typeof Symbol === 'function' ? Symbol : {}; const o = a.iterator || '@@iterator'; const l = a.asyncIterator || '@@asyncIterator'; const c = a.toStringTag || '@@toStringTag'; function h(e, t, r) {
        return Object.defineProperty(e, t, {
          value: r, enumerable: !0, configurable: !0, writable: !0,
        }), e[t];
      } try { h({}, ''); } catch (e) { h = function (e, t, r) { return e[t] = r; }; } function f(e, t, r, n) { const a = t && t.prototype instanceof b ? t : b; const o = Object.create(a.prototype); const s = new I(n || []); return i(o, '_invoke', { value: P(e, r, s) }), o; } function d(e, t, r) { try { return { type: 'normal', arg: e.call(t, r) }; } catch (e) { return { type: 'throw', arg: e }; } }t.wrap = f; const p = 'suspendedStart'; const m = 'suspendedYield'; const v = 'executing'; const g = 'completed'; const y = {}; function b() {} function w() {} function k() {} let x = {}; h(x, o, (function () { return this; })); const _ = Object.getPrototypeOf; const S = _ && _(_(O([]))); S && S !== r && n.call(S, o) && (x = S); const M = k.prototype = b.prototype = Object.create(x); function E(e) { ['next', 'throw', 'return'].forEach(((t) => { h(e, t, (function (e) { return this._invoke(t, e); })); })); } function C(e, t) { function r(i, a, o, u) { const l = d(e[i], e, a); if (l.type !== 'throw') { const c = l.arg; const h = c.value; return h && (0, s.Z)(h) == 'object' && n.call(h, '__await') ? t.resolve(h.__await).then(((e) => { r('next', e, o, u); }), ((e) => { r('throw', e, o, u); })) : t.resolve(h).then(((e) => { c.value = e, o(c); }), ((e) => r('throw', e, o, u))); }u(l.arg); } let a; i(this, '_invoke', { value(e, n) { function i() { return new t(((t, i) => { r(e, n, t, i); })); } return a = a ? a.then(i, i) : i(); } }); } function P(t, r, n) { let i = p; return function (a, o) { if (i === v) throw new Error('Generator is already running'); if (i === g) { if (a === 'throw') throw o; return { value: e, done: !0 }; } for (n.method = a, n.arg = o; ;) { const s = n.delegate; if (s) { const u = A(s, n); if (u) { if (u === y) continue; return u; } } if (n.method === 'next')n.sent = n._sent = n.arg; else if (n.method === 'throw') { if (i === p) throw i = g, n.arg; n.dispatchException(n.arg); } else n.method === 'return' && n.abrupt('return', n.arg); i = v; const l = d(t, r, n); if (l.type === 'normal') { if (i = n.done ? g : m, l.arg === y) continue; return { value: l.arg, done: n.done }; }l.type === 'throw' && (i = g, n.method = 'throw', n.arg = l.arg); } }; } function A(t, r) { const n = r.method; const i = t.iterator[n]; if (i === e) return r.delegate = null, n === 'throw' && t.iterator.return && (r.method = 'return', r.arg = e, A(t, r), r.method === 'throw') || n !== 'return' && (r.method = 'throw', r.arg = new TypeError(`The iterator does not provide a '${n}' method`)), y; const a = d(i, t.iterator, r.arg); if (a.type === 'throw') return r.method = 'throw', r.arg = a.arg, r.delegate = null, y; const o = a.arg; return o ? o.done ? (r[t.resultName] = o.value, r.next = t.nextLoc, r.method !== 'return' && (r.method = 'next', r.arg = e), r.delegate = null, y) : o : (r.method = 'throw', r.arg = new TypeError('iterator result is not an object'), r.delegate = null, y); } function T(e) { const t = { tryLoc: e[0] }; 1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t); } function R(e) { const t = e.completion || {}; t.type = 'normal', delete t.arg, e.completion = t; } function I(e) { this.tryEntries = [{ tryLoc: 'root' }], e.forEach(T, this), this.reset(!0); } function O(t) { if (t || t === '') { const r = t[o]; if (r) return r.call(t); if (typeof t.next === 'function') return t; if (!isNaN(t.length)) { let i = -1; const a = function r() { for (;++i < t.length;) if (n.call(t, i)) return r.value = t[i], r.done = !1, r; return r.value = e, r.done = !0, r; }; return a.next = a; } } throw new TypeError(`${(0, s.Z)(t)} is not iterable`); } return w.prototype = k, i(M, 'constructor', { value: k, configurable: !0 }), i(k, 'constructor', { value: w, configurable: !0 }), w.displayName = h(k, c, 'GeneratorFunction'), t.isGeneratorFunction = function (e) { const t = typeof e === 'function' && e.constructor; return !!t && (t === w || (t.displayName || t.name) === 'GeneratorFunction'); }, t.mark = function (e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, k) : (e.__proto__ = k, h(e, c, 'GeneratorFunction')), e.prototype = Object.create(M), e; }, t.awrap = function (e) { return { __await: e }; }, E(C.prototype), h(C.prototype, l, (function () { return this; })), t.AsyncIterator = C, t.async = function (e, r, n, i, a) { void 0 === a && (a = Promise); const o = new C(f(e, r, n, i), a); return t.isGeneratorFunction(r) ? o : o.next().then(((e) => (e.done ? e.value : o.next()))); }, E(M), h(M, c, 'Generator'), h(M, o, (function () { return this; })), h(M, 'toString', (() => '[object Generator]')), t.keys = function (e) { const t = Object(e); const r = []; for (const n in t)r.push(n); return r.reverse(), function e() { for (;r.length;) { const n = r.pop(); if (n in t) return e.value = n, e.done = !1, e; } return e.done = !0, e; }; }, t.values = O, I.prototype = {
        constructor: I, reset(t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = 'next', this.arg = e, this.tryEntries.forEach(R), !t) for (const r in this)r.charAt(0) === 't' && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = e); }, stop() { this.done = !0; const e = this.tryEntries[0].completion; if (e.type === 'throw') throw e.arg; return this.rval; }, dispatchException(t) { if (this.done) throw t; const r = this; function i(n, i) { return s.type = 'throw', s.arg = t, r.next = n, i && (r.method = 'next', r.arg = e), !!i; } for (let a = this.tryEntries.length - 1; a >= 0; --a) { const o = this.tryEntries[a]; var s = o.completion; if (o.tryLoc === 'root') return i('end'); if (o.tryLoc <= this.prev) { const u = n.call(o, 'catchLoc'); const l = n.call(o, 'finallyLoc'); if (u && l) { if (this.prev < o.catchLoc) return i(o.catchLoc, !0); if (this.prev < o.finallyLoc) return i(o.finallyLoc); } else if (u) { if (this.prev < o.catchLoc) return i(o.catchLoc, !0); } else { if (!l) throw new Error('try statement without catch or finally'); if (this.prev < o.finallyLoc) return i(o.finallyLoc); } } } }, abrupt(e, t) { for (let r = this.tryEntries.length - 1; r >= 0; --r) { const i = this.tryEntries[r]; if (i.tryLoc <= this.prev && n.call(i, 'finallyLoc') && this.prev < i.finallyLoc) { var a = i; break; } }a && (e === 'break' || e === 'continue') && a.tryLoc <= t && t <= a.finallyLoc && (a = null); const o = a ? a.completion : {}; return o.type = e, o.arg = t, a ? (this.method = 'next', this.next = a.finallyLoc, y) : this.complete(o); }, complete(e, t) { if (e.type === 'throw') throw e.arg; return e.type === 'break' || e.type === 'continue' ? this.next = e.arg : e.type === 'return' ? (this.rval = this.arg = e.arg, this.method = 'return', this.next = 'end') : e.type === 'normal' && t && (this.next = t), y; }, finish(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const r = this.tryEntries[t]; if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), R(r), y; } }, catch(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const r = this.tryEntries[t]; if (r.tryLoc === e) { const n = r.completion; if (n.type === 'throw') { var i = n.arg; R(r); } return i; } } throw new Error('illegal catch attempt'); }, delegateYield(t, r, n) { return this.delegate = { iterator: O(t), resultName: r, nextLoc: n }, this.method === 'next' && (this.arg = e), y; },
      }, t;
    } function l(e, t, r, n, i, a, o) { try { var s = e[a](o); var u = s.value; } catch (l) { return void r(l); }s.done ? t(u) : Promise.resolve(u).then(n, i); } function c(e) { return function () { const t = this; const r = arguments; return new Promise(((n, i) => { const a = e.apply(t, r); function o(e) { l(a, n, i, o, s, 'next', e); } function s(e) { l(a, n, i, o, s, 'throw', e); }o(void 0); })); }; } function h(e, t) { (t == null || t > e.length) && (t = e.length); for (var r = 0, n = new Array(t); r < t; r++)n[r] = e[r]; return n; } function f(e, t) { if (e) { if (typeof e === 'string') return h(e, t); let r = Object.prototype.toString.call(e).slice(8, -1); return r === 'Object' && e.constructor && (r = e.constructor.name), r === 'Map' || r === 'Set' ? Array.from(e) : r === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? h(e, t) : void 0; } } function d(e, t) { return (function (e) { if (Array.isArray(e)) return e; }(e)) || (function (e, t) { let r = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']; if (r != null) { let n; let i; let a; let o; const s = []; let u = !0; let l = !1; try { if (a = (r = r.call(e)).next, t === 0) { if (Object(r) !== r) return; u = !1; } else for (;!(u = (n = a.call(r)).done) && (s.push(n.value), s.length !== t); u = !0); } catch (e) { l = !0, i = e; } finally { try { if (!u && r.return != null && (o = r.return(), Object(o) !== o)) return; } finally { if (l) throw i; } } return s; } }(e, t)) || f(e, t) || (function () { throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function p(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })); } function m(e, t) { if (e == null) return {}; let r; let n; const i = {}; const a = Object.keys(e); for (n = 0; n < a.length; n++)r = a[n], t.indexOf(r) >= 0 || (i[r] = e[r]); return i; } function v(e, t) { if (e == null) return {}; let r; let n; const i = m(e, t); if (Object.getOwnPropertySymbols) { const a = Object.getOwnPropertySymbols(e); for (n = 0; n < a.length; n++)r = a[n], t.indexOf(r) >= 0 || Object.prototype.propertyIsEnumerable.call(e, r) && (i[r] = e[r]); } return i; } const g = __webpack_require__(97); const y = __webpack_require__.n(g); const b = __webpack_require__(3144); const w = __webpack_require__(5671); function k(e, t) { return k = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) { return e.__proto__ = t, e; }, k(e, t); } function x(e, t) { if (typeof t !== 'function' && t !== null) throw new TypeError('Super expression must either be null or a function'); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, 'prototype', { writable: !1 }), t && k(e, t); } function _(e) { return _ = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) { return e.__proto__ || Object.getPrototypeOf(e); }, _(e); } function S() { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (() => {}))), !0; } catch (e) { return !1; } } function M(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; } function E(e, t) { if (t && ((0, s.Z)(t) === 'object' || typeof t === 'function')) return t; if (void 0 !== t) throw new TypeError('Derived constructors may only return object or undefined'); return M(e); } function C(e) { const t = S(); return function () { let r; const n = _(e); if (t) { const i = _(this).constructor; r = Reflect.construct(n, arguments, i); } else r = n.apply(this, arguments); return E(this, r); }; } function P(e) { return (function (e) { if (Array.isArray(e)) return h(e); }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) return Array.from(e); }(e)) || f(e) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function A() { return A = typeof Reflect !== 'undefined' && Reflect.get ? Reflect.get.bind() : function (e, t, r) { const n = (function (e, t) { for (;!Object.prototype.hasOwnProperty.call(e, t) && (e = _(e)) !== null;);return e; }(e, t)); if (n) { const i = Object.getOwnPropertyDescriptor(n, t); return i.get ? i.get.call(arguments.length < 3 ? e : r) : i.value; } }, A.apply(this, arguments); } function T(e, t, r) { return T = S() ? Reflect.construct.bind() : function (e, t, r) { const n = [null]; n.push.apply(n, t); const i = new (Function.bind.apply(e, n))(); return r && k(i, r.prototype), i; }, T.apply(null, arguments); } function R(e) {
      const t = typeof Map === 'function' ? new Map() : void 0; return R = function (e) {
        if (e === null || !(function (e) { try { return Function.toString.call(e).indexOf('[native code]') !== -1; } catch (t) { return typeof e === 'function'; } }(e))) return e; if (typeof e !== 'function') throw new TypeError('Super expression must either be null or a function'); if (typeof t !== 'undefined') { if (t.has(e)) return t.get(e); t.set(e, r); } function r() { return T(e, arguments, _(this).constructor); } return r.prototype = Object.create(e.prototype, {
          constructor: {
            value: r, enumerable: !1, writable: !0, configurable: !0,
          },
        }), k(r, e);
      }, R(e);
    } const I = __webpack_require__(9142); function O(e, t, r) {
      return (t = (0, I.Z)(t)) in e ? Object.defineProperty(e, t, {
        value: r, enumerable: !0, configurable: !0, writable: !0,
      }) : e[t] = r, e;
    } function D(e, t) { const r = Object.keys(e); if (Object.getOwnPropertySymbols) { let n = Object.getOwnPropertySymbols(e); t && (n = n.filter(((t) => Object.getOwnPropertyDescriptor(e, t).enumerable))), r.push.apply(r, n); } return r; } function z(e) { for (let t = 1; t < arguments.length; t++) { var r = arguments[t] != null ? arguments[t] : {}; t % 2 ? D(Object(r), !0).forEach(((t) => { O(e, t, r[t]); })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : D(Object(r)).forEach(((t) => { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t)); })); } return e; } function N(e, t) {
      let r = typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']; if (!r) {
        if (Array.isArray(e) || (r = f(e)) || t && e && typeof e.length === 'number') {
          r && (e = r); let n = 0; const i = function () {}; return {
            s: i, n() { return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] }; }, e(e) { throw e; }, f: i,
          };
        } throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
      } let a; let o = !0; let s = !1; return {
        s() { r = r.call(e); }, n() { const e = r.next(); return o = e.done, e; }, e(e) { s = !0, a = e; }, f() { try { o || r.return == null || r.return(); } finally { if (s) throw a; } },
      };
    } const L = Object.defineProperty; const j = {}; !(function (e, t) { for (const r in t)L(e, r, { get: t[r], enumerable: !0 }); }(j, {
      assign() { return ge; }, colors() { return pe; }, createStringInterpolator() { return ce; }, skipAnimation() { return me; }, to() { return he; }, willAdvance() { return ve; },
    })); const F = te(); const B = function (e) { return K(e, F); }; const U = te(); B.write = function (e) { return K(e, U); }; const V = te(); B.onStart = function (e) { return K(e, V); }; const Y = te(); B.onFrame = function (e) { return K(e, Y); }; const H = te(); B.onFinish = function (e) { return K(e, H); }; const q = []; B.setTimeout = function (e, t) { const r = B.now() + t; const n = { time: r, handler: e, cancel: function e() { const t = q.findIndex(((t) => t.cancel == e)); ~t && q.splice(t, 1), $ -= ~t ? 1 : 0; } }; return q.splice(W(r), 0, n), $ += 1, Q(), n; }; var W = function (e) { return ~(~q.findIndex(((t) => t.time > e)) || ~q.length); }; B.cancel = function (e) { V.delete(e), Y.delete(e), H.delete(e), F.delete(e), U.delete(e); }, B.sync = function (e) { Z = !0, B.batchedUpdates(e), Z = !1; }, B.throttle = function (e) { let t; function r() { try { e.apply(void 0, P(t)); } finally { t = null; } } function n() { for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++)n[i] = arguments[i]; t = n, B.onStart(r); } return n.handler = e, n.cancel = function () { V.delete(r), t = null; }, n; }; let X = typeof window !== 'undefined' ? window.requestAnimationFrame : function () {}; B.use = function (e) { return X = e; }, B.now = typeof performance !== 'undefined' ? function () { return performance.now(); } : Date.now, B.batchedUpdates = function (e) { return e(); }, B.catch = console.error, B.frameLoop = 'always', B.advance = function () { B.frameLoop !== 'demand' ? console.warn('Cannot call the manual advancement of rafz whilst frameLoop is not set as demand') : ee(); }; let G = -1; var $ = 0; var Z = !1; function K(e, t) { Z ? (t.delete(e), e(0)) : (t.add(e), Q()); } function Q() { G < 0 && (G = 0, B.frameLoop !== 'demand' && X(J)); } function J() { ~G && (X(J), B.batchedUpdates(ee)); } function ee() { const e = G; G = B.now(); const t = W(G); t && (re(q.splice(0, t), ((e) => e.handler())), $ -= t), $ ? (V.flush(), F.flush(e ? Math.min(64, G - e) : 16.667), Y.flush(), U.flush(), H.flush()) : G = -1; } function te() {
      let e = new Set(); let
        t = e; return { add(r) { $ += t != e || e.has(r) ? 0 : 1, e.add(r); }, delete(r) { return $ -= t == e && e.has(r) ? 1 : 0, e.delete(r); }, flush(r) { t.size && (e = new Set(), $ -= t.size, re(t, ((t) => t(r) && e.add(t))), $ += e.size, t = e); } };
    } function re(e, t) { e.forEach(((e) => { try { t(e); } catch (r) { B.catch(r); } })); } function ne() {} const ie = {
      arr: Array.isArray, obj(e) { return !!e && e.constructor.name === 'Object'; }, fun(e) { return typeof e === 'function'; }, str(e) { return typeof e === 'string'; }, num(e) { return typeof e === 'number'; }, und(e) { return void 0 === e; },
    }; function ae(e, t) { if (ie.arr(e)) { if (!ie.arr(t) || e.length !== t.length) return !1; for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1; return !0; } return e === t; } const oe = function (e, t) { return e.forEach(t); }; function se(e, t, r) { if (ie.arr(e)) for (let n = 0; n < e.length; n++)t.call(r, e[n], ''.concat(n)); else for (const i in e)e.hasOwnProperty(i) && t.call(r, e[i], i); } const ue = function (e) { return ie.und(e) ? [] : ie.arr(e) ? e : [e]; }; function le(e, t) { if (e.size) { const r = Array.from(e); e.clear(), oe(r, t); } } let ce; let he; const fe = function (e) { for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)r[n - 1] = arguments[n]; return le(e, ((e) => e.apply(void 0, r))); }; const de = function () { return typeof window === 'undefined' || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent); }; var pe = null; var me = !1; var ve = ne; var ge = function (e) { e.to && (he = e.to), e.now && (B.now = e.now), void 0 !== e.colors && (pe = e.colors), e.skipAnimation != null && (me = e.skipAnimation), e.createStringInterpolator && (ce = e.createStringInterpolator), e.requestAnimationFrame && B.use(e.requestAnimationFrame), e.batchedUpdates && (B.batchedUpdates = e.batchedUpdates), e.willAdvance && (ve = e.willAdvance), e.frameLoop && (B.frameLoop = e.frameLoop); }; const ye = new Set(); let be = []; let we = []; let ke = 0; var xe = {
      get idle() { return !ye.size && !be.length; }, start(e) { ke > e.priority ? (ye.add(e), B.onStart(_e)) : (Se(e), B(Ee)); }, advance: Ee, sort(e) { if (ke)B.onFrame((() => xe.sort(e))); else { const t = be.indexOf(e); ~t && (be.splice(t, 1), Me(e)); } }, clear() { be = [], ye.clear(); },
    }; function _e() { ye.forEach(Se), ye.clear(), B(Ee); } function Se(e) { be.includes(e) || Me(e); } function Me(e) { be.splice((function (e, t) { const r = e.findIndex(t); return r < 0 ? e.length : r; }(be, ((t) => t.priority > e.priority))), 0, e); } function Ee(e) { for (var t = we, r = 0; r < be.length; r++) { const n = be[r]; ke = n.priority, n.idle || (ve(n), n.advance(e), n.idle || t.push(n)); } return ke = 0, (we = be).length = 0, (be = t).length > 0; } const Ce = '[-+]?\\d*\\.?\\d+'; const Pe = `${Ce}%`; function Ae() { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return `\\(\\s*(${t.join(')\\s*,\\s*(')})\\s*\\)`; } const Te = new RegExp(`rgb${Ae(Ce, Ce, Ce)}`); const Re = new RegExp(`rgba${Ae(Ce, Ce, Ce, Ce)}`); const Ie = new RegExp(`hsl${Ae(Ce, Pe, Pe)}`); const Oe = new RegExp(`hsla${Ae(Ce, Pe, Pe, Ce)}`); const De = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/; const ze = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/; const Ne = /^#([0-9a-fA-F]{6})$/; const Le = /^#([0-9a-fA-F]{8})$/; function je(e, t, r) { return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + 6 * (t - e) * r : r < 0.5 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e; } function Fe(e, t, r) { const n = r < 0.5 ? r * (1 + t) : r + t - r * t; const i = 2 * r - n; const a = je(i, n, e + 1 / 3); const o = je(i, n, e); const s = je(i, n, e - 1 / 3); return Math.round(255 * a) << 24 | Math.round(255 * o) << 16 | Math.round(255 * s) << 8; } function Be(e) { const t = parseInt(e, 10); return t < 0 ? 0 : t > 255 ? 255 : t; } function Ue(e) { return (parseFloat(e) % 360 + 360) % 360 / 360; } function Ve(e) { const t = parseFloat(e); return t < 0 ? 0 : t > 1 ? 255 : Math.round(255 * t); } function Ye(e) { const t = parseFloat(e); return t < 0 ? 0 : t > 100 ? 1 : t / 100; } function He(e) { let t = (function (e) { let t; return typeof e === 'number' ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = Ne.exec(e)) ? parseInt(`${t[1]}ff`, 16) >>> 0 : pe && void 0 !== pe[e] ? pe[e] : (t = Te.exec(e)) ? (Be(t[1]) << 24 | Be(t[2]) << 16 | Be(t[3]) << 8 | 255) >>> 0 : (t = Re.exec(e)) ? (Be(t[1]) << 24 | Be(t[2]) << 16 | Be(t[3]) << 8 | Ve(t[4])) >>> 0 : (t = De.exec(e)) ? parseInt(`${t[1] + t[1] + t[2] + t[2] + t[3] + t[3]}ff`, 16) >>> 0 : (t = Le.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = ze.exec(e)) ? parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + t[4] + t[4], 16) >>> 0 : (t = Ie.exec(e)) ? (255 | Fe(Ue(t[1]), Ye(t[2]), Ye(t[3]))) >>> 0 : (t = Oe.exec(e)) ? (Fe(Ue(t[1]), Ye(t[2]), Ye(t[3])) | Ve(t[4])) >>> 0 : null; }(e)); if (t === null) return e; const r = (16711680 & (t = t || 0)) >>> 16; const n = (65280 & t) >>> 8; const i = (255 & t) / 255; return 'rgba('.concat((4278190080 & t) >>> 24, ', ').concat(r, ', ').concat(n, ', ').concat(i, ')'); } const qe = function e(t, r, n) { if (ie.fun(t)) return t; if (ie.arr(t)) return e({ range: t, output: r, extrapolate: n }); if (ie.str(t.output[0])) return ce(t); const i = t; const a = i.output; const o = i.range || [0, 1]; const s = i.extrapolateLeft || i.extrapolate || 'extend'; const u = i.extrapolateRight || i.extrapolate || 'extend'; const l = i.easing || function (e) { return e; }; return function (e) { const t = (function (e, t) { for (var r = 1; r < t.length - 1 && !(t[r] >= e); ++r);return r - 1; }(e, o)); return (function (e, t, r, n, i, a, o, s, u) { let l = u ? u(e) : e; if (l < t) { if (o === 'identity') return l; o === 'clamp' && (l = t); } if (l > r) { if (s === 'identity') return l; s === 'clamp' && (l = r); } if (n === i) return n; if (t === r) return e <= t ? n : i; t === -1 / 0 ? l = -l : r === 1 / 0 ? l -= t : l = (l - t) / (r - t); l = a(l), n === -1 / 0 ? l = -l : i === 1 / 0 ? l += n : l = l * (i - n) + n; return l; }(e, o[t], o[t + 1], a[t], a[t + 1], l, s, u, i.map)); }; }; const We = 1.70158; const Xe = 1.525 * We; const Ge = We + 1; const $e = 2 * Math.PI / 3; const Ze = 2 * Math.PI / 4.5; const Ke = function (e) { const t = 7.5625; const r = 2.75; return e < 1 / r ? t * e * e : e < 2 / r ? t * (e -= 1.5 / r) * e + 0.75 : e < 2.5 / r ? t * (e -= 2.25 / r) * e + 0.9375 : t * (e -= 2.625 / r) * e + 0.984375; }; const Qe = {
      linear(e) { return e; }, easeInQuad(e) { return e * e; }, easeOutQuad(e) { return 1 - (1 - e) * (1 - e); }, easeInOutQuad(e) { return e < 0.5 ? 2 * e * e : 1 - (-2 * e + 2) ** 2 / 2; }, easeInCubic(e) { return e * e * e; }, easeOutCubic(e) { return 1 - (1 - e) ** 3; }, easeInOutCubic(e) { return e < 0.5 ? 4 * e * e * e : 1 - (-2 * e + 2) ** 3 / 2; }, easeInQuart(e) { return e * e * e * e; }, easeOutQuart(e) { return 1 - (1 - e) ** 4; }, easeInOutQuart(e) { return e < 0.5 ? 8 * e * e * e * e : 1 - (-2 * e + 2) ** 4 / 2; }, easeInQuint(e) { return e * e * e * e * e; }, easeOutQuint(e) { return 1 - (1 - e) ** 5; }, easeInOutQuint(e) { return e < 0.5 ? 16 * e * e * e * e * e : 1 - (-2 * e + 2) ** 5 / 2; }, easeInSine(e) { return 1 - Math.cos(e * Math.PI / 2); }, easeOutSine(e) { return Math.sin(e * Math.PI / 2); }, easeInOutSine(e) { return -(Math.cos(Math.PI * e) - 1) / 2; }, easeInExpo(e) { return e === 0 ? 0 : 2 ** (10 * e - 10); }, easeOutExpo(e) { return e === 1 ? 1 : 1 - 2 ** (-10 * e); }, easeInOutExpo(e) { return e === 0 ? 0 : e === 1 ? 1 : e < 0.5 ? 2 ** (20 * e - 10) / 2 : (2 - 2 ** (-20 * e + 10)) / 2; }, easeInCirc(e) { return 1 - Math.sqrt(1 - e ** 2); }, easeOutCirc(e) { return Math.sqrt(1 - (e - 1) ** 2); }, easeInOutCirc(e) { return e < 0.5 ? (1 - Math.sqrt(1 - (2 * e) ** 2)) / 2 : (Math.sqrt(1 - (-2 * e + 2) ** 2) + 1) / 2; }, easeInBack(e) { return Ge * e * e * e - We * e * e; }, easeOutBack(e) { return 1 + Ge * (e - 1) ** 3 + We * (e - 1) ** 2; }, easeInOutBack(e) { return e < 0.5 ? (2 * e) ** 2 * (7.189819 * e - Xe) / 2 : ((2 * e - 2) ** 2 * ((Xe + 1) * (2 * e - 2) + Xe) + 2) / 2; }, easeInElastic(e) { return e === 0 ? 0 : e === 1 ? 1 : -(2 ** (10 * e - 10)) * Math.sin((10 * e - 10.75) * $e); }, easeOutElastic(e) { return e === 0 ? 0 : e === 1 ? 1 : 2 ** (-10 * e) * Math.sin((10 * e - 0.75) * $e) + 1; }, easeInOutElastic(e) { return e === 0 ? 0 : e === 1 ? 1 : e < 0.5 ? -(2 ** (20 * e - 10)) * Math.sin((20 * e - 11.125) * Ze) / 2 : 2 ** (-20 * e + 10) * Math.sin((20 * e - 11.125) * Ze) / 2 + 1; }, easeInBounce(e) { return 1 - Ke(1 - e); }, easeOutBounce: Ke, easeInOutBounce(e) { return e < 0.5 ? (1 - Ke(1 - 2 * e)) / 2 : (1 + Ke(2 * e - 1)) / 2; }, steps(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'end'; return function (r) { const n = (r = t === 'end' ? Math.min(r, 0.999) : Math.max(r, 0.001)) * e; return (function (e, t, r) { return Math.min(Math.max(r, e), t); }(0, 1, (t === 'end' ? Math.floor(n) : Math.ceil(n)) / e)); }; },
    }; const Je = Symbol.for('FluidValue.get'); const et = Symbol.for('FluidValue.observers'); const tt = function (e) { return Boolean(e && e[Je]); }; const rt = function (e) { return e && e[Je] ? e[Je]() : e; }; const nt = function (e) { return e[et] || null; }; function it(e, t) { const r = e[et]; r && r.forEach(((e) => { !(function (e, t) { e.eventObserved ? e.eventObserved(t) : e(t); }(e, t)); })); } const at = (0, b.Z)((function e(t) { if ((0, w.Z)(this, e), !t && !(t = this.get)) throw Error('Unknown getter'); ot(this, t); })); var ot = function (e, t) { return ct(e, Je, t); }; function st(e, t) { if (e[Je]) { let r = e[et]; r || ct(e, et, r = new Set()), r.has(t) || (r.add(t), e.observerAdded && e.observerAdded(r.size, t)); } return t; } function ut(e, t) { const r = e[et]; if (r && r.has(t)) { const n = r.size - 1; n ? r.delete(t) : e[et] = null, e.observerRemoved && e.observerRemoved(n, t); } } let lt; var ct = function (e, t, r) { return Object.defineProperty(e, t, { value: r, writable: !0, configurable: !0 }); }; const ht = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g; const ft = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi; const dt = new RegExp('('.concat(ht.source, ')(%|[a-z]+)'), 'i'); const pt = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi; const mt = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/; const vt = function e(t) { const r = d(gt(t), 2); const n = r[0]; const i = r[1]; if (!n || de()) return t; const a = window.getComputedStyle(document.documentElement).getPropertyValue(n); if (a) return a.trim(); if (i && i.startsWith('--')) { const o = window.getComputedStyle(document.documentElement).getPropertyValue(i); return o || t; } return i && mt.test(i) ? e(i) : i || t; }; var gt = function (e) { const t = mt.exec(e); if (!t) return [,]; const r = d(t, 3); return [r[1], r[2]]; }; const yt = function (e, t, r, n, i) { return 'rgba('.concat(Math.round(t), ', ').concat(Math.round(r), ', ').concat(Math.round(n), ', ').concat(i, ')'); }; const bt = function (e) { lt || (lt = pe ? new RegExp('('.concat(Object.keys(pe).join('|'), ')(?!\\w)'), 'g') : /^\b$/); const t = e.output.map(((e) => rt(e).replace(mt, vt).replace(ft, He).replace(lt, He))); const r = t.map(((e) => e.match(ht).map(Number))); const n = r[0].map(((e, t) => r.map(((e) => { if (!(t in e)) throw Error('The arity of each "output" value must be equal'); return e[t]; })))); const i = n.map(((t) => qe(z(z({}, e), {}, { output: t })))); return function (e) { let r; const n = !dt.test(t[0]) && ((r = t.find(((e) => dt.test(e)))) === null || void 0 === r ? void 0 : r.replace(ht, '')); let a = 0; return t[0].replace(ht, (() => ''.concat(i[a++](e)).concat(n || ''))).replace(pt, yt); }; }; const wt = 'react-spring: '; const kt = function (e) { const t = e; let r = !1; if (typeof t !== 'function') throw new TypeError(''.concat(wt, 'once requires a function parameter')); return function () { r || (t.apply(void 0, arguments), r = !0); }; }; const xt = kt(console.warn); const _t = kt(console.warn); function St(e) { return ie.str(e) && (e[0] == '#' || /\d/.test(e) || !de() && mt.test(e) || e in (pe || {})); } const Mt = de() ? i.useEffect : i.useLayoutEffect; const Et = function () { const e = (0, i.useRef)(!1); return Mt((() => (e.current = !0, function () { e.current = !1; })), []), e; }; function Ct() { const e = (0, i.useState)()[1]; const t = Et(); return function () { t.current && e(Math.random()); }; } const Pt = function (e) { return (0, i.useEffect)(e, At); }; var At = []; function Tt(e) { const t = (0, i.useRef)(); return (0, i.useEffect)((() => { t.current = e; })), t.current; } const Rt = Symbol.for('Animated:node'); const It = function (e) { return e && e[Rt]; }; const Ot = function (e, t) { return r = e, n = Rt, i = t, Object.defineProperty(r, n, { value: i, writable: !0, configurable: !0 }); let r; let n; let i; }; const Dt = function (e) { return e && e[Rt] && e[Rt].getPayload(); }; const zt = (function () { function e() { (0, w.Z)(this, e), Ot(this, this); } return (0, b.Z)(e, [{ key: 'getPayload', value() { return this.payload || []; } }]), e; }()); const Nt = (function (e) { x(r, e); const t = C(r); function r(e) { let n; return (0, w.Z)(this, r), (n = t.call(this))._value = e, n.done = !0, n.durationProgress = 0, ie.num(n._value) && (n.lastPosition = n._value), n; } return (0, b.Z)(r, [{ key: 'getPayload', value() { return [this]; } }, { key: 'getValue', value() { return this._value; } }, { key: 'setValue', value(e, t) { return ie.num(e) && (this.lastPosition = e, t && (e = Math.round(e / t) * t, this.done && (this.lastPosition = e))), this._value !== e && (this._value = e, !0); } }, { key: 'reset', value() { const e = this.done; this.done = !1, ie.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e && (this.lastVelocity = null), this.v0 = null); } }], [{ key: 'create', value(e) { return new r(e); } }]), r; }(zt)); const Lt = (function (e) { x(r, e); const t = C(r); function r(e) { let n; return (0, w.Z)(this, r), (n = t.call(this, 0))._string = null, n._toString = qe({ output: [e, e] }), n; } return (0, b.Z)(r, [{ key: 'getValue', value() { const e = this._string; return e == null ? this._string = this._toString(this._value) : e; } }, { key: 'setValue', value(e) { if (ie.str(e)) { if (e == this._string) return !1; this._string = e, this._value = 1; } else { if (!A(_(r.prototype), 'setValue', this).call(this, e)) return !1; this._string = null; } return !0; } }, { key: 'reset', value(e) { e && (this._toString = qe({ output: [this.getValue(), e] })), this._value = 0, A(_(r.prototype), 'reset', this).call(this); } }], [{ key: 'create', value(e) { return new r(e); } }]), r; }(Nt)); const jt = { dependencies: null }; const Ft = (function (e) { x(r, e); const t = C(r); function r(e) { let n; return (0, w.Z)(this, r), (n = t.call(this)).source = e, n.setValue(e), n; } return (0, b.Z)(r, [{ key: 'getValue', value(e) { const t = {}; return se(this.source, ((r, n) => { let i; (i = r) && i[Rt] === i ? t[n] = r.getValue(e) : tt(r) ? t[n] = rt(r) : e || (t[n] = r); })), t; } }, { key: 'setValue', value(e) { this.source = e, this.payload = this._makePayload(e); } }, { key: 'reset', value() { this.payload && oe(this.payload, ((e) => e.reset())); } }, { key: '_makePayload', value(e) { if (e) { const t = new Set(); return se(e, this._addToPayload, t), Array.from(t); } } }, { key: '_addToPayload', value(e) { const t = this; jt.dependencies && tt(e) && jt.dependencies.add(e); const r = Dt(e); r && oe(r, ((e) => t.add(e))); } }]), r; }(zt)); const Bt = (function (e) { x(r, e); const t = C(r); function r(e) { return (0, w.Z)(this, r), t.call(this, e); } return (0, b.Z)(r, [{ key: 'getValue', value() { return this.source.map(((e) => e.getValue())); } }, { key: 'setValue', value(e) { const t = this.getPayload(); return e.length == t.length ? t.map(((t, r) => t.setValue(e[r]))).some(Boolean) : (A(_(r.prototype), 'setValue', this).call(this, e.map(Ut)), !0); } }], [{ key: 'create', value(e) { return new r(e); } }]), r; }(Ft)); function Ut(e) { return (St(e) ? Lt : Nt).create(e); } function Vt(e) { const t = It(e); return t ? t.constructor : ie.arr(e) ? Bt : St(e) ? Lt : Nt; } const Yt = function (e, t) { const r = !ie.fun(e) || e.prototype && e.prototype.isReactComponent; return (0, i.forwardRef)(((n, a) => { const o = (0, i.useRef)(null); const s = r && (0, i.useCallback)(((e) => { o.current = (function (e, t) { e && (ie.fun(e) ? e(t) : e.current = t); return t; }(a, e)); }), [a]); const u = (function (e, t) { const r = new Set(); jt.dependencies = r, e.style && (e = z(z({}, e), {}, { style: t.createAnimatedStyle(e.style) })); return e = new Ft(e), jt.dependencies = null, [e, r]; }(n, t)); const l = d(u, 2); const c = l[0]; const h = l[1]; const f = Ct(); const p = function () { const e = o.current; r && !e || !1 === (!!e && t.applyAnimatedValues(e, c.getValue(!0))) && f(); }; const m = new Ht(p, h); const v = (0, i.useRef)(); Mt((() => (v.current = m, oe(h, ((e) => st(e, m))), function () { v.current && (oe(v.current.deps, ((e) => ut(e, v.current))), B.cancel(v.current.update)); }))), (0, i.useEffect)(p, []), Pt((() => function () { const e = v.current; oe(e.deps, ((t) => ut(t, e))); })); const g = t.getComponentProps(c.getValue()); return i.createElement(e, z(z({}, g), {}, { ref: s })); })); }; var Ht = (function () { function e(t, r) { (0, w.Z)(this, e), this.update = t, this.deps = r; } return (0, b.Z)(e, [{ key: 'eventObserved', value(e) { e.type == 'change' && B.write(this.update); } }]), e; }()); const qt = Symbol.for('AnimatedComponent'); const Wt = function (e) { return ie.str(e) ? e : e && ie.str(e.displayName) ? e.displayName : ie.fun(e) && e.name || null; }; const Xt = ['children']; function Gt(e) { for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)r[n - 1] = arguments[n]; return ie.fun(e) ? e.apply(void 0, r) : e; } const $t = function (e, t) { return !0 === e || !!(t && e && (ie.fun(e) ? e(t) : ue(e).includes(t))); }; const Zt = function (e, t) { return ie.obj(e) ? t && e[t] : e; }; const Kt = function (e, t) { return !0 === e.default ? e[t] : e.default ? e.default[t] : void 0; }; const Qt = function (e) { return e; }; const Jt = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Qt; let r = er; e.default && !0 !== e.default && (e = e.default, r = Object.keys(e)); let n; const i = {}; const a = N(r); try { for (a.s(); !(n = a.n()).done;) { const o = n.value; const s = t(e[o], o); ie.und(s) || (i[o] = s); } } catch (Rv) { a.e(Rv); } finally { a.f(); } return i; }; var er = ['config', 'onProps', 'onStart', 'onChange', 'onPause', 'onResume', 'onRest']; const tr = {
      config: 1, from: 1, to: 1, ref: 1, loop: 1, reset: 1, pause: 1, cancel: 1, reverse: 1, immediate: 1, default: 1, delay: 1, onProps: 1, onStart: 1, onChange: 1, onPause: 1, onResume: 1, onRest: 1, onResolve: 1, items: 1, trail: 1, sort: 1, expires: 1, initial: 1, enter: 1, update: 1, leave: 1, children: 1, onDestroyed: 1, keys: 1, callId: 1, parentId: 1,
    }; function rr(e) { const t = (function (e) { const t = {}; let r = 0; if (se(e, ((e, n) => { tr[n] || (t[n] = e, r++); })), r) return t; }(e)); if (t) { const r = { to: t }; return se(e, ((e, n) => n in t || (r[n] = e))), r; } return z({}, e); } function nr(e) { return e = rt(e), ie.arr(e) ? e.map(nr) : St(e) ? j.createStringInterpolator({ range: [0, 1], output: [e, e] })(1) : e; } function ir(e) { for (const t in e) return !0; return !1; } function ar(e) { return ie.fun(e) || ie.arr(e) && ie.obj(e[0]); } function or(e, t) { let r; (r = e.ref) === null || void 0 === r || r.delete(e), t === null || void 0 === t || t.delete(e); } function sr(e, t) { let r; t && e.ref !== t && ((r = e.ref) === null || void 0 === r || r.delete(e), t.add(e), e.ref = t); } const ur = z(z({}, { tension: 170, friction: 26 }), {}, {
      mass: 1, damping: 1, easing: Qe.linear, clamp: !1,
    }); const lr = (0, b.Z)((function e() { (0, w.Z)(this, e), this.velocity = 0, Object.assign(this, ur); })); function cr(e, t) { if (ie.und(t.decay)) { const r = !ie.und(t.tension) || !ie.und(t.friction); !r && ie.und(t.frequency) && ie.und(t.damping) && ie.und(t.mass) || (e.duration = void 0, e.decay = void 0), r && (e.frequency = void 0); } else e.duration = void 0; } const hr = []; const fr = (0, b.Z)((function e() { (0, w.Z)(this, e), this.changed = !1, this.values = hr, this.toValues = null, this.fromValues = hr, this.config = new lr(), this.immediate = !1; })); function dr(e, t) { const r = t.key; const n = t.props; const i = t.defaultProps; const a = t.state; const o = t.actions; return new Promise(((t, s) => { let u; let l; let c; let h = $t((u = n.cancel) !== null && void 0 !== u ? u : i === null || void 0 === i ? void 0 : i.cancel, r); if (h)m(); else { ie.und(n.pause) || (a.paused = $t(n.pause, r)); let f = i === null || void 0 === i ? void 0 : i.pause; !0 !== f && (f = a.paused || $t(f, r)), l = Gt(n.delay || 0, r), f ? (a.resumeQueue.add(p), o.pause()) : (o.resume(), p()); } function d() { a.resumeQueue.add(p), a.timeouts.delete(c), c.cancel(), l = c.time - B.now(); } function p() { l > 0 && !j.skipAnimation ? (a.delayed = !0, c = B.setTimeout(m, l), a.pauseQueue.add(d), a.timeouts.add(c)) : m(); } function m() { a.delayed && (a.delayed = !1), a.pauseQueue.delete(d), a.timeouts.delete(c), e <= (a.cancelId || 0) && (h = !0); try { o.start(z(z({}, n), {}, { callId: e, cancel: h }), t); } catch (Rv) { s(Rv); } } })); } const pr = function (e, t) { return t.length == 1 ? t[0] : t.some(((e) => e.cancelled)) ? gr(e.get()) : t.every(((e) => e.noop)) ? mr(e.get()) : vr(e.get(), t.every(((e) => e.finished))); }; var mr = function (e) {
      return {
        value: e, noop: !0, finished: !0, cancelled: !1,
      };
    }; var vr = function (e, t) { return { value: e, finished: t, cancelled: arguments.length > 2 && void 0 !== arguments[2] && arguments[2] }; }; var gr = function (e) { return { value: e, cancelled: !0, finished: !1 }; }; function yr(e, t, r, n) {
      const i = t.callId; const a = t.parentId; const o = t.onRest; const s = r.asyncTo; const l = r.promise; return a || e !== s || t.reset ? r.promise = c(u().mark((function h() {
        let f; let d; let p; let m; let v; let g; let y; let b; return u().wrap(((h) => {
          for (;;) {
            switch (h.prev = h.next) {
              case 0: if (r.asyncId = i, r.asyncTo = e, f = Jt(t, ((e, t) => (t === 'onRest' ? void 0 : e))), m = new Promise(((e, t) => (d = e, p = t))), v = function (e) { const t = i <= (r.cancelId || 0) && gr(n) || i !== r.asyncId && vr(n, !1); if (t) throw e.result = t, p(e), e; }, g = function (e, t) {
                const a = new wr(); const
                  o = new kr(); return c(u().mark((function s() { let l; let c; return u().wrap(((s) => { for (;;) switch (s.prev = s.next) { case 0: if (!j.skipAnimation) { s.next = 5; break; } throw br(r), o.result = vr(n, !1), p(o), o; case 5: return v(a), (l = ie.obj(e) ? z({}, e) : z(z({}, t), {}, { to: e })).parentId = i, se(f, ((e, t) => { ie.und(l[t]) && (l[t] = e); })), s.next = 11, n.start(l); case 11: if (c = s.sent, v(a), !r.paused) { s.next = 16; break; } return s.next = 16, new Promise(((e) => { r.resumeQueue.add(e); })); case 16: return s.abrupt('return', c); case 17: case 'end': return s.stop(); } }), s); })))();
              }, !j.skipAnimation) { h.next = 9; break; } return br(r), h.abrupt('return', vr(n, !1)); case 9: return h.prev = 9, b = ie.arr(e) ? (function () { const e = c(u().mark((function e(t) { let r; let n; let i; return u().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: r = N(t), e.prev = 1, r.s(); case 3: if ((n = r.n()).done) { e.next = 9; break; } return i = n.value, e.next = 7, g(i); case 7: e.next = 3; break; case 9: e.next = 14; break; case 11: e.prev = 11, e.t0 = e.catch(1), r.e(e.t0); case 14: return e.prev = 14, r.f(), e.finish(14); case 17: case 'end': return e.stop(); } }), e, null, [[1, 11, 14, 17]]); }))); return function (t) { return e.apply(this, arguments); }; }())(e) : Promise.resolve(e(g, n.stop.bind(n))), h.next = 13, Promise.all([b.then(d), m]); case 13: y = vr(n.get(), !0, !1), h.next = 27; break; case 16: if (h.prev = 16, h.t0 = h.catch(9), !(h.t0 instanceof wr)) { h.next = 22; break; }y = h.t0.result, h.next = 27; break; case 22: if (!(h.t0 instanceof kr)) { h.next = 26; break; }y = h.t0.result, h.next = 27; break; case 26: throw h.t0; case 27: return h.prev = 27, i == r.asyncId && (r.asyncId = a, r.asyncTo = a ? s : void 0, r.promise = a ? l : void 0), h.finish(27); case 30: return ie.fun(o) && B.batchedUpdates((() => { o(y, n, n.item); })), h.abrupt('return', y); case 32: case 'end': return h.stop();
            }
          }
        }), h, null, [[9, 16, 27, 30]]);
      })))() : l;
    } function br(e, t) { le(e.timeouts, ((e) => e.cancel())), e.pauseQueue.clear(), e.resumeQueue.clear(), e.asyncId = e.asyncTo = e.promise = void 0, t && (e.cancelId = t); } var wr = (function (e) { x(r, e); const t = C(r); function r() { return (0, w.Z)(this, r), t.call(this, 'An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.'); } return (0, b.Z)(r); }(R(Error))); var kr = (function (e) { x(r, e); const t = C(r); function r() { return (0, w.Z)(this, r), t.call(this, 'SkipAnimationSignal'); } return (0, b.Z)(r); }(R(Error))); const xr = function (e) { return e instanceof Sr; }; let _r = 1; var Sr = (function (e) {
      x(r, e); const t = C(r); function r() { let e; return (0, w.Z)(this, r), (e = t.apply(this, arguments)).id = _r++, e._priority = 0, e; } return (0, b.Z)(r, [{ key: 'priority', get() { return this._priority; }, set(e) { this._priority != e && (this._priority = e, this._onPriorityChange(e)); } }, { key: 'get', value() { const e = It(this); return e && e.getValue(); } }, { key: 'to', value() { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return j.to(this, t); } }, { key: 'interpolate', value() { xt(''.concat(wt, 'The "interpolate" function is deprecated in v9 (use "to" instead)')); for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return j.to(this, t); } }, { key: 'toJSON', value() { return this.get(); } }, { key: 'observerAdded', value(e) { e == 1 && this._attach(); } }, { key: 'observerRemoved', value(e) { e == 0 && this._detach(); } }, { key: '_attach', value() {} }, { key: '_detach', value() {} }, {
        key: '_onChange',
        value(e) {
          it(this, {
            type: 'change', parent: this, value: e, idle: arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
          });
        },
      }, { key: '_onPriorityChange', value(e) { this.idle || xe.sort(this), it(this, { type: 'priority', parent: this, priority: e }); } }]), r;
    }(at)); const Mr = Symbol.for('SpringPhase'); const Er = function (e) { return (1 & e[Mr]) > 0; }; const Cr = function (e) { return (2 & e[Mr]) > 0; }; const Pr = function (e) { return (4 & e[Mr]) > 0; }; const Ar = function (e, t) { return t ? e[Mr] |= 3 : e[Mr] &= -3; }; const Tr = function (e, t) { return t ? e[Mr] |= 4 : e[Mr] &= -5; }; const Rr = (function (e) {
      x(r, e); const t = C(r); function r(e, n) {
        let i; if ((0, w.Z)(this, r), (i = t.call(this)).animation = new fr(), i.defaultProps = {}, i._state = {
          paused: !1, delayed: !1, pauseQueue: new Set(), resumeQueue: new Set(), timeouts: new Set(),
        }, i._pendingCalls = new Set(), i._lastCallId = 0, i._lastToId = 0, i._memoizedDuration = 0, !ie.und(e) || !ie.und(n)) { const a = ie.obj(e) ? z({}, e) : z(z({}, n), {}, { from: e }); ie.und(a.default) && (a.default = !0), i.start(a); } return i;
      } return (0, b.Z)(r, [{ key: 'idle', get() { return !(Cr(this) || this._state.asyncTo) || Pr(this); } }, { key: 'goal', get() { return rt(this.animation.to); } }, { key: 'velocity', get() { const e = It(this); return e instanceof Nt ? e.lastVelocity || 0 : e.getPayload().map(((e) => e.lastVelocity || 0)); } }, { key: 'hasAnimated', get() { return Er(this); } }, { key: 'isAnimating', get() { return Cr(this); } }, { key: 'isPaused', get() { return Pr(this); } }, { key: 'isDelayed', get() { return this._state.delayed; } }, { key: 'advance', value(e) { const t = this; let r = !0; let n = !1; const i = this.animation; let a = i.toValues; const o = i.config; const s = Dt(i.to); !s && tt(i.to) && (a = ue(rt(i.to))), i.values.forEach(((u, l) => { if (!u.done) { const c = u.constructor == Lt ? 1 : s ? s[l].lastPosition : a[l]; let h = i.immediate; let f = c; if (!h) { if (f = u.lastPosition, o.tension <= 0) return void (u.done = !0); let d; let p = u.elapsedTime += e; const m = i.fromValues[l]; const v = u.v0 != null ? u.v0 : u.v0 = ie.arr(o.velocity) ? o.velocity[l] : o.velocity; const g = o.precision || (m == c ? 0.005 : Math.min(1, 0.001 * Math.abs(c - m))); if (ie.und(o.duration)) if (o.decay) { const y = !0 === o.decay ? 0.998 : o.decay; const b = Math.exp(-(1 - y) * p); f = m + v / (1 - y) * (1 - b), h = Math.abs(u.lastPosition - f) <= g, d = v * b; } else { d = u.lastVelocity == null ? v : u.lastVelocity; for (let w = o.restVelocity || g / 10, k = o.clamp ? 0 : o.bounce, x = !ie.und(k), _ = m == c ? u.v0 > 0 : m < c, S = Math.ceil(e / 1), M = 0; M < S && (Math.abs(d) > w || !(h = Math.abs(c - f) <= g)); ++M) { x && (f == c || f > c == _) && (d = -d * k, f = c), f += 1 * (d += 1 * ((1e-6 * -o.tension * (f - c) + 0.001 * -o.friction * d) / o.mass)); } } else { let E = 1; o.duration > 0 && (t._memoizedDuration !== o.duration && (t._memoizedDuration = o.duration, u.durationProgress > 0 && (u.elapsedTime = o.duration * u.durationProgress, p = u.elapsedTime += e)), E = (E = (o.progress || 0) + p / t._memoizedDuration) > 1 ? 1 : E < 0 ? 0 : E, u.durationProgress = E), d = ((f = m + o.easing(E) * (c - m)) - u.lastPosition) / e, h = E == 1; }u.lastVelocity = d, Number.isNaN(f) && (console.warn('Got NaN while animating:', t), h = !0); }s && !s[l].done && (h = !1), h ? u.done = !0 : r = !1, u.setValue(f, o.round) && (n = !0); } })); const u = It(this); const l = u.getValue(); if (r) { const c = rt(i.to); l === c && !n || o.decay ? n && o.decay && this._onChange(l) : (u.setValue(c), this._onChange(c)), this._stop(); } else n && this._onChange(l); } }, { key: 'set', value(e) { const t = this; return B.batchedUpdates((() => { t._stop(), t._focus(e), t._set(e); })), this; } }, { key: 'pause', value() { this._update({ pause: !0 }); } }, { key: 'resume', value() { this._update({ pause: !1 }); } }, { key: 'finish', value() { const e = this; if (Cr(this)) { const t = this.animation; const r = t.to; const n = t.config; B.batchedUpdates((() => { e._onStart(), n.decay || e._set(r, !1), e._stop(); })); } return this; } }, { key: 'update', value(e) { return (this.queue || (this.queue = [])).push(e), this; } }, { key: 'start', value(e, t) { let r; const n = this; return ie.und(e) ? (r = this.queue || [], this.queue = []) : r = [ie.obj(e) ? e : z(z({}, t), {}, { to: e })], Promise.all(r.map(((e) => n._update(e)))).then(((e) => pr(n, e))); } }, { key: 'stop', value(e) { const t = this; const r = this.animation.to; return this._focus(this.get()), br(this._state, e && this._lastCallId), B.batchedUpdates((() => t._stop(r, e))), this; } }, { key: 'reset', value() { this._update({ reset: !0 }); } }, { key: 'eventObserved', value(e) { e.type == 'change' ? this._start() : e.type == 'priority' && (this.priority = e.priority + 1); } }, { key: '_prepareNode', value(e) { const t = this.key || ''; let r = e.to; let n = e.from; ((r = ie.obj(r) ? r[t] : r) == null || ar(r)) && (r = void 0), (n = ie.obj(n) ? n[t] : n) == null && (n = void 0); const i = { to: r, from: n }; if (!Er(this)) { if (e.reverse) { const a = [n, r]; r = a[0], n = a[1]; }n = rt(n), ie.und(n) ? It(this) || this._set(r) : this._set(n); } return i; } }, {
        key: '_update',
        value(e, t) {
          const r = this; const n = { ...((function (e) { if (e == null) throw new TypeError(`Cannot destructure ${e}`); }(e)), e) }; const i = this.key; const a = this.defaultProps; n.default && Object.assign(a, Jt(n, ((e, t) => (/^on/.test(t) ? Zt(e, i) : e)))), jr(this, n, 'onProps'), Fr(this, 'onProps', n, this); const o = this._prepareNode(n); if (Object.isFrozen(this)) throw Error('Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?'); const s = this._state; return dr(++this._lastCallId, {
            key: i, props: n, defaultProps: a, state: s, actions: { pause() { Pr(r) || (Tr(r, !0), fe(s.pauseQueue), Fr(r, 'onPause', vr(r, Ir(r, r.animation.to)), r)); }, resume() { Pr(r) && (Tr(r, !1), Cr(r) && r._resume(), fe(s.resumeQueue), Fr(r, 'onResume', vr(r, Ir(r, r.animation.to)), r)); }, start: this._merge.bind(this, o) },
          }).then(((e) => { if (n.loop && e.finished && (!t || !e.noop)) { const i = Or(n); if (i) return r._update(i, !0); } return e; }));
        },
      }, { key: '_merge', value(e, t, r) { const n = this; if (t.cancel) return this.stop(!0), r(gr(this)); const i = !ie.und(e.to); const a = !ie.und(e.from); if (i || a) { if (!(t.callId > this._lastToId)) return r(gr(this)); this._lastToId = t.callId; } const o = this.key; const s = this.defaultProps; const u = this.animation; const l = u.to; const c = u.from; const h = e.to; let f = void 0 === h ? l : h; const d = e.from; let p = void 0 === d ? c : d; if (!a || i || t.default && !ie.und(f) || (f = p), t.reverse) { const m = [p, f]; f = m[0], p = m[1]; } const v = !ae(p, c); v && (u.from = p), p = rt(p); const g = !ae(f, l); g && this._focus(f); const y = ar(t.to); const b = u.config; const w = b.decay; const k = b.velocity; (i || a) && (b.velocity = 0), t.config && !y && (function (e, t, r) { for (const n in r && (cr(r = z({}, r), t), t = z(z({}, r), t)), cr(e, t), Object.assign(e, t), ur)e[n] == null && (e[n] = ur[n]); let i = e.frequency; let a = e.damping; const o = e.mass; ie.und(i) || (i < 0.01 && (i = 0.01), a < 0 && (a = 0), e.tension = (2 * Math.PI / i) ** 2 * o, e.friction = 4 * Math.PI * a * o / i); }(b, Gt(t.config, o), t.config !== s.config ? Gt(s.config, o) : void 0)); let x = It(this); if (!x || ie.und(f)) return r(vr(this, !0)); const _ = ie.und(t.reset) ? a && !t.default : !ie.und(p) && $t(t.reset, o); const S = _ ? p : this.get(); const M = nr(f); const E = ie.num(M) || ie.arr(M) || St(M); const C = !y && (!E || $t(s.immediate || t.immediate, o)); if (g) { const P = Vt(f); if (P !== x.constructor) { if (!C) throw Error('Cannot animate between '.concat(x.constructor.name, ' and ').concat(P.name, ', as the "to" prop suggests')); x = this._set(M); } } const A = x.constructor; let T = tt(f); let R = !1; if (!T) { const I = _ || !Er(this) && v; (g || I) && (T = !(R = ae(nr(S), M))), (ae(u.immediate, C) || C) && ae(b.decay, w) && ae(b.velocity, k) || (T = !0); } if (R && Cr(this) && (u.changed && !_ ? T = !0 : T || this._stop(l)), !y && ((T || tt(l)) && (u.values = x.getPayload(), u.toValues = tt(f) ? null : A == Lt ? [1] : ue(M)), u.immediate != C && (u.immediate = C, C || _ || this._set(l)), T)) { const O = u.onRest; oe(Lr, ((e) => jr(n, t, e))); const D = vr(this, Ir(this, l)); fe(this._pendingCalls, D), this._pendingCalls.add(r), u.changed && B.batchedUpdates((() => { let e; (u.changed = !_, O === null || void 0 === O || O(D, n), _) ? Gt(s.onRest, D) : (e = u.onStart) === null || void 0 === e || e.call(u, D, n); })); }_ && this._set(S), y ? r(yr(t.to, t, this._state, this)) : T ? this._start() : Cr(this) && !g ? this._pendingCalls.add(r) : r(mr(S)); } }, { key: '_focus', value(e) { const t = this.animation; e !== t.to && (nt(this) && this._detach(), t.to = e, nt(this) && this._attach()); } }, { key: '_attach', value() { let e = 0; const t = this.animation.to; tt(t) && (st(t, this), xr(t) && (e = t.priority + 1)), this.priority = e; } }, { key: '_detach', value() { const e = this.animation.to; tt(e) && ut(e, this); } }, { key: '_set', value(e) { const t = this; const r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const n = rt(e); if (!ie.und(n)) { const i = It(this); if (!i || !ae(n, i.getValue())) { const a = Vt(n); i && i.constructor == a ? i.setValue(n) : Ot(this, a.create(n)), i && B.batchedUpdates((() => { t._onChange(n, r); })); } } return It(this); } }, { key: '_onStart', value() { const e = this.animation; e.changed || (e.changed = !0, Fr(this, 'onStart', vr(this, Ir(this, e.to)), this)); } }, { key: '_onChange', value(e, t) { t || (this._onStart(), Gt(this.animation.onChange, e, this)), Gt(this.defaultProps.onChange, e, this), A(_(r.prototype), '_onChange', this).call(this, e, t); } }, { key: '_start', value() { const e = this.animation; It(this).reset(rt(e.to)), e.immediate || (e.fromValues = e.values.map(((e) => e.lastPosition))), Cr(this) || (Ar(this, !0), Pr(this) || this._resume()); } }, { key: '_resume', value() { j.skipAnimation ? this.finish() : xe.start(this); } }, { key: '_stop', value(e, t) { if (Cr(this)) { Ar(this, !1); const r = this.animation; oe(r.values, ((e) => { e.done = !0; })), r.toValues && (r.onChange = r.onPause = r.onResume = void 0), it(this, { type: 'idle', parent: this }); const n = t ? gr(this.get()) : vr(this.get(), Ir(this, e !== null && void 0 !== e ? e : r.to)); fe(this._pendingCalls, n), r.changed && (r.changed = !1, Fr(this, 'onRest', n, this)); } } }]), r;
    }(Sr)); function Ir(e, t) { const r = nr(t); return ae(nr(e.get()), r); } function Or(e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.loop; const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.to; const n = Gt(t); if (n) {
        const i = !0 !== n && rr(n); const a = (i || e).reverse; const o = !i || i.reset; return Dr(z(z({}, e), {}, {
          loop: t, default: !1, pause: void 0, to: !a || ar(r) ? r : void 0, from: o ? e.from : void 0, reset: o,
        }, i));
      }
    } function Dr(e) { const t = e = rr(e); const r = t.to; const n = t.from; const i = new Set(); return ie.obj(r) && Nr(r, i), ie.obj(n) && Nr(n, i), e.keys = i.size ? Array.from(i) : null, e; } function zr(e) { const t = Dr(e); return ie.und(t.default) && (t.default = Jt(t)), t; } function Nr(e, t) { se(e, ((e, r) => e != null && t.add(r))); } var Lr = ['onStart', 'onRest', 'onChange', 'onPause', 'onResume']; function jr(e, t, r) { e.animation[r] = t[r] !== Kt(t, r) ? Zt(t[r], e.key) : void 0; } function Fr(e, t) { for (var r, n, i, a, o = arguments.length, s = new Array(o > 2 ? o - 2 : 0), u = 2; u < o; u++)s[u - 2] = arguments[u]; (r = (n = e.animation)[t]) === null || void 0 === r || r.call.apply(r, [n].concat(s)), (i = (a = e.defaultProps)[t]) === null || void 0 === i || i.call.apply(i, [a].concat(s)); } const Br = ['onStart', 'onChange', 'onRest']; let Ur = 1; const Vr = (function () {
      function e(t, r) {
        (0, w.Z)(this, e), this.id = Ur++, this.springs = {}, this.queue = [], this._lastAsyncId = 0, this._active = new Set(), this._changed = new Set(), this._started = !1, this._state = {
          paused: !1, pauseQueue: new Set(), resumeQueue: new Set(), timeouts: new Set(),
        }, this._events = { onStart: new Map(), onChange: new Map(), onRest: new Map() }, this._onFrame = this._onFrame.bind(this), r && (this._flush = r), t && this.start(z({ default: !0 }, t));
      } return (0, b.Z)(e, [{ key: 'idle', get() { return !this._state.asyncTo && Object.values(this.springs).every(((e) => e.idle && !e.isDelayed && !e.isPaused)); } }, { key: 'item', get() { return this._item; }, set(e) { this._item = e; } }, { key: 'get', value() { const e = {}; return this.each(((t, r) => e[r] = t.get())), e; } }, { key: 'set', value(e) { for (const t in e) { const r = e[t]; ie.und(r) || this.springs[t].set(r); } } }, { key: 'update', value(e) { return e && this.queue.push(Dr(e)), this; } }, { key: 'start', value(e) { let t = this.queue; return e ? t = ue(e).map(Dr) : this.queue = [], this._flush ? this._flush(this, t) : (Zr(this, t), Yr(this, t)); } }, { key: 'stop', value(e, t) { if (e !== !!e && (t = e), t) { const r = this.springs; oe(ue(t), ((t) => r[t].stop(!!e))); } else br(this._state, this._lastAsyncId), this.each(((t) => t.stop(!!e))); return this; } }, { key: 'pause', value(e) { if (ie.und(e)) this.start({ pause: !0 }); else { const t = this.springs; oe(ue(e), ((e) => t[e].pause())); } return this; } }, { key: 'resume', value(e) { if (ie.und(e)) this.start({ pause: !1 }); else { const t = this.springs; oe(ue(e), ((e) => t[e].resume())); } return this; } }, { key: 'each', value(e) { se(this.springs, e); } }, { key: '_onFrame', value() { const e = this; const t = this._events; const r = t.onStart; const n = t.onChange; const i = t.onRest; const a = this._active.size > 0; const o = this._changed.size > 0; (a && !this._started || o && !this._started) && (this._started = !0, le(r, ((t) => { const r = d(t, 2); const n = r[0]; const i = r[1]; i.value = e.get(), n(i, e, e._item); }))); const s = !a && this._started; const u = o || s && i.size ? this.get() : null; o && n.size && le(n, ((t) => { const r = d(t, 2); const n = r[0]; const i = r[1]; i.value = u, n(i, e, e._item); })), s && (this._started = !1, le(i, ((t) => { const r = d(t, 2); const n = r[0]; const i = r[1]; i.value = u, n(i, e, e._item); }))); } }, { key: 'eventObserved', value(e) { if (e.type == 'change') this._changed.add(e.parent), e.idle || this._active.add(e.parent); else { if (e.type != 'idle') return; this._active.delete(e.parent); }B.onFrame(this._onFrame); } }]), e;
    }()); function Yr(e, t) { return Promise.all(t.map(((t) => Hr(e, t)))).then(((t) => pr(e, t))); } function Hr(e, t, r) { return qr.apply(this, arguments); } function qr() { return qr = c(u().mark((function e(t, r, n) { let i; let a; let o; let s; let l; let c; let h; let f; let d; let p; let m; let v; let g; return u().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: if (i = r.keys, a = r.to, o = r.from, s = r.loop, l = r.onRest, c = r.onResolve, h = ie.obj(r.default) && r.default, s && (r.loop = !1), !1 === a && (r.to = null), !1 === o && (r.from = null), (f = ie.arr(a) || ie.fun(a) ? a : void 0) ? (r.to = void 0, r.onRest = void 0, h && (h.onRest = void 0)) : oe(Br, ((e) => { const n = r[e]; if (ie.fun(n)) { const i = t._events[e]; r[e] = function (e) { const t = e.finished; const r = e.cancelled; const a = i.get(n); a ? (t || (a.finished = !1), r && (a.cancelled = !0)) : i.set(n, { value: null, finished: t || !1, cancelled: r || !1 }); }, h && (h[e] = r[e]); } })), d = t._state, r.pause === !d.paused ? (d.paused = r.pause, fe(r.pause ? d.pauseQueue : d.resumeQueue)) : d.paused && (r.pause = !0), p = (i || Object.keys(t.springs)).map(((e) => t.springs[e].start(r))), m = !0 === r.cancel || !0 === Kt(r, 'cancel'), (f || m && d.asyncId) && p.push(dr(++t._lastAsyncId, { props: r, state: d, actions: { pause: ne, resume: ne, start(e, r) { m ? (br(d, t._lastAsyncId), r(gr(t))) : (e.onRest = l, r(yr(f, e, d, t))); } } })), !d.paused) { e.next = 15; break; } return e.next = 15, new Promise(((e) => { d.resumeQueue.add(e); })); case 15: return e.t0 = pr, e.t1 = t, e.next = 19, Promise.all(p); case 19: if (e.t2 = e.sent, v = (0, e.t0)(e.t1, e.t2), !s || !v.finished || n && v.noop) { e.next = 26; break; } if (!(g = Or(r, s, a))) { e.next = 26; break; } return Zr(t, [g]), e.abrupt('return', Hr(t, g, !0)); case 26: return c && B.batchedUpdates((() => c(v, t, t.item))), e.abrupt('return', v); case 28: case 'end': return e.stop(); } }), e); }))), qr.apply(this, arguments); } function Wr(e, t) { const r = z({}, e.springs); return t && oe(ue(t), ((e) => { ie.und(e.keys) && (e = Dr(e)), ie.obj(e.to) || (e = z(z({}, e), {}, { to: void 0 })), $r(r, e, ((e) => Gr(e))); })), Xr(e, r), r; } function Xr(e, t) { se(t, ((t, r) => { e.springs[r] || (e.springs[r] = t, st(t, e)); })); } function Gr(e, t) { const r = new Rr(); return r.key = e, t && st(r, t), r; } function $r(e, t, r) { t.keys && oe(t.keys, ((n) => { (e[n] || (e[n] = r(n)))._prepareNode(t); })); } function Zr(e, t) { oe(t, ((t) => { $r(e.springs, t, ((t) => Gr(t, e))); })); } let Kr; let Qr; const Jr = function (e) { const t = e.children; let r = v(e, Xt); const n = (0, i.useContext)(en); const a = r.pause || !!n.pause; const o = r.immediate || !!n.immediate; r = (function (e, t) { const r = d((0, i.useState)((() => ({ inputs: t, result: e() }))), 1)[0]; const n = (0, i.useRef)(); const a = n.current; let o = a; if (o) { const s = Boolean(t && o.inputs && (function (e, t) { if (e.length !== t.length) return !1; for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1; return !0; }(t, o.inputs))); s || (o = { inputs: t, result: e() }); } else o = r; return (0, i.useEffect)((() => { n.current = o, a == r && (r.inputs = r.result = void 0); }), [o]), o.result; }((() => ({ pause: a, immediate: o })), [a, o])); const s = en.Provider; return i.createElement(s, { value: r }, t); }; var en = (Kr = Jr, Qr = {}, Object.assign(Kr, i.createContext(Qr)), Kr.Provider._context = Kr, Kr.Consumer._context = Kr, Kr); Jr.Provider = en.Provider, Jr.Consumer = en.Consumer; const tn = function () { const e = []; const t = function (t) { _t(''.concat(wt, 'Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions')); const n = []; return oe(e, ((e, i) => { if (ie.und(t))n.push(e.start()); else { const a = r(t, e, i); a && n.push(e.start(a)); } })), n; }; t.current = e, t.add = function (t) { e.includes(t) || e.push(t); }, t.delete = function (t) { const r = e.indexOf(t); ~r && e.splice(r, 1); }, t.pause = function () { const t = arguments; return oe(e, ((e) => e.pause.apply(e, P(t)))), this; }, t.resume = function () { const t = arguments; return oe(e, ((e) => e.resume.apply(e, P(t)))), this; }, t.set = function (t) { oe(e, ((e, r) => { const n = ie.fun(t) ? t(r, e) : t; n && e.set(n); })); }, t.start = function (t) { const r = this; const n = []; return oe(e, ((e, i) => { if (ie.und(t))n.push(e.start()); else { const a = r._getProps(t, e, i); a && n.push(e.start(a)); } })), n; }, t.stop = function () { const t = arguments; return oe(e, ((e) => e.stop.apply(e, P(t)))), this; }, t.update = function (t) { const r = this; return oe(e, ((e, n) => e.update(r._getProps(t, e, n)))), this; }; var r = function (e, t, r) { return ie.fun(e) ? e(r, t) : e; }; return t._getProps = r, t; }; function rn(e, t, r) { const n = arguments; const a = ie.fun(t) && t; a && !r && (r = []); const o = (0, i.useMemo)((() => (a || n.length == 3 ? tn() : void 0)), []); const s = (0, i.useRef)(0); const u = Ct(); var l = (0, i.useMemo)((() => ({ ctrls: [], queue: [], flush(e, t) { const r = Wr(e, t); return s.current > 0 && !l.queue.length && !Object.keys(r).some(((t) => !e.springs[t])) ? Yr(e, t) : new Promise(((n) => { Xr(e, r), l.queue.push((() => { n(Yr(e, t)); })), u(); })); } })), []); const c = (0, i.useRef)(P(l.ctrls)); const h = []; const f = Tt(e) || 0; function d(e, r) { for (let n = e; n < r; n++) { const i = c.current[n] || (c.current[n] = new Vr(null, l.flush)); const o = a ? a(n, i) : t[n]; o && (h[n] = zr(o)); } }(0, i.useMemo)((() => { oe(c.current.slice(e, f), ((e) => { or(e, o), e.stop(!0); })), c.current.length = e, d(f, e); }), [e]), (0, i.useMemo)((() => { d(0, Math.min(f, e)); }), r); const p = c.current.map(((e, t) => Wr(e, h[t]))); const m = (0, i.useContext)(Jr); const v = Tt(m); const g = m !== v && ir(m); Mt((() => { s.current++, l.ctrls = c.current; const e = l.queue; e.length && (l.queue = [], oe(e, ((e) => e()))), oe(c.current, ((e, t) => { o === null || void 0 === o || o.add(e), g && e.start({ default: m }); const r = h[t]; r && (sr(e, r.ref), e.ref ? e.queue.push(r) : e.start(r)); })); })), Pt((() => function () { oe(l.ctrls, ((e) => e.stop(!0))); })); const y = p.map(((e) => z({}, e))); return o ? [y, o] : y; } function nn(e, t) { const r = ie.fun(e); const n = d(rn(1, r ? e : [e], r ? t || [] : t), 2); const i = d(n[0], 1)[0]; const a = n[1]; return r || arguments.length == 2 ? [i, a] : i; } function an(e, t, r) {
      const n = arguments; const a = ie.fun(t) && t; const o = a ? a() : t; const s = o.reset; const u = o.sort; const l = o.trail; const c = void 0 === l ? 0 : l; const h = o.expires; const f = void 0 === h || h; const d = o.exitBeforeEnter; const p = void 0 !== d && d; const m = o.onDestroyed; const v = o.ref; const g = o.config; const y = (0, i.useMemo)((() => (a || n.length == 3 ? tn() : void 0)), []); const b = ue(e); const w = []; const k = (0, i.useRef)(null); const x = s ? null : k.current; Mt((() => { k.current = w; })), Pt((() => (oe(w, ((e) => { y === null || void 0 === y || y.add(e.ctrl), e.ctrl.ref = y; })), function () { oe(k.current, ((e) => { e.expired && clearTimeout(e.expirationId), or(e.ctrl, y), e.ctrl.stop(!0); })); }))); const _ = (function (e, t, r) { const n = t.key; const i = t.keys; const a = void 0 === i ? n : i; if (a === null) { const o = new Set(); return e.map(((e) => { const t = r && r.find(((t) => t.item === e && t.phase !== 'leave' && !o.has(t))); return t ? (o.add(t), t.key) : on++; })); } return ie.und(a) ? e : ie.fun(a) ? e.map(a) : ue(a); }(b, a ? a() : t, x)); const S = s && k.current || []; Mt((() => oe(S, ((e) => { const t = e.ctrl; const r = e.item; const n = e.key; or(t, y), Gt(m, r, n); })))); const M = []; if (x && oe(x, ((e, t) => { e.expired ? (clearTimeout(e.expirationId), S.push(e)) : ~(t = M[t] = _.indexOf(e.key)) && (w[t] = e); })), oe(b, ((e, t) => {
        w[t] || (w[t] = {
          key: _[t], item: e, phase: 'mount', ctrl: new Vr(),
        }, w[t].ctrl.item = e);
      })), M.length) { let E = -1; const C = (a ? a() : t).leave; oe(M, ((e, t) => { const r = x[t]; ~e ? (E = w.indexOf(r), w[E] = z(z({}, r), {}, { item: b[e] })) : C && w.splice(++E, 0, r); })); }ie.fun(u) && w.sort(((e, t) => u(e.item, t.item))); let P = -c; const A = Ct(); const T = Jt(t); const R = new Map(); const I = (0, i.useRef)(new Map()); const O = (0, i.useRef)(!1); oe(w, ((e, r) => {
        let n; let i; const o = e.key; const s = e.phase; const u = a ? a() : t; const l = Gt(u.delay || 0, o); if (s == 'mount')n = u.enter, i = 'enter'; else { const h = _.indexOf(o) < 0; if (s != 'leave') if (h)n = u.leave, i = 'leave'; else { if (!(n = u.update)) return; i = 'update'; } else { if (h) return; n = u.enter, i = 'enter'; } } if (n = Gt(n, e.item, r), !(n = ie.obj(n) ? rr(n) : { to: n }).config) { const d = g || T.config; n.config = Gt(d, e.item, r, i); }P += c; const m = z(z({}, T), {}, {
          delay: l + P, ref: v, immediate: u.immediate, reset: !1,
        }, n); if (i == 'enter' && ie.und(m.from)) { const y = a ? a() : t; const b = ie.und(y.initial) || x ? y.from : y.initial; m.from = Gt(b, e.item, r); } const w = m.onResolve; m.onResolve = function (e) { Gt(w, e); const t = k.current; const r = t.find(((e) => e.key === o)); if (r && (!e.cancelled || r.phase == 'update') && r.ctrl.idle) { const n = t.every(((e) => e.ctrl.idle)); if (r.phase == 'leave') { const i = Gt(f, r.item); if (!1 !== i) { const a = !0 === i ? 0 : i; if (r.expired = !0, !n && a > 0) return void (a <= 2147483647 && (r.expirationId = setTimeout(A, a))); } }n && t.some(((e) => e.expired)) && (I.current.delete(r), p && (O.current = !0), A()); } }; const S = Wr(e.ctrl, m); i === 'leave' && p ? I.current.set(e, { phase: i, springs: S, payload: m }) : R.set(e, { phase: i, springs: S, payload: m });
      })); const D = (0, i.useContext)(Jr); const N = Tt(D); const L = D !== N && ir(D); Mt((() => { L && oe(w, ((e) => { e.ctrl.start({ default: D }); })); }), [D]), oe(R, ((e, t) => { if (I.current.size) { const r = w.findIndex(((e) => e.key === t.key)); w.splice(r, 1); } })), Mt((() => { oe(I.current.size ? I.current : R, ((e, t) => { const r = e.phase; const n = e.payload; const i = t.ctrl; t.phase = r, y === null || void 0 === y || y.add(i), L && r == 'enter' && i.start({ default: D }), n && (sr(i, n.ref), !i.ref && !y || O.current ? (i.start(n), O.current && (O.current = !1)) : i.update(n)); })); }), s ? void 0 : r); const j = function (e) { return i.createElement(i.Fragment, null, w.map(((t, r) => { const n = (R.get(t) || t.ctrl).springs; const a = e(z({}, n), t.item, t, r); return a && a.type ? i.createElement(a.type, z(z({}, a.props), {}, { key: ie.str(t.key) || ie.num(t.key) ? t.key : t.ctrl.id, ref: a.ref })) : a; }))); }; return y ? [j, y] : j;
    } var on = 1; const sn = (function (e) { x(r, e); const t = C(r); function r(e, n) { let i; (0, w.Z)(this, r), (i = t.call(this)).source = e, i.idle = !0, i._active = new Set(), i.calc = qe.apply(void 0, P(n)); const a = i._get(); const o = Vt(a); return Ot(M(i), o.create(a)), i; } return (0, b.Z)(r, [{ key: 'advance', value(e) { const t = this._get(); ae(t, this.get()) || (It(this).setValue(t), this._onChange(t, this.idle)), !this.idle && ln(this._active) && cn(this); } }, { key: '_get', value() { const e = ie.arr(this.source) ? this.source.map(rt) : ue(rt(this.source)); return this.calc.apply(this, P(e)); } }, { key: '_start', value() { const e = this; this.idle && !ln(this._active) && (this.idle = !1, oe(Dt(this), ((e) => { e.done = !1; })), j.skipAnimation ? (B.batchedUpdates((() => e.advance())), cn(this)) : xe.start(this)); } }, { key: '_attach', value() { const e = this; let t = 1; oe(ue(this.source), ((r) => { tt(r) && st(r, e), xr(r) && (r.idle || e._active.add(r), t = Math.max(t, r.priority + 1)); })), this.priority = t, this._start(); } }, { key: '_detach', value() { const e = this; oe(ue(this.source), ((t) => { tt(t) && ut(t, e); })), this._active.clear(), cn(this); } }, { key: 'eventObserved', value(e) { e.type == 'change' ? e.idle ? this.advance() : (this._active.add(e.parent), this._start()) : e.type == 'idle' ? this._active.delete(e.parent) : e.type == 'priority' && (this.priority = ue(this.source).reduce(((e, t) => Math.max(e, (xr(t) ? t.priority : 0) + 1)), 0)); } }]), r; }(Sr)); function un(e) { return !1 !== e.idle; } function ln(e) { return !e.size || Array.from(e).every(un); } function cn(e) { e.idle || (e.idle = !0, oe(Dt(e), ((e) => { e.done = !0; })), it(e, { type: 'idle', parent: e })); }j.assign({ createStringInterpolator: bt, to(e, t) { return new sn(e, t); } }); xe.advance; const hn = __webpack_require__(4164); const fn = ['style', 'children', 'scrollTop', 'scrollLeft', 'viewBox']; const dn = ['x', 'y', 'z']; const pn = ['scrollTop', 'scrollLeft']; const mn = /^--/; function vn(e, t) { return t == null || typeof t === 'boolean' || t === '' ? '' : typeof t !== 'number' || t === 0 || mn.test(e) || yn.hasOwnProperty(e) && yn[e] ? (`${t}`).trim() : `${t}px`; } const gn = {}; var yn = {
      animationIterationCount: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0,
    }; const bn = ['Webkit', 'Ms', 'Moz', 'O']; yn = Object.keys(yn).reduce(((e, t) => (bn.forEach(((r) => e[(function (e, t) { return e + t.charAt(0).toUpperCase() + t.substring(1); }(r, t))] = e[t])), e)), yn); const wn = /^(matrix|translate|scale|rotate|skew)/; const kn = /^(translate)/; const xn = /^(rotate|skew)/; const _n = function (e, t) { return ie.num(e) && e !== 0 ? e + t : e; }; const Sn = function e(t, r) { return ie.arr(t) ? t.every(((t) => e(t, r))) : ie.num(t) ? t === r : parseFloat(t) === r; }; const Mn = (function (e) { x(r, e); const t = C(r); function r(e) { const n = e.x; const i = e.y; const a = e.z; const o = v(e, dn); (0, w.Z)(this, r); const s = []; const u = []; return (n || i || a) && (s.push([n || 0, i || 0, a || 0]), u.push(((e) => ['translate3d('.concat(e.map(((e) => _n(e, 'px'))).join(','), ')'), Sn(e, 0)]))), se(o, ((e, t) => { if (t === 'transform')s.push([e || '']), u.push(((e) => [e, e === ''])); else if (wn.test(t)) { if (delete o[t], ie.und(e)) return; const r = kn.test(t) ? 'px' : xn.test(t) ? 'deg' : ''; s.push(ue(e)), u.push(t === 'rotate3d' ? (e) => { const t = d(e, 4); const n = t[0]; const i = t[1]; const a = t[2]; const o = t[3]; return ['rotate3d('.concat(n, ',').concat(i, ',').concat(a, ',').concat(_n(o, r), ')'), Sn(o, 0)]; } : (e) => [''.concat(t, '(').concat(e.map(((e) => _n(e, r))).join(','), ')'), Sn(e, t.startsWith('scale') ? 1 : 0)]); } })), s.length && (o.transform = new En(s, u)), t.call(this, o); } return (0, b.Z)(r); }(Ft)); var En = (function (e) { x(r, e); const t = C(r); function r(e, n) { let i; return (0, w.Z)(this, r), (i = t.call(this)).inputs = e, i.transforms = n, i._value = null, i; } return (0, b.Z)(r, [{ key: 'get', value() { return this._value || (this._value = this._get()); } }, { key: '_get', value() { const e = this; let t = ''; let r = !0; return oe(this.inputs, ((n, i) => { const a = rt(n[0]); const o = d(e.transforms[i](ie.arr(a) ? a : n.map(rt)), 2); const s = o[0]; const u = o[1]; t += ` ${s}`, r = r && u; })), r ? 'none' : t; } }, { key: 'observerAdded', value(e) { const t = this; e == 1 && oe(this.inputs, ((e) => oe(e, ((e) => tt(e) && st(e, t))))); } }, { key: 'observerRemoved', value(e) { const t = this; e == 0 && oe(this.inputs, ((e) => oe(e, ((e) => tt(e) && ut(e, t))))); } }, { key: 'eventObserved', value(e) { e.type == 'change' && (this._value = null), it(this, e); } }]), r; }(at)); j.assign({
      batchedUpdates: hn.unstable_batchedUpdates,
      createStringInterpolator: bt,
      colors: {
        transparent: 0, aliceblue: 4042850303, antiquewhite: 4209760255, aqua: 16777215, aquamarine: 2147472639, azure: 4043309055, beige: 4126530815, bisque: 4293182719, black: 255, blanchedalmond: 4293643775, blue: 65535, blueviolet: 2318131967, brown: 2771004159, burlywood: 3736635391, burntsienna: 3934150143, cadetblue: 1604231423, chartreuse: 2147418367, chocolate: 3530104575, coral: 4286533887, cornflowerblue: 1687547391, cornsilk: 4294499583, crimson: 3692313855, cyan: 16777215, darkblue: 35839, darkcyan: 9145343, darkgoldenrod: 3095792639, darkgray: 2846468607, darkgreen: 6553855, darkgrey: 2846468607, darkkhaki: 3182914559, darkmagenta: 2332068863, darkolivegreen: 1433087999, darkorange: 4287365375, darkorchid: 2570243327, darkred: 2332033279, darksalmon: 3918953215, darkseagreen: 2411499519, darkslateblue: 1211993087, darkslategray: 793726975, darkslategrey: 793726975, darkturquoise: 13554175, darkviolet: 2483082239, deeppink: 4279538687, deepskyblue: 12582911, dimgray: 1768516095, dimgrey: 1768516095, dodgerblue: 512819199, firebrick: 2988581631, floralwhite: 4294635775, forestgreen: 579543807, fuchsia: 4278255615, gainsboro: 3705462015, ghostwhite: 4177068031, gold: 4292280575, goldenrod: 3668254975, gray: 2155905279, green: 8388863, greenyellow: 2919182335, grey: 2155905279, honeydew: 4043305215, hotpink: 4285117695, indianred: 3445382399, indigo: 1258324735, ivory: 4294963455, khaki: 4041641215, lavender: 3873897215, lavenderblush: 4293981695, lawngreen: 2096890111, lemonchiffon: 4294626815, lightblue: 2916673279, lightcoral: 4034953471, lightcyan: 3774873599, lightgoldenrodyellow: 4210742015, lightgray: 3553874943, lightgreen: 2431553791, lightgrey: 3553874943, lightpink: 4290167295, lightsalmon: 4288707327, lightseagreen: 548580095, lightskyblue: 2278488831, lightslategray: 2005441023, lightslategrey: 2005441023, lightsteelblue: 2965692159, lightyellow: 4294959359, lime: 16711935, limegreen: 852308735, linen: 4210091775, magenta: 4278255615, maroon: 2147483903, mediumaquamarine: 1724754687, mediumblue: 52735, mediumorchid: 3126187007, mediumpurple: 2473647103, mediumseagreen: 1018393087, mediumslateblue: 2070474495, mediumspringgreen: 16423679, mediumturquoise: 1221709055, mediumvioletred: 3340076543, midnightblue: 421097727, mintcream: 4127193855, mistyrose: 4293190143, moccasin: 4293178879, navajowhite: 4292783615, navy: 33023, oldlace: 4260751103, olive: 2155872511, olivedrab: 1804477439, orange: 4289003775, orangered: 4282712319, orchid: 3664828159, palegoldenrod: 4008225535, palegreen: 2566625535, paleturquoise: 2951671551, palevioletred: 3681588223, papayawhip: 4293907967, peachpuff: 4292524543, peru: 3448061951, pink: 4290825215, plum: 3718307327, powderblue: 2967529215, purple: 2147516671, rebeccapurple: 1714657791, red: 4278190335, rosybrown: 3163525119, royalblue: 1097458175, saddlebrown: 2336560127, salmon: 4202722047, sandybrown: 4104413439, seagreen: 780883967, seashell: 4294307583, sienna: 2689740287, silver: 3233857791, skyblue: 2278484991, slateblue: 1784335871, slategray: 1887473919, slategrey: 1887473919, snow: 4294638335, springgreen: 16744447, steelblue: 1182971135, tan: 3535047935, teal: 8421631, thistle: 3636451583, tomato: 4284696575, turquoise: 1088475391, violet: 4001558271, wheat: 4125012991, white: 4294967295, whitesmoke: 4126537215, yellow: 4294902015, yellowgreen: 2597139199,
      },
    }); const Cn = (function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.applyAnimatedValues; const n = void 0 === r ? function () { return !1; } : r; const i = t.createAnimatedStyle; const a = void 0 === i ? function (e) { return new Ft(e); } : i; const o = t.getComponentProps; const s = { applyAnimatedValues: n, createAnimatedStyle: a, getComponentProps: void 0 === o ? function (e) { return e; } : o }; const u = function e(t) { const r = Wt(t) || 'Anonymous'; return (t = ie.str(t) ? e[t] || (e[t] = Yt(t, s)) : t[qt] || (t[qt] = Yt(t, s))).displayName = 'Animated('.concat(r, ')'), t; }; return se(e, ((t, r) => { ie.arr(e) && (r = Wt(t)), u[r] = u(t); })), { animated: u }; }(['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', 'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'], { applyAnimatedValues(e, t) { if (!e.nodeType || !e.setAttribute) return !1; const r = e.nodeName === 'filter' || e.parentNode && e.parentNode.nodeName === 'filter'; const n = t.style; const i = t.children; const a = t.scrollTop; const o = t.scrollLeft; const s = t.viewBox; const u = v(t, fn); const l = Object.values(u); const c = Object.keys(u).map(((t) => (r || e.hasAttribute(t) ? t : gn[t] || (gn[t] = t.replace(/([A-Z])/g, ((e) => '-' + e.toLowerCase())))))); for (const h in void 0 !== i && (e.textContent = i), n) if (n.hasOwnProperty(h)) { const f = vn(h, n[h]); mn.test(h) ? e.style.setProperty(h, f) : e.style[h] = f; }c.forEach(((t, r) => { e.setAttribute(t, l[r]); })), void 0 !== a && (e.scrollTop = a), void 0 !== o && (e.scrollLeft = o), void 0 !== s && e.setAttribute('viewBox', s); }, createAnimatedStyle(e) { return new Mn(e); }, getComponentProps(e) { e.scrollTop, e.scrollLeft; return v(e, pn); } })); const Pn = Cn.animated; function An() { const e = d((0, i.useState)({ width: void 0, height: void 0 }), 2); const t = e[0]; const r = e[1]; return (0, i.useEffect)((() => { const e = function () { r({ width: window.innerWidth, height: window.innerHeight }); }; return e(), window.addEventListener('resize', e), function () { window.removeEventListener('resize', e); }; }), []), t; } function Tn() { return Tn = Object.assign ? Object.assign.bind() : function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e; }, Tn.apply(this, arguments); } function Rn(e) { let t; let r; let n = ''; if (typeof e === 'string' || typeof e === 'number')n += e; else if (typeof e === 'object') if (Array.isArray(e)) for (t = 0; t < e.length; t++)e[t] && (r = Rn(e[t])) && (n && (n += ' '), n += r); else for (t in e)e[t] && (n && (n += ' '), n += t); return n; } const In = function () { for (var e, t, r = 0, n = ''; r < arguments.length;)(e = arguments[r++]) && (t = Rn(e)) && (n && (n += ' '), n += t); return n; }; function On(e) { const t = Object.create(null); return function (r) { return void 0 === t[r] && (t[r] = e(r)), t[r]; }; } const Dn = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; const zn = On(((e) => Dn.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91)); const Nn = (function () { function e(e) { const t = this; this._insertTag = function (e) { let r; r = t.tags.length === 0 ? t.insertionPoint ? t.insertionPoint.nextSibling : t.prepend ? t.container.firstChild : t.before : t.tags[t.tags.length - 1].nextSibling, t.container.insertBefore(e, r), t.tags.push(e); }, this.isSpeedy = void 0 === e.speedy || e.speedy, this.tags = [], this.ctr = 0, this.nonce = e.nonce, this.key = e.key, this.container = e.container, this.prepend = e.prepend, this.insertionPoint = e.insertionPoint, this.before = null; } const t = e.prototype; return t.hydrate = function (e) { e.forEach(this._insertTag); }, t.insert = function (e) { this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(function (e) { const t = document.createElement('style'); return t.setAttribute('data-emotion', e.key), void 0 !== e.nonce && t.setAttribute('nonce', e.nonce), t.appendChild(document.createTextNode('')), t.setAttribute('data-s', ''), t; }(this)); const t = this.tags[this.tags.length - 1]; if (this.isSpeedy) { const r = (function (e) { if (e.sheet) return e.sheet; for (let t = 0; t < document.styleSheets.length; t++) if (document.styleSheets[t].ownerNode === e) return document.styleSheets[t]; }(t)); try { r.insertRule(e, r.cssRules.length); } catch (n) { 0; } } else t.appendChild(document.createTextNode(e)); this.ctr++; }, t.flush = function () { this.tags.forEach(((e) => e.parentNode && e.parentNode.removeChild(e))), this.tags = [], this.ctr = 0; }, e; }()); const Ln = Math.abs; const jn = String.fromCharCode; const Fn = Object.assign; function Bn(e) { return e.trim(); } function Un(e, t, r) { return e.replace(t, r); } function Vn(e, t) { return e.indexOf(t); } function Yn(e, t) { return 0 | e.charCodeAt(t); } function Hn(e, t, r) { return e.slice(t, r); } function qn(e) { return e.length; } function Wn(e) { return e.length; } function Xn(e, t) { return t.push(e), e; } let Gn = 1; let $n = 1; let Zn = 0; let Kn = 0; let Qn = 0; let Jn = ''; function ei(e, t, r, n, i, a, o) {
      return {
        value: e, root: t, parent: r, type: n, props: i, children: a, line: Gn, column: $n, length: o, return: '',
      };
    } function ti(e, t) { return Fn(ei('', null, null, '', null, null, 0), e, { length: -e.length }, t); } function ri() { return Qn = Kn > 0 ? Yn(Jn, --Kn) : 0, $n--, Qn === 10 && ($n = 1, Gn--), Qn; } function ni() { return Qn = Kn < Zn ? Yn(Jn, Kn++) : 0, $n++, Qn === 10 && ($n = 1, Gn++), Qn; } function ii() { return Yn(Jn, Kn); } function ai() { return Kn; } function oi(e, t) { return Hn(Jn, e, t); } function si(e) { switch (e) { case 0: case 9: case 10: case 13: case 32: return 5; case 33: case 43: case 44: case 47: case 62: case 64: case 126: case 59: case 123: case 125: return 4; case 58: return 3; case 34: case 39: case 40: case 91: return 2; case 41: case 93: return 1; } return 0; } function ui(e) { return Gn = $n = 1, Zn = qn(Jn = e), Kn = 0, []; } function li(e) { return Jn = '', e; } function ci(e) { return Bn(oi(Kn - 1, di(e === 91 ? e + 2 : e === 40 ? e + 1 : e))); } function hi(e) { for (;(Qn = ii()) && Qn < 33;)ni(); return si(e) > 2 || si(Qn) > 3 ? '' : ' '; } function fi(e, t) { for (;--t && ni() && !(Qn < 48 || Qn > 102 || Qn > 57 && Qn < 65 || Qn > 70 && Qn < 97););return oi(e, ai() + (t < 6 && ii() == 32 && ni() == 32)); } function di(e) { for (;ni();) switch (Qn) { case e: return Kn; case 34: case 39: e !== 34 && e !== 39 && di(Qn); break; case 40: e === 41 && di(e); break; case 92: ni(); } return Kn; } function pi(e, t) { for (;ni() && e + Qn !== 57 && (e + Qn !== 84 || ii() !== 47););return `/*${oi(t, Kn - 1)}*${jn(e === 47 ? e : ni())}`; } function mi(e) { for (;!si(ii());)ni(); return oi(e, Kn); } const vi = '-ms-'; const gi = '-moz-'; const yi = '-webkit-'; const bi = 'comm'; const wi = 'rule'; const ki = 'decl'; const xi = '@keyframes'; function _i(e, t) { for (var r = '', n = Wn(e), i = 0; i < n; i++)r += t(e[i], i, e, t) || ''; return r; } function Si(e, t, r, n) { switch (e.type) { case '@layer': if (e.children.length) break; case '@import': case ki: return e.return = e.return || e.value; case bi: return ''; case xi: return e.return = `${e.value}{${_i(e.children, n)}}`; case wi: e.value = e.props.join(','); } return qn(r = _i(e.children, n)) ? e.return = `${e.value}{${r}}` : ''; } function Mi(e) { return li(Ei('', null, null, null, [''], e = ui(e), 0, [0], e)); } function Ei(e, t, r, n, i, a, o, s, u) { for (let l = 0, c = 0, h = o, f = 0, d = 0, p = 0, m = 1, v = 1, g = 1, y = 0, b = '', w = i, k = a, x = n, _ = b; v;) switch (p = y, y = ni()) { case 40: if (p != 108 && Yn(_, h - 1) == 58) { Vn(_ += Un(ci(y), '&', '&\f'), '&\f') != -1 && (g = -1); break; } case 34: case 39: case 91: _ += ci(y); break; case 9: case 10: case 13: case 32: _ += hi(p); break; case 92: _ += fi(ai() - 1, 7); continue; case 47: switch (ii()) { case 42: case 47: Xn(Pi(pi(ni(), ai()), t, r), u); break; default: _ += '/'; } break; case 123 * m: s[l++] = qn(_) * g; case 125 * m: case 59: case 0: switch (y) { case 0: case 125: v = 0; case 59 + c: g == -1 && (_ = Un(_, /\f/g, '')), d > 0 && qn(_) - h && Xn(d > 32 ? Ai(`${_};`, n, r, h - 1) : Ai(`${Un(_, ' ', '')};`, n, r, h - 2), u); break; case 59: _ += ';'; default: if (Xn(x = Ci(_, t, r, l, c, i, s, b, w = [], k = [], h), a), y === 123) if (c === 0)Ei(_, t, x, x, w, a, h, s, k); else switch (f === 99 && Yn(_, 3) === 110 ? 100 : f) { case 100: case 108: case 109: case 115: Ei(e, x, x, n && Xn(Ci(e, x, x, 0, 0, i, s, b, i, w = [], h), k), i, k, h, s, n ? w : k); break; default: Ei(_, x, x, x, [''], k, 0, s, k); } }l = c = d = 0, m = g = 1, b = _ = '', h = o; break; case 58: h = 1 + qn(_), d = p; default: if (m < 1) if (y == 123)--m; else if (y == 125 && m++ == 0 && ri() == 125) continue; switch (_ += jn(y), y * m) { case 38: g = c > 0 ? 1 : (_ += '\f', -1); break; case 44: s[l++] = (qn(_) - 1) * g, g = 1; break; case 64: ii() === 45 && (_ += ci(ni())), f = ii(), c = h = qn(b = _ += mi(ai())), y++; break; case 45: p === 45 && qn(_) == 2 && (m = 0); } } return a; } function Ci(e, t, r, n, i, a, o, s, u, l, c) { for (let h = i - 1, f = i === 0 ? a : [''], d = Wn(f), p = 0, m = 0, v = 0; p < n; ++p) for (let g = 0, y = Hn(e, h + 1, h = Ln(m = o[p])), b = e; g < d; ++g)(b = Bn(m > 0 ? `${f[g]} ${y}` : Un(y, /&\f/g, f[g]))) && (u[v++] = b); return ei(e, t, r, i === 0 ? wi : s, u, l, c); } function Pi(e, t, r) { return ei(e, t, r, bi, jn(Qn), Hn(e, 2, -2), 0); } function Ai(e, t, r, n) { return ei(e, t, r, ki, Hn(e, 0, n), Hn(e, n + 1, -1), n); } const Ti = function (e, t, r) { for (let n = 0, i = 0; n = i, i = ii(), n === 38 && i === 12 && (t[r] = 1), !si(i);)ni(); return oi(e, Kn); }; const Ri = function (e, t) { return li(function (e, t) { let r = -1; let n = 44; do { switch (si(n)) { case 0: n === 38 && ii() === 12 && (t[r] = 1), e[r] += Ti(Kn - 1, t, r); break; case 2: e[r] += ci(n); break; case 4: if (n === 44) { e[++r] = ii() === 58 ? '&\f' : '', t[r] = e[r].length; break; } default: e[r] += jn(n); } } while (n = ni()); return e; }(ui(e), t)); }; const Ii = new WeakMap(); const Oi = function (e) { if (e.type === 'rule' && e.parent && !(e.length < 1)) { for (var t = e.value, r = e.parent, n = e.column === r.column && e.line === r.line; r.type !== 'rule';) if (!(r = r.parent)) return; if ((e.props.length !== 1 || t.charCodeAt(0) === 58 || Ii.get(r)) && !n) { Ii.set(e, !0); for (let i = [], a = Ri(t, i), o = r.props, s = 0, u = 0; s < a.length; s++) for (let l = 0; l < o.length; l++, u++)e.props[u] = i[s] ? a[s].replace(/&\f/g, o[l]) : `${o[l]} ${a[s]}`; } } }; const Di = function (e) { if (e.type === 'decl') { const t = e.value; t.charCodeAt(0) === 108 && t.charCodeAt(2) === 98 && (e.return = '', e.value = ''); } }; function zi(e, t) { switch (function (e, t) { return 45 ^ Yn(e, 0) ? (((t << 2 ^ Yn(e, 0)) << 2 ^ Yn(e, 1)) << 2 ^ Yn(e, 2)) << 2 ^ Yn(e, 3) : 0; }(e, t)) { case 5103: return `${yi}print-${e}${e}`; case 5737: case 4201: case 3177: case 3433: case 1641: case 4457: case 2921: case 5572: case 6356: case 5844: case 3191: case 6645: case 3005: case 6391: case 5879: case 5623: case 6135: case 4599: case 4855: case 4215: case 6389: case 5109: case 5365: case 5621: case 3829: return yi + e + e; case 5349: case 4246: case 4810: case 6968: case 2756: return yi + e + gi + e + vi + e + e; case 6828: case 4268: return yi + e + vi + e + e; case 6165: return `${yi + e + vi}flex-${e}${e}`; case 5187: return yi + e + Un(e, /(\w+).+(:[^]+)/, `${yi}box-$1$2${vi}flex-$1$2`) + e; case 5443: return `${yi + e + vi}flex-item-${Un(e, /flex-|-self/, '')}${e}`; case 4675: return `${yi + e + vi}flex-line-pack${Un(e, /align-content|flex-|-self/, '')}${e}`; case 5548: return yi + e + vi + Un(e, 'shrink', 'negative') + e; case 5292: return yi + e + vi + Un(e, 'basis', 'preferred-size') + e; case 6060: return `${yi}box-${Un(e, '-grow', '')}${yi}${e}${vi}${Un(e, 'grow', 'positive')}${e}`; case 4554: return yi + Un(e, /([^-])(transform)/g, `$1${yi}$2`) + e; case 6187: return Un(Un(Un(e, /(zoom-|grab)/, `${yi}$1`), /(image-set)/, `${yi}$1`), e, '') + e; case 5495: case 3959: return Un(e, /(image-set\([^]*)/, `${yi}$1$\`$1`); case 4968: return Un(Un(e, /(.+:)(flex-)?(.*)/, `${yi}box-pack:$3${vi}flex-pack:$3`), /s.+-b[^;]+/, 'justify') + yi + e + e; case 4095: case 3583: case 4068: case 2532: return Un(e, /(.+)-inline(.+)/, `${yi}$1$2`) + e; case 8116: case 7059: case 5753: case 5535: case 5445: case 5701: case 4933: case 4677: case 5533: case 5789: case 5021: case 4765: if (qn(e) - 1 - t > 6) switch (Yn(e, t + 1)) { case 109: if (Yn(e, t + 4) !== 45) break; case 102: return Un(e, /(.+:)(.+)-([^]+)/, `$1${yi}$2-$3$1${gi}${Yn(e, t + 3) == 108 ? '$3' : '$2-$3'}`) + e; case 115: return ~Vn(e, 'stretch') ? zi(Un(e, 'stretch', 'fill-available'), t) + e : e; } break; case 4949: if (Yn(e, t + 1) !== 115) break; case 6444: switch (Yn(e, qn(e) - 3 - (~Vn(e, '!important') && 10))) { case 107: return Un(e, ':', `:${yi}`) + e; case 101: return Un(e, /(.+:)([^;!]+)(;|!.+)?/, `$1${yi}${Yn(e, 14) === 45 ? 'inline-' : ''}box$3$1${yi}$2$3$1${vi}$2box$3`) + e; } break; case 5936: switch (Yn(e, t + 11)) { case 114: return yi + e + vi + Un(e, /[svh]\w+-[tblr]{2}/, 'tb') + e; case 108: return yi + e + vi + Un(e, /[svh]\w+-[tblr]{2}/, 'tb-rl') + e; case 45: return yi + e + vi + Un(e, /[svh]\w+-[tblr]{2}/, 'lr') + e; } return yi + e + vi + e + e; } return e; } const Ni = [function (e, t, r, n) { if (e.length > -1 && !e.return) switch (e.type) { case ki: e.return = zi(e.value, e.length); break; case xi: return _i([ti(e, { value: Un(e.value, '@', `@${yi}`) })], n); case wi: if (e.length) return (function (e, t) { return e.map(t).join(''); }(e.props, ((t) => { switch (function (e, t) { return (e = t.exec(e)) ? e[0] : e; }(t, /(::plac\w+|:read-\w+)/)) { case ':read-only': case ':read-write': return _i([ti(e, { props: [Un(t, /:(read-\w+)/, ':-moz-$1')] })], n); case '::placeholder': return _i([ti(e, { props: [Un(t, /:(plac\w+)/, `:${yi}input-$1`)] }), ti(e, { props: [Un(t, /:(plac\w+)/, ':-moz-$1')] }), ti(e, { props: [Un(t, /:(plac\w+)/, `${vi}input-$1`)] })], n); } return ''; }))); } }]; const Li = function (e) {
      const t = e.key; if (t === 'css') { const r = document.querySelectorAll('style[data-emotion]:not([data-s])'); Array.prototype.forEach.call(r, ((e) => { e.getAttribute('data-emotion').indexOf(' ') !== -1 && (document.head.appendChild(e), e.setAttribute('data-s', '')); })); } const n = e.stylisPlugins || Ni; let i; let a; const o = {}; const s = []; i = e.container || document.head, Array.prototype.forEach.call(document.querySelectorAll(`style[data-emotion^="${t} "]`), ((e) => { for (let t = e.getAttribute('data-emotion').split(' '), r = 1; r < t.length; r++)o[t[r]] = !0; s.push(e); })); let u; let l; const c = [Si, (l = function (e) { u.insert(e); }, function (e) { e.root || (e = e.return) && l(e); })]; const h = (function (e) { const t = Wn(e); return function (r, n, i, a) { for (var o = '', s = 0; s < t; s++)o += e[s](r, n, i, a) || ''; return o; }; }([Oi, Di].concat(n, c))); a = function (e, t, r, n) { u = r, _i(Mi(e ? `${e}{${t.styles}}` : t.styles), h), n && (f.inserted[t.name] = !0); }; var f = {
        key: t,
        sheet: new Nn({
          key: t, container: i, nonce: e.nonce, speedy: e.speedy, prepend: e.prepend, insertionPoint: e.insertionPoint,
        }),
        nonce: e.nonce,
        inserted: o,
        registered: {},
        insert: a,
      }; return f.sheet.hydrate(s), f;
    }; const ji = {
      animationIterationCount: 1, aspectRatio: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1,
    }; const Fi = /[A-Z]|^ms/g; const Bi = /_EMO_([^_]+?)_([^]*?)_EMO_/g; const Ui = function (e) { return e.charCodeAt(1) === 45; }; const Vi = function (e) { return e != null && typeof e !== 'boolean'; }; const Yi = On(((e) => (Ui(e) ? e : e.replace(Fi, '-$&').toLowerCase()))); const Hi = function (e, t) { switch (e) { case 'animation': case 'animationName': if (typeof t === 'string') return t.replace(Bi, ((e, t, r) => (Wi = { name: t, styles: r, next: Wi }, t))); } return ji[e] === 1 || Ui(e) || typeof t !== 'number' || t === 0 ? t : `${t}px`; }; function qi(e, t, r) { if (r == null) return ''; if (void 0 !== r.__emotion_styles) return r; switch (typeof r) { case 'boolean': return ''; case 'object': if (r.anim === 1) return Wi = { name: r.name, styles: r.styles, next: Wi }, r.name; if (void 0 !== r.styles) { let n = r.next; if (void 0 !== n) for (;void 0 !== n;)Wi = { name: n.name, styles: n.styles, next: Wi }, n = n.next; return `${r.styles};`; } return (function (e, t, r) { let n = ''; if (Array.isArray(r)) for (let i = 0; i < r.length; i++)n += `${qi(e, t, r[i])};`; else for (const a in r) { const o = r[a]; if (typeof o !== 'object')t != null && void 0 !== t[o] ? n += `${a}{${t[o]}}` : Vi(o) && (n += `${Yi(a)}:${Hi(a, o)};`); else if (!Array.isArray(o) || typeof o[0] !== 'string' || t != null && void 0 !== t[o[0]]) { const s = qi(e, t, o); switch (a) { case 'animation': case 'animationName': n += `${Yi(a)}:${s};`; break; default: n += `${a}{${s}}`; } } else for (let u = 0; u < o.length; u++)Vi(o[u]) && (n += `${Yi(a)}:${Hi(a, o[u])};`); } return n; }(e, t, r)); case 'function': if (void 0 !== e) { const i = Wi; const a = r(e); return Wi = i, qi(e, t, a); } } if (t == null) return r; const o = t[r]; return void 0 !== o ? o : r; } let Wi; const Xi = /label:\s*([^\s;\n{]+)\s*(;|$)/g; const Gi = function (e, t, r) { if (e.length === 1 && typeof e[0] === 'object' && e[0] !== null && void 0 !== e[0].styles) return e[0]; let n = !0; let i = ''; Wi = void 0; const a = e[0]; a == null || void 0 === a.raw ? (n = !1, i += qi(r, t, a)) : i += a[0]; for (let o = 1; o < e.length; o++)i += qi(r, t, e[o]), n && (i += a[o]); Xi.lastIndex = 0; for (var s, u = ''; (s = Xi.exec(i)) !== null;)u += `-${s[1]}`; const l = (function (e) { for (var t, r = 0, n = 0, i = e.length; i >= 4; ++n, i -= 4)t = 1540483477 * (65535 & (t = 255 & e.charCodeAt(n) | (255 & e.charCodeAt(++n)) << 8 | (255 & e.charCodeAt(++n)) << 16 | (255 & e.charCodeAt(++n)) << 24)) + (59797 * (t >>> 16) << 16), r = 1540483477 * (65535 & (t ^= t >>> 24)) + (59797 * (t >>> 16) << 16) ^ 1540483477 * (65535 & r) + (59797 * (r >>> 16) << 16); switch (i) { case 3: r ^= (255 & e.charCodeAt(n + 2)) << 16; case 2: r ^= (255 & e.charCodeAt(n + 1)) << 8; case 1: r = 1540483477 * (65535 & (r ^= 255 & e.charCodeAt(n))) + (59797 * (r >>> 16) << 16); } return (((r = 1540483477 * (65535 & (r ^= r >>> 13)) + (59797 * (r >>> 16) << 16)) ^ r >>> 15) >>> 0).toString(36); }(i)) + u; return { name: l, styles: i, next: Wi }; }; const $i = !!a.useInsertionEffect && a.useInsertionEffect; const Zi = $i || function (e) { return e(); }; const Ki = ($i || i.useLayoutEffect, i.createContext(typeof HTMLElement !== 'undefined' ? Li({ key: 'css' }) : null)); Ki.Provider; const Qi = function (e) { return (0, i.forwardRef)(((t, r) => { const n = (0, i.useContext)(Ki); return e(t, n, r); })); }; const Ji = i.createContext({}); const ea = function (e, t, r) { const n = `${e.key}-${t.name}`; !1 === r && void 0 === e.registered[n] && (e.registered[n] = t.styles); }; const ta = zn; const ra = function (e) { return e !== 'theme'; }; const na = function (e) { return typeof e === 'string' && e.charCodeAt(0) > 96 ? ta : ra; }; const ia = function (e, t, r) { let n; if (t) { const i = t.shouldForwardProp; n = e.__emotion_forwardProp && i ? function (t) { return e.__emotion_forwardProp(t) && i(t); } : i; } return typeof n !== 'function' && r && (n = e.__emotion_forwardProp), n; }; const aa = function (e) { const t = e.cache; const r = e.serialized; const n = e.isStringTag; return ea(t, r, n), Zi((() => (function (e, t, r) { ea(e, t, r); const n = `${e.key}-${t.name}`; if (void 0 === e.inserted[t.name]) { let i = t; do { e.insert(t === i ? `.${n}` : '', i, e.sheet, !0), i = i.next; } while (void 0 !== i); } }(t, r, n)))), null; }; const oa = function e(t, r) { let n; let a; const o = t.__emotion_real === t; const s = o && t.__emotion_base || t; void 0 !== r && (n = r.label, a = r.target); const u = ia(t, r, o); const l = u || na(s); const c = !l('as'); return function () { const h = arguments; const f = o && void 0 !== t.__emotion_styles ? t.__emotion_styles.slice(0) : []; if (void 0 !== n && f.push(`label:${n};`), h[0] == null || void 0 === h[0].raw)f.push.apply(f, h); else { 0, f.push(h[0][0]); for (let d = h.length, p = 1; p < d; p++)f.push(h[p], h[0][p]); } const m = Qi(((e, t, r) => { const n = c && e.as || s; let o = ''; const h = []; let d = e; if (e.theme == null) { for (const p in d = {}, e)d[p] = e[p]; d.theme = i.useContext(Ji); } typeof e.className === 'string' ? o = (function (e, t, r) { let n = ''; return r.split(' ').forEach(((r) => { void 0 !== e[r] ? t.push(`${e[r]};`) : n += `${r} `; })), n; }(t.registered, h, e.className)) : e.className != null && (o = `${e.className} `); const m = Gi(f.concat(h), t.registered, d); o += `${t.key}-${m.name}`, void 0 !== a && (o += ` ${a}`); const v = c && void 0 === u ? na(n) : l; const g = {}; for (const y in e)c && y === 'as' || v(y) && (g[y] = e[y]); return g.className = o, g.ref = r, i.createElement(i.Fragment, null, i.createElement(aa, { cache: t, serialized: m, isStringTag: typeof n === 'string' }), i.createElement(n, g)); })); return m.displayName = void 0 !== n ? n : `Styled(${typeof s === 'string' ? s : s.displayName || s.name || 'Component'})`, m.defaultProps = t.defaultProps, m.__emotion_real = m, m.__emotion_base = s, m.__emotion_styles = f, m.__emotion_forwardProp = u, Object.defineProperty(m, 'toString', { value() { return `.${a}`; } }), m.withComponent = function (t, n) { return e(t, Tn({}, r, n, { shouldForwardProp: ia(m, n, !0) })).apply(void 0, f); }, m; }; }.bind(); function sa(e, t) { return oa(e, t); }['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', 'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'].forEach(((e) => { oa[e] = oa(e); })); function ua(e) { for (var t = `https://mui.com/production-error/?code=${e}`, r = 1; r < arguments.length; r += 1)t += `&args[]=${encodeURIComponent(arguments[r])}`; return `Minified MUI error #${e}; visit ${t} for the full message.`; } function la(e) { if (typeof e !== 'string') throw new Error(ua(7)); return e.charAt(0).toUpperCase() + e.slice(1); } function ca(e) { return e !== null && typeof e === 'object' && e.constructor === Object; } function ha(e) { if (!ca(e)) return e; const t = {}; return Object.keys(e).forEach(((r) => { t[r] = ha(e[r]); })), t; } function fa(e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : { clone: !0 }; const n = r.clone ? Tn({}, e) : e; return ca(e) && ca(t) && Object.keys(t).forEach(((i) => { i !== '__proto__' && (ca(t[i]) && i in e && ca(e[i]) ? n[i] = fa(e[i], t[i], r) : r.clone ? n[i] = ca(t[i]) ? ha(t[i]) : t[i] : n[i] = t[i]); })), n; } const da = function (e, t) { return t ? fa(e, t, { clone: !1 }) : e; }; const pa = {
      xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536,
    }; const ma = { keys: ['xs', 'sm', 'md', 'lg', 'xl'], up(e) { return '@media (min-width:'.concat(pa[e], 'px)'); } }; function va(e, t, r) { const n = e.theme || {}; if (Array.isArray(t)) { const i = n.breakpoints || ma; return t.reduce(((e, n, a) => (e[i.up(i.keys[a])] = r(t[a]), e)), {}); } if (typeof t === 'object') { const a = n.breakpoints || ma; return Object.keys(t).reduce(((e, n) => { if (Object.keys(a.values || pa).indexOf(n) !== -1) { e[a.up(n)] = r(t[n], n); } else { const i = n; e[i] = t[i]; } return e; }), {}); } return r(t); } function ga() { let e; const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return ((e = t.keys) == null ? void 0 : e.reduce(((e, r) => (e[t.up(r)] = {}, e)), {})) || {}; } function ya(e, t) { return e.reduce(((e, t) => { const r = e[t]; return (!r || Object.keys(r).length === 0) && delete e[t], e; }), t); } function ba(e, t) { const r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; if (!t || typeof t !== 'string') return null; if (e && e.vars && r) { const n = 'vars.'.concat(t).split('.').reduce(((e, t) => (e && e[t] ? e[t] : null)), e); if (n != null) return n; } return t.split('.').reduce(((e, t) => (e && e[t] != null ? e[t] : null)), e); } function wa(e, t, r) { let n; const i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : r; return n = typeof e === 'function' ? e(r) : Array.isArray(e) ? e[r] || i : ba(e, r) || i, t && (n = t(n, i, e)), n; } const ka = function (e) { const t = e.prop; const r = e.cssProperty; const n = void 0 === r ? e.prop : r; const i = e.themeKey; const a = e.transform; const o = function (e) { if (e[t] == null) return null; const r = e[t]; const o = ba(e.theme, i) || {}; return va(e, r, ((e) => { let r = wa(o, a, e); return e === r && typeof e === 'string' && (r = wa(o, a, ''.concat(t).concat(e === 'default' ? '' : la(e)), e)), !1 === n ? r : O({}, n, r); })); }; return o.propTypes = {}, o.filterProps = [t], o; }; const xa = { m: 'margin', p: 'padding' }; const _a = {
      t: 'Top', r: 'Right', b: 'Bottom', l: 'Left', x: ['Left', 'Right'], y: ['Top', 'Bottom'],
    }; const Sa = {
      marginX: 'mx', marginY: 'my', paddingX: 'px', paddingY: 'py',
    }; const Ma = (function (e) { const t = {}; return function (r) { return void 0 === t[r] && (t[r] = e(r)), t[r]; }; }(((e) => { if (e.length > 2) { if (!Sa[e]) return [e]; e = Sa[e]; } const t = d(e.split(''), 2); const r = t[0]; const n = t[1]; const i = xa[r]; const a = _a[n] || ''; return Array.isArray(a) ? a.map(((e) => i + e)) : [i + a]; }))); const Ea = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'marginInline', 'marginInlineStart', 'marginInlineEnd', 'marginBlock', 'marginBlockStart', 'marginBlockEnd']; const Ca = ['p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY', 'paddingInline', 'paddingInlineStart', 'paddingInlineEnd', 'paddingBlock', 'paddingBlockStart', 'paddingBlockEnd']; const Pa = [].concat(Ea, Ca); function Aa(e, t, r, n) { let i; const a = (i = ba(e, t, !1)) != null ? i : r; return typeof a === 'number' ? function (e) { return typeof e === 'string' ? e : a * e; } : Array.isArray(a) ? function (e) { return typeof e === 'string' ? e : a[e]; } : typeof a === 'function' ? a : function () {}; } function Ta(e) { return Aa(e, 'spacing', 8); } function Ra(e, t) { if (typeof t === 'string' || t == null) return t; const r = e(Math.abs(t)); return t >= 0 ? r : typeof r === 'number' ? -r : '-'.concat(r); } function Ia(e, t, r, n) { if (t.indexOf(r) === -1) return null; const i = (function (e, t) { return function (r) { return e.reduce(((e, n) => (e[n] = Ra(t, r), e)), {}); }; }(Ma(r), n)); return va(e, e[r], i); } function Oa(e, t) { const r = Ta(e.theme); return Object.keys(e).map(((n) => Ia(e, t, n, r))).reduce(da, {}); } function Da(e) { return Oa(e, Ea); } function za(e) { return Oa(e, Ca); } function Na(e) { return Oa(e, Pa); }Da.propTypes = {}, Da.filterProps = Ea, za.propTypes = {}, za.filterProps = Ca, Na.propTypes = {}, Na.filterProps = Pa; const La = function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; const n = t.reduce(((e, t) => (t.filterProps.forEach(((r) => { e[r] = t; })), e)), {}); const i = function (e) { return Object.keys(e).reduce(((t, r) => (n[r] ? da(t, n[r](e)) : t)), {}); }; return i.propTypes = {}, i.filterProps = t.reduce(((e, t) => e.concat(t.filterProps)), []), i; }; function ja(e) { return typeof e !== 'number' ? e : ''.concat(e, 'px solid'); } function Fa(e, t) { return ka({ prop: e, themeKey: 'borders', transform: t }); } const Ba = Fa('border', ja); const Ua = Fa('borderTop', ja); const Va = Fa('borderRight', ja); const Ya = Fa('borderBottom', ja); const Ha = Fa('borderLeft', ja); const qa = Fa('borderColor'); const Wa = Fa('borderTopColor'); const Xa = Fa('borderRightColor'); const Ga = Fa('borderBottomColor'); const $a = Fa('borderLeftColor'); const Za = Fa('outline', ja); const Ka = Fa('outlineColor'); const Qa = function (e) { if (void 0 !== e.borderRadius && e.borderRadius !== null) { const t = Aa(e.theme, 'shape.borderRadius', 4); return va(e, e.borderRadius, ((e) => ({ borderRadius: Ra(t, e) }))); } return null; }; Qa.propTypes = {}, Qa.filterProps = ['borderRadius']; La(Ba, Ua, Va, Ya, Ha, qa, Wa, Xa, Ga, $a, Qa, Za, Ka); const Ja = function (e) { if (void 0 !== e.gap && e.gap !== null) { const t = Aa(e.theme, 'spacing', 8); return va(e, e.gap, ((e) => ({ gap: Ra(t, e) }))); } return null; }; Ja.propTypes = {}, Ja.filterProps = ['gap']; const eo = function (e) { if (void 0 !== e.columnGap && e.columnGap !== null) { const t = Aa(e.theme, 'spacing', 8); return va(e, e.columnGap, ((e) => ({ columnGap: Ra(t, e) }))); } return null; }; eo.propTypes = {}, eo.filterProps = ['columnGap']; const to = function (e) { if (void 0 !== e.rowGap && e.rowGap !== null) { const t = Aa(e.theme, 'spacing', 8); return va(e, e.rowGap, ((e) => ({ rowGap: Ra(t, e) }))); } return null; }; to.propTypes = {}, to.filterProps = ['rowGap']; La(Ja, eo, to, ka({ prop: 'gridColumn' }), ka({ prop: 'gridRow' }), ka({ prop: 'gridAutoFlow' }), ka({ prop: 'gridAutoColumns' }), ka({ prop: 'gridAutoRows' }), ka({ prop: 'gridTemplateColumns' }), ka({ prop: 'gridTemplateRows' }), ka({ prop: 'gridTemplateAreas' }), ka({ prop: 'gridArea' })); function ro(e, t) { return t === 'grey' ? t : e; }La(ka({ prop: 'color', themeKey: 'palette', transform: ro }), ka({
      prop: 'bgcolor', cssProperty: 'backgroundColor', themeKey: 'palette', transform: ro,
    }), ka({ prop: 'backgroundColor', themeKey: 'palette', transform: ro })); function no(e) { return e <= 1 && e !== 0 ? ''.concat(100 * e, '%') : e; } const io = ka({ prop: 'width', transform: no }); const ao = function (e) { if (void 0 !== e.maxWidth && e.maxWidth !== null) { return va(e, e.maxWidth, ((t) => { let r; let n; const i = ((r = e.theme) == null || (r = r.breakpoints) == null || (r = r.values) == null ? void 0 : r[t]) || pa[t]; return i ? ((n = e.theme) == null || (n = n.breakpoints) == null ? void 0 : n.unit) !== 'px' ? { maxWidth: ''.concat(i).concat(e.theme.breakpoints.unit) } : { maxWidth: i } : { maxWidth: no(t) }; })); } return null; }; ao.filterProps = ['maxWidth']; const oo = ka({ prop: 'minWidth', transform: no }); const so = ka({ prop: 'height', transform: no }); const uo = ka({ prop: 'maxHeight', transform: no }); const lo = ka({ prop: 'minHeight', transform: no }); const co = (ka({ prop: 'size', cssProperty: 'width', transform: no }), ka({ prop: 'size', cssProperty: 'height', transform: no }), La(io, ao, oo, so, uo, lo, ka({ prop: 'boxSizing' })), {
      border: { themeKey: 'borders', transform: ja }, borderTop: { themeKey: 'borders', transform: ja }, borderRight: { themeKey: 'borders', transform: ja }, borderBottom: { themeKey: 'borders', transform: ja }, borderLeft: { themeKey: 'borders', transform: ja }, borderColor: { themeKey: 'palette' }, borderTopColor: { themeKey: 'palette' }, borderRightColor: { themeKey: 'palette' }, borderBottomColor: { themeKey: 'palette' }, borderLeftColor: { themeKey: 'palette' }, outline: { themeKey: 'borders', transform: ja }, outlineColor: { themeKey: 'palette' }, borderRadius: { themeKey: 'shape.borderRadius', style: Qa }, color: { themeKey: 'palette', transform: ro }, bgcolor: { themeKey: 'palette', cssProperty: 'backgroundColor', transform: ro }, backgroundColor: { themeKey: 'palette', transform: ro }, p: { style: za }, pt: { style: za }, pr: { style: za }, pb: { style: za }, pl: { style: za }, px: { style: za }, py: { style: za }, padding: { style: za }, paddingTop: { style: za }, paddingRight: { style: za }, paddingBottom: { style: za }, paddingLeft: { style: za }, paddingX: { style: za }, paddingY: { style: za }, paddingInline: { style: za }, paddingInlineStart: { style: za }, paddingInlineEnd: { style: za }, paddingBlock: { style: za }, paddingBlockStart: { style: za }, paddingBlockEnd: { style: za }, m: { style: Da }, mt: { style: Da }, mr: { style: Da }, mb: { style: Da }, ml: { style: Da }, mx: { style: Da }, my: { style: Da }, margin: { style: Da }, marginTop: { style: Da }, marginRight: { style: Da }, marginBottom: { style: Da }, marginLeft: { style: Da }, marginX: { style: Da }, marginY: { style: Da }, marginInline: { style: Da }, marginInlineStart: { style: Da }, marginInlineEnd: { style: Da }, marginBlock: { style: Da }, marginBlockStart: { style: Da }, marginBlockEnd: { style: Da }, displayPrint: { cssProperty: !1, transform(e) { return { '@media print': { display: e } }; } }, display: {}, overflow: {}, textOverflow: {}, visibility: {}, whiteSpace: {}, flexBasis: {}, flexDirection: {}, flexWrap: {}, justifyContent: {}, alignItems: {}, alignContent: {}, order: {}, flex: {}, flexGrow: {}, flexShrink: {}, alignSelf: {}, justifyItems: {}, justifySelf: {}, gap: { style: Ja }, rowGap: { style: to }, columnGap: { style: eo }, gridColumn: {}, gridRow: {}, gridAutoFlow: {}, gridAutoColumns: {}, gridAutoRows: {}, gridTemplateColumns: {}, gridTemplateRows: {}, gridTemplateAreas: {}, gridArea: {}, position: {}, zIndex: { themeKey: 'zIndex' }, top: {}, right: {}, bottom: {}, left: {}, boxShadow: { themeKey: 'shadows' }, width: { transform: no }, maxWidth: { style: ao }, minWidth: { transform: no }, height: { transform: no }, maxHeight: { transform: no }, minHeight: { transform: no }, boxSizing: {}, fontFamily: { themeKey: 'typography' }, fontSize: { themeKey: 'typography' }, fontStyle: { themeKey: 'typography' }, fontWeight: { themeKey: 'typography' }, letterSpacing: {}, textTransform: {}, lineHeight: {}, textAlign: {}, typography: { cssProperty: !1, themeKey: 'typography' },
    }); const ho = (function () { function e(e, t, r, n) { let i; const a = (O(i = {}, e, t), O(i, 'theme', r), i); const o = n[e]; if (!o) return O({}, e, t); const s = o.cssProperty; const u = void 0 === s ? e : s; const l = o.themeKey; const c = o.transform; const h = o.style; if (t == null) return null; if (l === 'typography' && t === 'inherit') return O({}, e, t); const f = ba(r, l) || {}; if (h) return h(a); return va(a, t, ((t) => { let r = wa(f, c, t); return t === r && typeof t === 'string' && (r = wa(f, c, ''.concat(e).concat(t === 'default' ? '' : la(t)), t)), !1 === u ? r : O({}, u, r); })); } return function t(r) { let n; const i = r || {}; const a = i.sx; const o = i.theme; const s = void 0 === o ? {} : o; if (!a) return null; const u = (n = s.unstable_sxConfig) != null ? n : co; function l(r) { let n = r; if (typeof r === 'function')n = r(s); else if (typeof r !== 'object') return r; if (!n) return null; const i = ga(s.breakpoints); const a = Object.keys(i); let o = i; return Object.keys(n).forEach(((r) => { let i; let a; const l = (i = n[r], a = s, typeof i === 'function' ? i(a) : i); if (l !== null && void 0 !== l) if (typeof l === 'object') if (u[r])o = da(o, e(r, l, s, u)); else { const c = va({ theme: s }, l, ((e) => O({}, r, e))); !(function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; const n = t.reduce(((e, t) => e.concat(Object.keys(t))), []); const i = new Set(n); return t.every(((e) => i.size === Object.keys(e).length)); }(c, l)) ? o = da(o, c) : o[r] = t({ sx: l, theme: s }); } else o = da(o, e(r, l, s, u)); })), ya(a, o); } return Array.isArray(a) ? a.map(l) : l(a); }; }()); ho.filterProps = ['sx']; const fo = ho; const po = ['sx']; const mo = function (e) { let t; let r; const n = { systemProps: {}, otherProps: {} }; const i = (t = e == null || (r = e.theme) == null ? void 0 : r.unstable_sxConfig) != null ? t : co; return Object.keys(e).forEach(((t) => { i[t] ? n.systemProps[t] = e[t] : n.otherProps[t] = e[t]; })), n; }; function vo(e) { let t; const r = e.sx; const n = m(e, po); const i = mo(n); const a = i.systemProps; const o = i.otherProps; return t = Array.isArray(r) ? [a].concat(P(r)) : typeof r === 'function' ? function () { const e = r.apply(void 0, arguments); return ca(e) ? Tn({}, a, e) : a; } : Tn({}, a, r), Tn({}, o, { sx: t }); } const go = ['values', 'unit', 'step']; const yo = function (e) { const t = Object.keys(e).map(((t) => ({ key: t, val: e[t] }))) || []; return t.sort(((e, t) => e.val - t.val)), t.reduce(((e, t) => Tn({}, e, O({}, t.key, t.val))), {}); }; const bo = { borderRadius: 4 }; const wo = ['breakpoints', 'palette', 'spacing', 'shape']; const ko = function () {
      for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = e.breakpoints, r = void 0 === t ? {} : t, n = e.palette, i = void 0 === n ? {} : n, a = e.spacing, o = e.shape, s = void 0 === o ? {} : o, u = m(e, wo), l = (function (e) {
          const t = e.values; const r = void 0 === t ? {
            xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536,
          } : t; const n = e.unit; const i = void 0 === n ? 'px' : n; const a = e.step; const o = void 0 === a ? 5 : a; const s = m(e, go); const u = yo(r); const l = Object.keys(u); function c(e) { const t = typeof r[e] === 'number' ? r[e] : e; return '@media (min-width:'.concat(t).concat(i, ')'); } function h(e) { const t = typeof r[e] === 'number' ? r[e] : e; return '@media (max-width:'.concat(t - o / 100).concat(i, ')'); } function f(e, t) { const n = l.indexOf(t); return '@media (min-width:'.concat(typeof r[e] === 'number' ? r[e] : e).concat(i, ') and ') + '(max-width:'.concat((n !== -1 && typeof r[l[n]] === 'number' ? r[l[n]] : t) - o / 100).concat(i, ')'); } return Tn({
            keys: l, values: u, up: c, down: h, between: f, only(e) { return l.indexOf(e) + 1 < l.length ? f(e, l[l.indexOf(e) + 1]) : c(e); }, not(e) { const t = l.indexOf(e); return t === 0 ? c(l[1]) : t === l.length - 1 ? h(l[t]) : f(e, l[l.indexOf(e) + 1]).replace('@media', '@media not all and'); }, unit: i,
          }, s);
        }(r)), c = (function () { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8; if (e.mui) return e; const t = Ta({ spacing: e }); const r = function () { for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)r[n] = arguments[n]; return (r.length === 0 ? [1] : r).map(((e) => { const r = t(e); return typeof r === 'number' ? ''.concat(r, 'px') : r; })).join(' '); }; return r.mui = !0, r; }(a)), h = fa({
          breakpoints: l, direction: 'ltr', components: {}, palette: Tn({ mode: 'light' }, i), spacing: c, shape: Tn({}, bo, s),
        }, u), f = arguments.length, d = new Array(f > 1 ? f - 1 : 0), p = 1; p < f; p++)d[p - 1] = arguments[p]; return (h = d.reduce(((e, t) => fa(e, t)), h)).unstable_sxConfig = Tn({}, co, u == null ? void 0 : u.unstable_sxConfig), h.unstable_sx = function (e) { return fo({ sx: e, theme: this }); }, h;
    }; const xo = function () { let e; const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; const r = i.useContext(Ji); return r && (e = r, Object.keys(e).length !== 0) ? r : t; }; const _o = ko(); const So = function () { return xo(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _o); }; const Mo = __webpack_require__(184); const Eo = ['className', 'component']; const Co = function (e) { return e; }; const Po = (function () { let e = Co; return { configure(t) { e = t; }, generate(t) { return e(t); }, reset() { e = Co; } }; }()); function Ao(e, t) { let r; return Tn({ toolbar: (r = { minHeight: 56 }, O(r, e.up('xs'), { '@media (orientation: landscape)': { minHeight: 48 } }), O(r, e.up('sm'), { minHeight: 64 }), r) }, t); } function To(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1; return Math.min(Math.max(t, e), r); } function Ro(e) { if (e.type) return e; if (e.charAt(0) === '#') return Ro(function (e) { e = e.slice(1); const t = new RegExp('.{1,'.concat(e.length >= 6 ? 2 : 1, '}'), 'g'); let r = e.match(t); return r && r[0].length === 1 && (r = r.map(((e) => e + e))), r ? 'rgb'.concat(r.length === 4 ? 'a' : '', '(').concat(r.map(((e, t) => (t < 3 ? parseInt(e, 16) : Math.round(parseInt(e, 16) / 255 * 1e3) / 1e3))).join(', '), ')') : ''; }(e)); const t = e.indexOf('('); const r = e.substring(0, t); if (['rgb', 'rgba', 'hsl', 'hsla', 'color'].indexOf(r) === -1) throw new Error(ua(9, e)); let n; let i = e.substring(t + 1, e.length - 1); if (r === 'color') { if (n = (i = i.split(' ')).shift(), i.length === 4 && i[3].charAt(0) === '/' && (i[3] = i[3].slice(1)), ['srgb', 'display-p3', 'a98-rgb', 'prophoto-rgb', 'rec-2020'].indexOf(n) === -1) throw new Error(ua(10, n)); } else i = i.split(','); return { type: r, values: i = i.map(((e) => parseFloat(e))), colorSpace: n }; } function Io(e) { const t = e.type; const r = e.colorSpace; let n = e.values; return t.indexOf('rgb') !== -1 ? n = n.map(((e, t) => (t < 3 ? parseInt(e, 10) : e))) : t.indexOf('hsl') !== -1 && (n[1] = ''.concat(n[1], '%'), n[2] = ''.concat(n[2], '%')), n = t.indexOf('color') !== -1 ? ''.concat(r, ' ').concat(n.join(' ')) : ''.concat(n.join(', ')), ''.concat(t, '(').concat(n, ')'); } function Oo(e) { let t = (e = Ro(e)).type === 'hsl' || e.type === 'hsla' ? Ro(function (e) { const t = (e = Ro(e)).values; const r = t[0]; const n = t[1] / 100; const i = t[2] / 100; const a = n * Math.min(i, 1 - i); const o = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : (e + r / 30) % 12; return i - a * Math.max(Math.min(t - 3, 9 - t, 1), -1); }; let s = 'rgb'; const u = [Math.round(255 * o(0)), Math.round(255 * o(8)), Math.round(255 * o(4))]; return e.type === 'hsla' && (s += 'a', u.push(t[3])), Io({ type: s, values: u }); }(e)).values : e.values; return t = t.map(((t) => (e.type !== 'color' && (t /= 255), t <= 0.03928 ? t / 12.92 : ((t + 0.055) / 1.055) ** 2.4))), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3)); } function Do(e, t) { return e = Ro(e), t = To(t), e.type !== 'rgb' && e.type !== 'hsl' || (e.type += 'a'), e.type === 'color' ? e.values[3] = '/'.concat(t) : e.values[3] = t, Io(e); } function zo(e, t) { if (e = Ro(e), t = To(t), e.type.indexOf('hsl') !== -1)e.values[2] *= 1 - t; else if (e.type.indexOf('rgb') !== -1 || e.type.indexOf('color') !== -1) for (let r = 0; r < 3; r += 1)e.values[r] *= 1 - t; return Io(e); } function No(e, t) { if (e = Ro(e), t = To(t), e.type.indexOf('hsl') !== -1)e.values[2] += (100 - e.values[2]) * t; else if (e.type.indexOf('rgb') !== -1) for (let r = 0; r < 3; r += 1)e.values[r] += (255 - e.values[r]) * t; else if (e.type.indexOf('color') !== -1) for (let n = 0; n < 3; n += 1)e.values[n] += (1 - e.values[n]) * t; return Io(e); } const Lo = { black: '#000', white: '#fff' }; const jo = {
      50: '#fafafa', 100: '#f5f5f5', 200: '#eeeeee', 300: '#e0e0e0', 400: '#bdbdbd', 500: '#9e9e9e', 600: '#757575', 700: '#616161', 800: '#424242', 900: '#212121', A100: '#f5f5f5', A200: '#eeeeee', A400: '#bdbdbd', A700: '#616161',
    }; const Fo = {
      50: '#f3e5f5', 100: '#e1bee7', 200: '#ce93d8', 300: '#ba68c8', 400: '#ab47bc', 500: '#9c27b0', 600: '#8e24aa', 700: '#7b1fa2', 800: '#6a1b9a', 900: '#4a148c', A100: '#ea80fc', A200: '#e040fb', A400: '#d500f9', A700: '#aa00ff',
    }; const Bo = {
      50: '#ffebee', 100: '#ffcdd2', 200: '#ef9a9a', 300: '#e57373', 400: '#ef5350', 500: '#f44336', 600: '#e53935', 700: '#d32f2f', 800: '#c62828', 900: '#b71c1c', A100: '#ff8a80', A200: '#ff5252', A400: '#ff1744', A700: '#d50000',
    }; const Uo = {
      50: '#fff3e0', 100: '#ffe0b2', 200: '#ffcc80', 300: '#ffb74d', 400: '#ffa726', 500: '#ff9800', 600: '#fb8c00', 700: '#f57c00', 800: '#ef6c00', 900: '#e65100', A100: '#ffd180', A200: '#ffab40', A400: '#ff9100', A700: '#ff6d00',
    }; const Vo = {
      50: '#e3f2fd', 100: '#bbdefb', 200: '#90caf9', 300: '#64b5f6', 400: '#42a5f5', 500: '#2196f3', 600: '#1e88e5', 700: '#1976d2', 800: '#1565c0', 900: '#0d47a1', A100: '#82b1ff', A200: '#448aff', A400: '#2979ff', A700: '#2962ff',
    }; const Yo = {
      50: '#e1f5fe', 100: '#b3e5fc', 200: '#81d4fa', 300: '#4fc3f7', 400: '#29b6f6', 500: '#03a9f4', 600: '#039be5', 700: '#0288d1', 800: '#0277bd', 900: '#01579b', A100: '#80d8ff', A200: '#40c4ff', A400: '#00b0ff', A700: '#0091ea',
    }; const Ho = {
      50: '#e8f5e9', 100: '#c8e6c9', 200: '#a5d6a7', 300: '#81c784', 400: '#66bb6a', 500: '#4caf50', 600: '#43a047', 700: '#388e3c', 800: '#2e7d32', 900: '#1b5e20', A100: '#b9f6ca', A200: '#69f0ae', A400: '#00e676', A700: '#00c853',
    }; const qo = ['mode', 'contrastThreshold', 'tonalOffset']; const Wo = {
      text: { primary: 'rgba(0, 0, 0, 0.87)', secondary: 'rgba(0, 0, 0, 0.6)', disabled: 'rgba(0, 0, 0, 0.38)' },
      divider: 'rgba(0, 0, 0, 0.12)',
      background: { paper: Lo.white, default: Lo.white },
      action: {
        active: 'rgba(0, 0, 0, 0.54)', hover: 'rgba(0, 0, 0, 0.04)', hoverOpacity: 0.04, selected: 'rgba(0, 0, 0, 0.08)', selectedOpacity: 0.08, disabled: 'rgba(0, 0, 0, 0.26)', disabledBackground: 'rgba(0, 0, 0, 0.12)', disabledOpacity: 0.38, focus: 'rgba(0, 0, 0, 0.12)', focusOpacity: 0.12, activatedOpacity: 0.12,
      },
    }; const Xo = {
      text: {
        primary: Lo.white, secondary: 'rgba(255, 255, 255, 0.7)', disabled: 'rgba(255, 255, 255, 0.5)', icon: 'rgba(255, 255, 255, 0.5)',
      },
      divider: 'rgba(255, 255, 255, 0.12)',
      background: { paper: '#121212', default: '#121212' },
      action: {
        active: Lo.white, hover: 'rgba(255, 255, 255, 0.08)', hoverOpacity: 0.08, selected: 'rgba(255, 255, 255, 0.16)', selectedOpacity: 0.16, disabled: 'rgba(255, 255, 255, 0.3)', disabledBackground: 'rgba(255, 255, 255, 0.12)', disabledOpacity: 0.38, focus: 'rgba(255, 255, 255, 0.12)', focusOpacity: 0.12, activatedOpacity: 0.24,
      },
    }; function Go(e, t, r, n) { const i = n.light || n; const a = n.dark || 1.5 * n; e[t] || (e.hasOwnProperty(r) ? e[t] = e[r] : t === 'light' ? e.light = No(e.main, i) : t === 'dark' && (e.dark = zo(e.main, a))); } function $o(e) {
      const t = e.mode; const r = void 0 === t ? 'light' : t; const n = e.contrastThreshold; const i = void 0 === n ? 3 : n; const a = e.tonalOffset; const o = void 0 === a ? 0.2 : a; const s = m(e, qo); const u = e.primary || (function () { return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'light') === 'dark' ? { main: Vo[200], light: Vo[50], dark: Vo[400] } : { main: Vo[700], light: Vo[400], dark: Vo[800] }; }(r)); const l = e.secondary || (function () { return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'light') === 'dark' ? { main: Fo[200], light: Fo[50], dark: Fo[400] } : { main: Fo[500], light: Fo[300], dark: Fo[700] }; }(r)); const c = e.error || (function () { return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'light') === 'dark' ? { main: Bo[500], light: Bo[300], dark: Bo[700] } : { main: Bo[700], light: Bo[400], dark: Bo[800] }; }(r)); const h = e.info || (function () { return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'light') === 'dark' ? { main: Yo[400], light: Yo[300], dark: Yo[700] } : { main: Yo[700], light: Yo[500], dark: Yo[900] }; }(r)); const f = e.success || (function () { return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'light') === 'dark' ? { main: Ho[400], light: Ho[300], dark: Ho[700] } : { main: Ho[800], light: Ho[500], dark: Ho[900] }; }(r)); const d = e.warning || (function () { return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'light') === 'dark' ? { main: Uo[400], light: Uo[300], dark: Uo[700] } : { main: '#ed6c02', light: Uo[500], dark: Uo[900] }; }(r)); function p(e) { const t = (function (e, t) { const r = Oo(e); const n = Oo(t); return (Math.max(r, n) + 0.05) / (Math.min(r, n) + 0.05); }(e, Xo.text.primary)) >= i ? Xo.text.primary : Wo.text.primary; return t; } const v = function (e) { let t = e.color; const r = e.name; const n = e.mainShade; const i = void 0 === n ? 500 : n; const a = e.lightShade; const s = void 0 === a ? 300 : a; const u = e.darkShade; const l = void 0 === u ? 700 : u; if (!(t = Tn({}, t)).main && t[i] && (t.main = t[i]), !t.hasOwnProperty('main')) throw new Error(ua(11, r ? ' ('.concat(r, ')') : '', i)); if (typeof t.main !== 'string') throw new Error(ua(12, r ? ' ('.concat(r, ')') : '', JSON.stringify(t.main))); return Go(t, 'light', s, o), Go(t, 'dark', l, o), t.contrastText || (t.contrastText = p(t.main)), t; }; const g = { dark: Xo, light: Wo }; return fa(Tn({
        common: Tn({}, Lo),
        mode: r,
        primary: v({ color: u, name: 'primary' }),
        secondary: v({
          color: l, name: 'secondary', mainShade: 'A400', lightShade: 'A200', darkShade: 'A700',
        }),
        error: v({ color: c, name: 'error' }),
        warning: v({ color: d, name: 'warning' }),
        info: v({ color: h, name: 'info' }),
        success: v({ color: f, name: 'success' }),
        grey: jo,
        contrastThreshold: i,
        getContrastText: p,
        augmentColor: v,
        tonalOffset: o,
      }, g[r]), s);
    } const Zo = ['fontFamily', 'fontSize', 'fontWeightLight', 'fontWeightRegular', 'fontWeightMedium', 'fontWeightBold', 'htmlFontSize', 'allVariants', 'pxToRem']; const Ko = { textTransform: 'uppercase' }; const Qo = '"Roboto", "Helvetica", "Arial", sans-serif'; function Jo(e, t) {
      const r = typeof t === 'function' ? t(e) : t; const n = r.fontFamily; const i = void 0 === n ? Qo : n; const a = r.fontSize; const o = void 0 === a ? 14 : a; const s = r.fontWeightLight; const u = void 0 === s ? 300 : s; const l = r.fontWeightRegular; const c = void 0 === l ? 400 : l; const h = r.fontWeightMedium; const f = void 0 === h ? 500 : h; const d = r.fontWeightBold; const p = void 0 === d ? 700 : d; const v = r.htmlFontSize; const g = void 0 === v ? 16 : v; const y = r.allVariants; const b = r.pxToRem; const w = m(r, Zo); const k = o / 14; const x = b || function (e) { return ''.concat(e / g * k, 'rem'); }; const _ = function (e, t, r, n, a) {
        return Tn({
          fontFamily: i, fontWeight: e, fontSize: x(t), lineHeight: r,
        }, i === Qo ? { letterSpacing: ''.concat((o = n / t, Math.round(1e5 * o) / 1e5), 'em') } : {}, a, y); let o;
      }; const S = {
        h1: _(u, 96, 1.167, -1.5),
        h2: _(u, 60, 1.2, -0.5),
        h3: _(c, 48, 1.167, 0),
        h4: _(c, 34, 1.235, 0.25),
        h5: _(c, 24, 1.334, 0),
        h6: _(f, 20, 1.6, 0.15),
        subtitle1: _(c, 16, 1.75, 0.15),
        subtitle2: _(f, 14, 1.57, 0.1),
        body1: _(c, 16, 1.5, 0.15),
        body2: _(c, 14, 1.43, 0.15),
        button: _(f, 14, 1.75, 0.4, Ko),
        caption: _(c, 12, 1.66, 0.4),
        overline: _(c, 12, 2.66, 1, Ko),
        inherit: {
          fontFamily: 'inherit', fontWeight: 'inherit', fontSize: 'inherit', lineHeight: 'inherit', letterSpacing: 'inherit',
        },
      }; return fa(Tn({
        htmlFontSize: g, pxToRem: x, fontFamily: i, fontSize: o, fontWeightLight: u, fontWeightRegular: c, fontWeightMedium: f, fontWeightBold: p,
      }, S), w, { clone: !1 });
    } function es() {
      return [''.concat(arguments.length <= 0 ? void 0 : arguments[0], 'px ').concat(arguments.length <= 1 ? void 0 : arguments[1], 'px ').concat(arguments.length <= 2 ? void 0 : arguments[2], 'px ').concat(arguments.length <= 3 ? void 0 : arguments[3], 'px rgba(0,0,0,')
        .concat(0.2, ')'), ''.concat(arguments.length <= 4 ? void 0 : arguments[4], 'px ').concat(arguments.length <= 5 ? void 0 : arguments[5], 'px ').concat(arguments.length <= 6 ? void 0 : arguments[6], 'px ').concat(arguments.length <= 7 ? void 0 : arguments[7], 'px rgba(0,0,0,')
        .concat(0.14, ')'), ''.concat(arguments.length <= 8 ? void 0 : arguments[8], 'px ').concat(arguments.length <= 9 ? void 0 : arguments[9], 'px ').concat(arguments.length <= 10 ? void 0 : arguments[10], 'px ').concat(arguments.length <= 11 ? void 0 : arguments[11], 'px rgba(0,0,0,')
        .concat(0.12, ')')].join(',');
    } const ts = ['none', es(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), es(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), es(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), es(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), es(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), es(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), es(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), es(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), es(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), es(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), es(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), es(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), es(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), es(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), es(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), es(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), es(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), es(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), es(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), es(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), es(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), es(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), es(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), es(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)]; const rs = ['duration', 'easing', 'delay']; const ns = {
      easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)', easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)', easeIn: 'cubic-bezier(0.4, 0, 1, 1)', sharp: 'cubic-bezier(0.4, 0, 0.6, 1)',
    }; const is = {
      shortest: 150, shorter: 200, short: 250, standard: 300, complex: 375, enteringScreen: 225, leavingScreen: 195,
    }; function as(e) { return ''.concat(Math.round(e), 'ms'); } function os(e) { if (!e) return 0; const t = e / 36; return Math.round(10 * (4 + 15 * t ** 0.25 + t / 5)); } function ss(e) { const t = Tn({}, ns, e.easing); const r = Tn({}, is, e.duration); return Tn({ getAutoHeightDuration: os, create() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ['all']; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const i = n.duration; const a = void 0 === i ? r.standard : i; const o = n.easing; const s = void 0 === o ? t.easeInOut : o; const u = n.delay; const l = void 0 === u ? 0 : u; m(n, rs); return (Array.isArray(e) ? e : [e]).map(((e) => ''.concat(e, ' ').concat(typeof a === 'string' ? a : as(a), ' ').concat(s, ' ').concat(typeof l === 'string' ? l : as(l)))).join(','); } }, e, { easing: t, duration: r }); } const us = {
      mobileStepper: 1e3, fab: 1050, speedDial: 1050, appBar: 1100, drawer: 1200, modal: 1300, snackbar: 1400, tooltip: 1500,
    }; const ls = ['breakpoints', 'mixins', 'spacing', 'palette', 'transitions', 'typography', 'shape']; function cs() {
      const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.mixins; const r = void 0 === t ? {} : t; const n = e.palette; const i = void 0 === n ? {} : n; const a = e.transitions; const o = void 0 === a ? {} : a; const s = e.typography; const u = void 0 === s ? {} : s; const l = m(e, ls); if (e.vars) throw new Error(ua(18)); const c = $o(i); const h = ko(e); let f = fa(h, {
        mixins: Ao(h.breakpoints, r), palette: c, shadows: ts.slice(), typography: Jo(c, u), transitions: ss(o), zIndex: Tn({}, us),
      }); f = fa(f, l); for (var d = arguments.length, p = new Array(d > 1 ? d - 1 : 0), v = 1; v < d; v++)p[v - 1] = arguments[v]; return (f = p.reduce(((e, t) => fa(e, t)), f)).unstable_sxConfig = Tn({}, co, l == null ? void 0 : l.unstable_sxConfig), f.unstable_sx = function (e) { return fo({ sx: e, theme: this }); }, f;
    } const hs = cs; const fs = '$$material'; const ds = hs(); const ps = (function () {
      const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.themeId; const r = e.defaultTheme; const n = e.defaultClassName; const a = void 0 === n ? 'MuiBox-root' : n; const o = e.generateClassName; const s = sa('div', { shouldForwardProp(e) { return e !== 'theme' && e !== 'sx' && e !== 'as'; } })(fo); const u = i.forwardRef(((e, n) => {
        const i = So(r); const u = vo(e); const l = u.className; const c = u.component; const h = void 0 === c ? 'div' : c; const f = m(u, Eo); return (0, Mo.jsx)(s, Tn({
          as: h, ref: n, className: In(l, o ? o(a) : a), theme: t && i[t] || i,
        }, f));
      })); return u;
    }({
      themeId: fs, defaultTheme: ds, defaultClassName: 'MuiBox-root', generateClassName: Po.generate,
    })); const ms = ps; let vs = function () { return vs = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) for (const i in t = arguments[r])Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e; }, vs.apply(this, arguments); }; Object.create; function gs(e, t, r) { if (r || arguments.length === 2) for (var n, i = 0, a = t.length; i < a; i++)!n && i in t || (n || (n = Array.prototype.slice.call(t, 0, i)), n[i] = t[i]); return e.concat(n || Array.prototype.slice.call(t)); }Object.create; typeof SuppressedError === 'function' && SuppressedError; const ys = __webpack_require__(9613); const bs = __webpack_require__.n(ys); const ws = '-ms-'; const ks = '-moz-'; const xs = '-webkit-'; const _s = 'comm'; const Ss = 'rule'; const Ms = 'decl'; const Es = '@import'; const Cs = '@keyframes'; const Ps = '@layer'; const As = Math.abs; const Ts = String.fromCharCode; const Rs = Object.assign; function Is(e) { return e.trim(); } function Os(e, t) { return (e = t.exec(e)) ? e[0] : e; } function Ds(e, t, r) { return e.replace(t, r); } function zs(e, t) { return e.indexOf(t); } function Ns(e, t) { return 0 | e.charCodeAt(t); } function Ls(e, t, r) { return e.slice(t, r); } function js(e) { return e.length; } function Fs(e) { return e.length; } function Bs(e, t) { return t.push(e), e; } function Us(e, t) { return e.filter(((e) => !Os(e, t))); } let Vs = 1; let Ys = 1; let Hs = 0; let qs = 0; let Ws = 0; let Xs = ''; function Gs(e, t, r, n, i, a, o, s) {
      return {
        value: e, root: t, parent: r, type: n, props: i, children: a, line: Vs, column: Ys, length: o, return: '', siblings: s,
      };
    } function $s(e, t) { return Rs(Gs('', null, null, '', null, null, 0, e.siblings), e, { length: -e.length }, t); } function Zs(e) { for (;e.root;)e = $s(e.root, { children: [e] }); Bs(e, e.siblings); } function Ks() { return Ws = qs < Hs ? Ns(Xs, qs++) : 0, Ys++, Ws === 10 && (Ys = 1, Vs++), Ws; } function Qs() { return Ns(Xs, qs); } function Js() { return qs; } function eu(e, t) { return Ls(Xs, e, t); } function tu(e) { switch (e) { case 0: case 9: case 10: case 13: case 32: return 5; case 33: case 43: case 44: case 47: case 62: case 64: case 126: case 59: case 123: case 125: return 4; case 58: return 3; case 34: case 39: case 40: case 91: return 2; case 41: case 93: return 1; } return 0; } function ru(e) { return Vs = Ys = 1, Hs = js(Xs = e), qs = 0, []; } function nu(e) { return Xs = '', e; } function iu(e) { return Is(eu(qs - 1, su(e === 91 ? e + 2 : e === 40 ? e + 1 : e))); } function au(e) { for (;(Ws = Qs()) && Ws < 33;)Ks(); return tu(e) > 2 || tu(Ws) > 3 ? '' : ' '; } function ou(e, t) { for (;--t && Ks() && !(Ws < 48 || Ws > 102 || Ws > 57 && Ws < 65 || Ws > 70 && Ws < 97););return eu(e, Js() + (t < 6 && Qs() == 32 && Ks() == 32)); } function su(e) { for (;Ks();) switch (Ws) { case e: return qs; case 34: case 39: e !== 34 && e !== 39 && su(Ws); break; case 40: e === 41 && su(e); break; case 92: Ks(); } return qs; } function uu(e, t) { for (;Ks() && e + Ws !== 57 && (e + Ws !== 84 || Qs() !== 47););return `/*${eu(t, qs - 1)}*${Ts(e === 47 ? e : Ks())}`; } function lu(e) { for (;!tu(Qs());)Ks(); return eu(e, qs); } function cu(e, t) { for (var r = '', n = 0; n < e.length; n++)r += t(e[n], n, e, t) || ''; return r; } function hu(e, t, r, n) { switch (e.type) { case Ps: if (e.children.length) break; case Es: case Ms: return e.return = e.return || e.value; case _s: return ''; case Cs: return e.return = `${e.value}{${cu(e.children, n)}}`; case Ss: if (!js(e.value = e.props.join(','))) return ''; } return js(r = cu(e.children, n)) ? e.return = `${e.value}{${r}}` : ''; } function fu(e, t, r) { switch (function (e, t) { return 45 ^ Ns(e, 0) ? (((t << 2 ^ Ns(e, 0)) << 2 ^ Ns(e, 1)) << 2 ^ Ns(e, 2)) << 2 ^ Ns(e, 3) : 0; }(e, t)) { case 5103: return `${xs}print-${e}${e}`; case 5737: case 4201: case 3177: case 3433: case 1641: case 4457: case 2921: case 5572: case 6356: case 5844: case 3191: case 6645: case 3005: case 6391: case 5879: case 5623: case 6135: case 4599: case 4855: case 4215: case 6389: case 5109: case 5365: case 5621: case 3829: return xs + e + e; case 4789: return ks + e + e; case 5349: case 4246: case 4810: case 6968: case 2756: return xs + e + ks + e + ws + e + e; case 5936: switch (Ns(e, t + 11)) { case 114: return xs + e + ws + Ds(e, /[svh]\w+-[tblr]{2}/, 'tb') + e; case 108: return xs + e + ws + Ds(e, /[svh]\w+-[tblr]{2}/, 'tb-rl') + e; case 45: return xs + e + ws + Ds(e, /[svh]\w+-[tblr]{2}/, 'lr') + e; } case 6828: case 4268: case 2903: return xs + e + ws + e + e; case 6165: return `${xs + e + ws}flex-${e}${e}`; case 5187: return xs + e + Ds(e, /(\w+).+(:[^]+)/, `${xs}box-$1$2${ws}flex-$1$2`) + e; case 5443: return `${xs + e + ws}flex-item-${Ds(e, /flex-|-self/g, '')}${Os(e, /flex-|baseline/) ? '' : `${ws}grid-row-${Ds(e, /flex-|-self/g, '')}`}${e}`; case 4675: return `${xs + e + ws}flex-line-pack${Ds(e, /align-content|flex-|-self/g, '')}${e}`; case 5548: return xs + e + ws + Ds(e, 'shrink', 'negative') + e; case 5292: return xs + e + ws + Ds(e, 'basis', 'preferred-size') + e; case 6060: return `${xs}box-${Ds(e, '-grow', '')}${xs}${e}${ws}${Ds(e, 'grow', 'positive')}${e}`; case 4554: return xs + Ds(e, /([^-])(transform)/g, `$1${xs}$2`) + e; case 6187: return Ds(Ds(Ds(e, /(zoom-|grab)/, `${xs}$1`), /(image-set)/, `${xs}$1`), e, '') + e; case 5495: case 3959: return Ds(e, /(image-set\([^]*)/, `${xs}$1$\`$1`); case 4968: return Ds(Ds(e, /(.+:)(flex-)?(.*)/, `${xs}box-pack:$3${ws}flex-pack:$3`), /s.+-b[^;]+/, 'justify') + xs + e + e; case 4200: if (!Os(e, /flex-|baseline/)) return `${ws}grid-column-align${Ls(e, t)}${e}`; break; case 2592: case 3360: return ws + Ds(e, 'template-', '') + e; case 4384: case 3616: return r && r.some(((e, r) => (t = r, Os(e.props, /grid-\w+-end/)))) ? ~zs(e + (r = r[t].value), 'span') ? e : `${ws + Ds(e, '-start', '') + e + ws}grid-row-span:${~zs(r, 'span') ? Os(r, /\d+/) : +Os(r, /\d+/) - +Os(e, /\d+/)};` : ws + Ds(e, '-start', '') + e; case 4896: case 4128: return r && r.some(((e) => Os(e.props, /grid-\w+-start/))) ? e : ws + Ds(Ds(e, '-end', '-span'), 'span ', '') + e; case 4095: case 3583: case 4068: case 2532: return Ds(e, /(.+)-inline(.+)/, `${xs}$1$2`) + e; case 8116: case 7059: case 5753: case 5535: case 5445: case 5701: case 4933: case 4677: case 5533: case 5789: case 5021: case 4765: if (js(e) - 1 - t > 6) switch (Ns(e, t + 1)) { case 109: if (Ns(e, t + 4) !== 45) break; case 102: return Ds(e, /(.+:)(.+)-([^]+)/, `$1${xs}$2-$3$1${ks}${Ns(e, t + 3) == 108 ? '$3' : '$2-$3'}`) + e; case 115: return ~zs(e, 'stretch') ? fu(Ds(e, 'stretch', 'fill-available'), t, r) + e : e; } break; case 5152: case 5920: return Ds(e, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, ((t, r, n, i, a, o, s) => `${ws + r}:${n}${s}${i ? `${ws + r}-span:${a ? o : +o - +n}${s}` : ''}${e}`)); case 4949: if (Ns(e, t + 6) === 121) return Ds(e, ':', `:${xs}`) + e; break; case 6444: switch (Ns(e, Ns(e, 14) === 45 ? 18 : 11)) { case 120: return Ds(e, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, `$1${xs}${Ns(e, 14) === 45 ? 'inline-' : ''}box$3$1${xs}$2$3$1${ws}$2box$3`) + e; case 100: return Ds(e, ':', `:${ws}`) + e; } break; case 5719: case 2647: case 2135: case 3927: case 2391: return Ds(e, 'scroll-', 'scroll-snap-') + e; } return e; } function du(e, t, r, n) { if (e.length > -1 && !e.return) switch (e.type) { case Ms: return void (e.return = fu(e.value, e.length, r)); case Cs: return cu([$s(e, { value: Ds(e.value, '@', `@${xs}`) })], n); case Ss: if (e.length) return (function (e, t) { return e.map(t).join(''); }(r = e.props, ((t) => { switch (Os(t, n = /(::plac\w+|:read-\w+)/)) { case ':read-only': case ':read-write': Zs($s(e, { props: [Ds(t, /:(read-\w+)/, `:${ks}$1`)] })), Zs($s(e, { props: [t] })), Rs(e, { props: Us(r, n) }); break; case '::placeholder': Zs($s(e, { props: [Ds(t, /:(plac\w+)/, `:${xs}input-$1`)] })), Zs($s(e, { props: [Ds(t, /:(plac\w+)/, `:${ks}$1`)] })), Zs($s(e, { props: [Ds(t, /:(plac\w+)/, `${ws}input-$1`)] })), Zs($s(e, { props: [t] })), Rs(e, { props: Us(r, n) }); } return ''; }))); } } function pu(e) { return nu(mu('', null, null, null, [''], e = ru(e), 0, [0], e)); } function mu(e, t, r, n, i, a, o, s, u) { for (let l = 0, c = 0, h = o, f = 0, d = 0, p = 0, m = 1, v = 1, g = 1, y = 0, b = '', w = i, k = a, x = n, _ = b; v;) switch (p = y, y = Ks()) { case 40: if (p != 108 && Ns(_, h - 1) == 58) { zs(_ += Ds(iu(y), '&', '&\f'), '&\f') != -1 && (g = -1); break; } case 34: case 39: case 91: _ += iu(y); break; case 9: case 10: case 13: case 32: _ += au(p); break; case 92: _ += ou(Js() - 1, 7); continue; case 47: switch (Qs()) { case 42: case 47: Bs(gu(uu(Ks(), Js()), t, r, u), u); break; default: _ += '/'; } break; case 123 * m: s[l++] = js(_) * g; case 125 * m: case 59: case 0: switch (y) { case 0: case 125: v = 0; case 59 + c: g == -1 && (_ = Ds(_, /\f/g, '')), d > 0 && js(_) - h && Bs(d > 32 ? yu(`${_};`, n, r, h - 1, u) : yu(`${Ds(_, ' ', '')};`, n, r, h - 2, u), u); break; case 59: _ += ';'; default: if (Bs(x = vu(_, t, r, l, c, i, s, b, w = [], k = [], h, a), a), y === 123) if (c === 0)mu(_, t, x, x, w, a, h, s, k); else switch (f === 99 && Ns(_, 3) === 110 ? 100 : f) { case 100: case 108: case 109: case 115: mu(e, x, x, n && Bs(vu(e, x, x, 0, 0, i, s, b, i, w = [], h, k), k), i, k, h, s, n ? w : k); break; default: mu(_, x, x, x, [''], k, 0, s, k); } }l = c = d = 0, m = g = 1, b = _ = '', h = o; break; case 58: h = 1 + js(_), d = p; default: if (m < 1) if (y == 123)--m; else if (y == 125 && m++ == 0 && (Ws = qs > 0 ? Ns(Xs, --qs) : 0, Ys--, Ws === 10 && (Ys = 1, Vs--), Ws) == 125) continue; switch (_ += Ts(y), y * m) { case 38: g = c > 0 ? 1 : (_ += '\f', -1); break; case 44: s[l++] = (js(_) - 1) * g, g = 1; break; case 64: Qs() === 45 && (_ += iu(Ks())), f = Qs(), c = h = js(b = _ += lu(Js())), y++; break; case 45: p === 45 && js(_) == 2 && (m = 0); } } return a; } function vu(e, t, r, n, i, a, o, s, u, l, c, h) { for (let f = i - 1, d = i === 0 ? a : [''], p = Fs(d), m = 0, v = 0, g = 0; m < n; ++m) for (let y = 0, b = Ls(e, f + 1, f = As(v = o[m])), w = e; y < p; ++y)(w = Is(v > 0 ? `${d[y]} ${b}` : Ds(b, /&\f/g, d[y]))) && (u[g++] = w); return Gs(e, t, r, i === 0 ? Ss : s, u, l, c, h); } function gu(e, t, r, n) { return Gs(e, t, r, _s, Ts(Ws), Ls(e, 2, -2), 0, n); } function yu(e, t, r, n, i) { return Gs(e, t, r, Ms, Ls(e, 0, n), Ls(e, n + 1, -1), n, i); } const bu = typeof process !== 'undefined' && void 0 !== {
      NODE_ENV: 'production', PUBLIC_URL: '', WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0,
    } && ({
      NODE_ENV: 'production', PUBLIC_URL: '', WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0,
    }.REACT_APP_SC_ATTR || {
      NODE_ENV: 'production', PUBLIC_URL: '', WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0,
    }.SC_ATTR) || 'data-styled'; const wu = typeof window !== 'undefined' && 'HTMLElement' in window; const ku = Boolean(typeof SC_DISABLE_SPEEDY === 'boolean' ? SC_DISABLE_SPEEDY : typeof process !== 'undefined' && void 0 !== {
      NODE_ENV: 'production', PUBLIC_URL: '', WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0,
    } && void 0 !== {
      NODE_ENV: 'production', PUBLIC_URL: '', WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0,
    }.REACT_APP_SC_DISABLE_SPEEDY && {
      NODE_ENV: 'production', PUBLIC_URL: '', WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0,
    }.REACT_APP_SC_DISABLE_SPEEDY !== '' ? {
        NODE_ENV: 'production', PUBLIC_URL: '', WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0,
      }.REACT_APP_SC_DISABLE_SPEEDY !== 'false' && {
        NODE_ENV: 'production', PUBLIC_URL: '', WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0,
      }.REACT_APP_SC_DISABLE_SPEEDY : typeof process !== 'undefined' && void 0 !== {
        NODE_ENV: 'production', PUBLIC_URL: '', WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0,
      } && void 0 !== {
        NODE_ENV: 'production', PUBLIC_URL: '', WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0,
      }.SC_DISABLE_SPEEDY && {
        NODE_ENV: 'production', PUBLIC_URL: '', WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0,
      }.SC_DISABLE_SPEEDY !== '' && ({
        NODE_ENV: 'production', PUBLIC_URL: '', WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0,
      }.SC_DISABLE_SPEEDY !== 'false' && {
        NODE_ENV: 'production', PUBLIC_URL: '', WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0,
      }.SC_DISABLE_SPEEDY)); const xu = (new Set(), Object.freeze([])); const _u = Object.freeze({}); function Su(e, t, r) { return void 0 === r && (r = _u), e.theme !== r.theme && e.theme || t || r.theme; } const Mu = new Set(['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'u', 'ul', 'use', 'var', 'video', 'wbr', 'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'marker', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan']); const Eu = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g; const Cu = /(^-|-$)/g; function Pu(e) { return e.replace(Eu, '-').replace(Cu, ''); } const Au = /(a)(d)/gi; const Tu = function (e) { return String.fromCharCode(e + (e > 25 ? 39 : 97)); }; function Ru(e) { let t; let r = ''; for (t = Math.abs(e); t > 52; t = t / 52 | 0)r = Tu(t % 52) + r; return (Tu(t % 52) + r).replace(Au, '$1-$2'); } let Iu; const Ou = function (e, t) { for (let r = t.length; r;)e = 33 * e ^ t.charCodeAt(--r); return e; }; const Du = function (e) { return Ou(5381, e); }; function zu(e) { return Ru(Du(e) >>> 0); } function Nu(e) { return typeof e === 'string' && !0; } const Lu = typeof Symbol === 'function' && Symbol.for; const ju = Lu ? Symbol.for('react.memo') : 60115; const Fu = Lu ? Symbol.for('react.forward_ref') : 60112; const Bu = {
      childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0,
    }; const Uu = {
      name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0,
    }; const Vu = {
      $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0,
    }; const Yu = ((Iu = {})[Fu] = {
      $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0,
    }, Iu[ju] = Vu, Iu); function Hu(e) { return ('type' in (t = e) && t.type.$$typeof) === ju ? Vu : '$$typeof' in e ? Yu[e.$$typeof] : Bu; let t; } const qu = Object.defineProperty; const Wu = Object.getOwnPropertyNames; const Xu = Object.getOwnPropertySymbols; const Gu = Object.getOwnPropertyDescriptor; const $u = Object.getPrototypeOf; const Zu = Object.prototype; function Ku(e, t, r) { if (typeof t !== 'string') { if (Zu) { const n = $u(t); n && n !== Zu && Ku(e, n, r); } let i = Wu(t); Xu && (i = i.concat(Xu(t))); for (let a = Hu(e), o = Hu(t), s = 0; s < i.length; ++s) { const u = i[s]; if (!(u in Uu || r && r[u] || o && u in o || a && u in a)) { const l = Gu(t, u); try { qu(e, u, l); } catch (e) {} } } } return e; } function Qu(e) { return typeof e === 'function'; } function Ju(e) { return typeof e === 'object' && 'styledComponentId' in e; } function el(e, t) { return e && t ? ''.concat(e, ' ').concat(t) : e || t || ''; } function tl(e, t) { if (e.length === 0) return ''; for (var r = e[0], n = 1; n < e.length; n++)r += t ? t + e[n] : e[n]; return r; } function rl(e) { return e !== null && typeof e === 'object' && e.constructor.name === Object.name && !('props' in e && e.$$typeof); } function nl(e, t, r) { if (void 0 === r && (r = !1), !r && !rl(e) && !Array.isArray(e)) return t; if (Array.isArray(t)) for (var n = 0; n < t.length; n++)e[n] = nl(e[n], t[n]); else if (rl(t)) for (var n in t)e[n] = nl(e[n], t[n]); return e; } function il(e, t) { Object.defineProperty(e, 'toString', { value: t }); } function al(e) { for (var t = [], r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; return new Error('An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#'.concat(e, ' for more information.').concat(t.length > 0 ? ' Args: '.concat(t.join(', ')) : '')); } const ol = (function () { function e(e) { this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e; } return e.prototype.indexOfGroup = function (e) { for (var t = 0, r = 0; r < e; r++)t += this.groupSizes[r]; return t; }, e.prototype.insertRules = function (e, t) { if (e >= this.groupSizes.length) { for (var r = this.groupSizes, n = r.length, i = n; e >= i;) if ((i <<= 1) < 0) throw al(16, ''.concat(e)); this.groupSizes = new Uint32Array(i), this.groupSizes.set(r), this.length = i; for (var a = n; a < i; a++) this.groupSizes[a] = 0; } for (let o = this.indexOfGroup(e + 1), s = (a = 0, t.length); a < s; a++) this.tag.insertRule(o, t[a]) && (this.groupSizes[e]++, o++); }, e.prototype.clearGroup = function (e) { if (e < this.length) { const t = this.groupSizes[e]; const r = this.indexOfGroup(e); const n = r + t; this.groupSizes[e] = 0; for (let i = r; i < n; i++) this.tag.deleteRule(r); } }, e.prototype.getGroup = function (e) { let t = ''; if (e >= this.length || this.groupSizes[e] === 0) return t; for (let r = this.groupSizes[e], n = this.indexOfGroup(e), i = n + r, a = n; a < i; a++)t += ''.concat(this.tag.getRule(a)).concat('/*!sc*/\n'); return t; }, e; }()); const sl = new Map(); const ul = new Map(); let ll = 1; const cl = function (e) { if (sl.has(e)) return sl.get(e); for (;ul.has(ll);)ll++; const t = ll++; return sl.set(e, t), ul.set(t, e), t; }; const hl = function (e, t) { sl.set(e, t), ul.set(t, e); }; const fl = 'style['.concat(bu, '][').concat('data-styled-version', '="').concat('6.1.0', '"]'); const dl = new RegExp('^'.concat(bu, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')); const pl = function (e, t, r) { for (var n, i = r.split(','), a = 0, o = i.length; a < o; a++)(n = i[a]) && e.registerName(t, n); }; const ml = function (e, t) { for (var r, n = ((r = t.textContent) !== null && void 0 !== r ? r : '').split('/*!sc*/\n'), i = [], a = 0, o = n.length; a < o; a++) { const s = n[a].trim(); if (s) { const u = s.match(dl); if (u) { const l = 0 | parseInt(u[1], 10); const c = u[2]; l !== 0 && (hl(c, l), pl(e, c, u[3]), e.getTag().insertRules(l, i)), i.length = 0; } else i.push(s); } } }; function vl() { return __webpack_require__.nc; } const gl = function (e) { const t = document.head; const r = e || t; const n = document.createElement('style'); const i = (function (e) { const t = Array.from(e.querySelectorAll('style['.concat(bu, ']'))); return t[t.length - 1]; }(r)); const a = void 0 !== i ? i.nextSibling : null; n.setAttribute(bu, 'active'), n.setAttribute('data-styled-version', '6.1.0'); const o = vl(); return o && n.setAttribute('nonce', o), r.insertBefore(n, a), n; }; const yl = (function () { function e(e) { this.element = gl(e), this.element.appendChild(document.createTextNode('')), this.sheet = (function (e) { if (e.sheet) return e.sheet; for (let t = document.styleSheets, r = 0, n = t.length; r < n; r++) { const i = t[r]; if (i.ownerNode === e) return i; } throw al(17); }(this.element)), this.length = 0; } return e.prototype.insertRule = function (e, t) { try { return this.sheet.insertRule(t, e), this.length++, !0; } catch (e) { return !1; } }, e.prototype.deleteRule = function (e) { this.sheet.deleteRule(e), this.length--; }, e.prototype.getRule = function (e) { const t = this.sheet.cssRules[e]; return t && t.cssText ? t.cssText : ''; }, e; }()); const bl = (function () { function e(e) { this.element = gl(e), this.nodes = this.element.childNodes, this.length = 0; } return e.prototype.insertRule = function (e, t) { if (e <= this.length && e >= 0) { const r = document.createTextNode(t); return this.element.insertBefore(r, this.nodes[e] || null), this.length++, !0; } return !1; }, e.prototype.deleteRule = function (e) { this.element.removeChild(this.nodes[e]), this.length--; }, e.prototype.getRule = function (e) { return e < this.length ? this.nodes[e].textContent : ''; }, e; }()); const wl = (function () { function e(e) { this.rules = [], this.length = 0; } return e.prototype.insertRule = function (e, t) { return e <= this.length && (this.rules.splice(e, 0, t), this.length++, !0); }, e.prototype.deleteRule = function (e) { this.rules.splice(e, 1), this.length--; }, e.prototype.getRule = function (e) { return e < this.length ? this.rules[e] : ''; }, e; }()); let kl = wu; const xl = { isServer: !wu, useCSSOMInjection: !ku }; const _l = (function () { function e(e, t, r) { void 0 === e && (e = _u), void 0 === t && (t = {}); const n = this; this.options = { ...xl, ...e }, this.gs = t, this.names = new Map(r), this.server = !!e.isServer, !this.server && wu && kl && (kl = !1, (function (e) { for (let t = document.querySelectorAll(fl), r = 0, n = t.length; r < n; r++) { const i = t[r]; i && i.getAttribute(bu) !== 'active' && (ml(e, i), i.parentNode && i.parentNode.removeChild(i)); } }(this))), il(this, (() => (function (e) { for (var t = e.getTag(), r = t.length, n = '', i = function (r) { const i = (function (e) { return ul.get(e); }(r)); if (void 0 === i) return 'continue'; const a = e.names.get(i); const o = t.getGroup(r); if (void 0 === a || o.length === 0) return 'continue'; const s = ''.concat(bu, '.g').concat(r, '[id="').concat(i, '"]'); let u = ''; void 0 !== a && a.forEach(((e) => { e.length > 0 && (u += ''.concat(e, ',')); })), n += ''.concat(o).concat(s, '{content:"').concat(u, '"}').concat('/*!sc*/\n'); }, a = 0; a < r; a++)i(a); return n; }(n)))); } return e.registerId = function (e) { return cl(e); }, e.prototype.reconstructWithOptions = function (t, r) { return void 0 === r && (r = !0), new e(({ ...this.options, ...t }), this.gs, r && this.names || void 0); }, e.prototype.allocateGSInstance = function (e) { return this.gs[e] = (this.gs[e] || 0) + 1; }, e.prototype.getTag = function () { return this.tag || (this.tag = (e = (function (e) { const t = e.useCSSOMInjection; const r = e.target; return e.isServer ? new wl(r) : t ? new yl(r) : new bl(r); }(this.options)), new ol(e))); let e; }, e.prototype.hasNameForId = function (e, t) { return this.names.has(e) && this.names.get(e).has(t); }, e.prototype.registerName = function (e, t) { if (cl(e), this.names.has(e)) this.names.get(e).add(t); else { const r = new Set(); r.add(t), this.names.set(e, r); } }, e.prototype.insertRules = function (e, t, r) { this.registerName(e, t), this.getTag().insertRules(cl(e), r); }, e.prototype.clearNames = function (e) { this.names.has(e) && this.names.get(e).clear(); }, e.prototype.clearRules = function (e) { this.getTag().clearGroup(cl(e)), this.clearNames(e); }, e.prototype.clearTag = function () { this.tag = void 0; }, e; }()); const Sl = /&/g; const Ml = /^\s*\/\/.*$/gm; function El(e, t) { return e.map(((e) => (e.type === 'rule' && (e.value = ''.concat(t, ' ').concat(e.value), e.value = e.value.replaceAll(',', ','.concat(t, ' ')), e.props = e.props.map(((e) => ''.concat(t, ' ').concat(e)))), Array.isArray(e.children) && e.type !== '@keyframes' && (e.children = El(e.children, t)), e))); } function Cl(e) { let t; let r; let n; const i = void 0 === e ? _u : e; const a = i.options; const o = void 0 === a ? _u : a; const s = i.plugins; const u = void 0 === s ? xu : s; const l = function (e, n, i) { return i === r || i.startsWith(r) && i.endsWith(r) && i.replaceAll(r, '').length > 0 ? '.'.concat(t) : e; }; const c = u.slice(); c.push(((e) => { e.type === Ss && e.value.includes('&') && (e.props[0] = e.props[0].replace(Sl, r).replace(n, l)); })), o.prefix && c.push(du), c.push(hu); const h = function (e, i, a, s) { void 0 === i && (i = ''), void 0 === a && (a = ''), void 0 === s && (s = '&'), t = s, r = i, n = new RegExp('\\'.concat(r, '\\b'), 'g'); const u = e.replace(Ml, ''); let l = pu(a || i ? ''.concat(a, ' ').concat(i, ' { ').concat(u, ' }') : u); o.namespace && (l = El(l, o.namespace)); let h; const f = []; return cu(l, (function (e) { const t = Fs(e); return function (r, n, i, a) { for (var o = '', s = 0; s < t; s++)o += e[s](r, n, i, a) || ''; return o; }; }(c.concat((h = function (e) { return f.push(e); }, function (e) { e.root || (e = e.return) && h(e); }))))), f; }; return h.hash = u.length ? u.reduce(((e, t) => (t.name || al(15), Ou(e, t.name))), 5381).toString() : '', h; } const Pl = new _l(); const Al = Cl(); const Tl = i.createContext({ shouldForwardProp: void 0, styleSheet: Pl, stylis: Al }); const
      Rl = (Tl.Consumer, i.createContext(void 0)); function Il() { return (0, i.useContext)(Tl); } function Ol(e) { const t = (0, i.useState)(e.stylisPlugins); const r = t[0]; const n = t[1]; const a = Il().styleSheet; const o = (0, i.useMemo)((() => { let t = a; return e.sheet ? t = e.sheet : e.target && (t = t.reconstructWithOptions({ target: e.target }, !1)), e.disableCSSOMInjection && (t = t.reconstructWithOptions({ useCSSOMInjection: !1 })), t; }), [e.disableCSSOMInjection, e.sheet, e.target, a]); const s = (0, i.useMemo)((() => Cl({ options: { namespace: e.namespace, prefix: e.enableVendorPrefixes }, plugins: r })), [e.enableVendorPrefixes, e.namespace, r]); (0, i.useEffect)((() => { bs()(r, e.stylisPlugins) || n(e.stylisPlugins); }), [e.stylisPlugins]); const u = (0, i.useMemo)((() => ({ shouldForwardProp: e.shouldForwardProp, styleSheet: o, stylis: s })), [e.shouldForwardProp, o, s]); return i.createElement(Tl.Provider, { value: u }, i.createElement(Rl.Provider, { value: s }, e.children)); } const Dl = (function () { function e(e, t) { const r = this; this.inject = function (e, t) { void 0 === t && (t = Al); const n = r.name + t.hash; e.hasNameForId(r.id, n) || e.insertRules(r.id, n, t(r.rules, n, '@keyframes')); }, this.name = e, this.id = 'sc-keyframes-'.concat(e), this.rules = t, il(this, (() => { throw al(12, String(r.name)); })); } return e.prototype.getName = function (e) { return void 0 === e && (e = Al), this.name + e.hash; }, e; }()); const zl = function (e) { return e >= 'A' && e <= 'Z'; }; function Nl(e) { for (var t = '', r = 0; r < e.length; r++) { const n = e[r]; if (r === 1 && n === '-' && e[0] === '-') return e; zl(n) ? t += `-${n.toLowerCase()}` : t += n; } return t.startsWith('ms-') ? `-${t}` : t; } const Ll = function (e) { return e == null || !1 === e || e === ''; }; const jl = function e(t) { let r; let n; const i = []; for (const a in t) { const o = t[a]; t.hasOwnProperty(a) && !Ll(o) && (Array.isArray(o) && o.isCss || Qu(o) ? i.push(''.concat(Nl(a), ':'), o, ';') : rl(o) ? i.push.apply(i, gs(gs([''.concat(a, ' {')], e(o), !1), ['}'], !1)) : i.push(''.concat(Nl(a), ': ').concat((r = a, (n = o) == null || typeof n === 'boolean' || n === '' ? '' : typeof n !== 'number' || n === 0 || r in ji || r.startsWith('--') ? String(n).trim() : ''.concat(n, 'px')), ';'))); } return i; }; function Fl(e, t, r, n) { return Ll(e) ? [] : Ju(e) ? ['.'.concat(e.styledComponentId)] : Qu(e) ? !Qu(i = e) || i.prototype && i.prototype.isReactComponent || !t ? [e] : Fl(e(t), t, r, n) : e instanceof Dl ? r ? (e.inject(r, n), [e.getName(n)]) : [e] : rl(e) ? jl(e) : Array.isArray(e) ? Array.prototype.concat.apply(xu, e.map(((e) => Fl(e, t, r, n)))) : [e.toString()]; let i; } function Bl(e) { for (let t = 0; t < e.length; t += 1) { const r = e[t]; if (Qu(r) && !Ju(r)) return !1; } return !0; } const Ul = Du('6.1.0'); const Vl = (function () { function e(e, t, r) { this.rules = e, this.staticRulesId = '', this.isStatic = (void 0 === r || r.isStatic) && Bl(e), this.componentId = t, this.baseHash = Ou(Ul, t), this.baseStyle = r, _l.registerId(t); } return e.prototype.generateAndInjectStyles = function (e, t, r) { let n = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e, t, r) : ''; if (this.isStatic && !r.hash) if (this.staticRulesId && t.hasNameForId(this.componentId, this.staticRulesId))n = el(n, this.staticRulesId); else { const i = tl(Fl(this.rules, e, t, r)); const a = Ru(Ou(this.baseHash, i) >>> 0); if (!t.hasNameForId(this.componentId, a)) { const o = r(i, '.'.concat(a), void 0, this.componentId); t.insertRules(this.componentId, a, o); }n = el(n, a), this.staticRulesId = a; } else { for (var s = Ou(this.baseHash, r.hash), u = '', l = 0; l < this.rules.length; l++) { const c = this.rules[l]; if (typeof c === 'string')u += c; else if (c) { const h = tl(Fl(c, e, t, r)); s = Ou(s, h + l), u += h; } } if (u) { const f = Ru(s >>> 0); t.hasNameForId(this.componentId, f) || t.insertRules(this.componentId, f, r(u, '.'.concat(f), void 0, this.componentId)), n = el(n, f); } } return n; }, e; }()); const Yl = i.createContext(void 0); Yl.Consumer; const Hl = {}; new Set(); function ql(e, t, r) {
      const n = Ju(e); const a = e; const o = !Nu(e); const s = t.attrs; const u = void 0 === s ? xu : s; const l = t.componentId; const c = void 0 === l ? (function (e, t) { const r = typeof e !== 'string' ? 'sc' : Pu(e); Hl[r] = (Hl[r] || 0) + 1; const n = ''.concat(r, '-').concat(zu(`6.1.0${r}${Hl[r]}`)); return t ? ''.concat(t, '-').concat(n) : n; }(t.displayName, t.parentComponentId)) : l; const h = t.displayName; const f = (void 0 === h && (function (e) { Nu(e) ? 'styled.'.concat(e) : 'Styled('.concat((function (e) { return e.displayName || e.name || 'Component'; }(e)), ')'); }(e)), t.displayName && t.componentId ? ''.concat(Pu(t.displayName), '-').concat(t.componentId) : t.componentId || c); const d = n && a.attrs ? a.attrs.concat(u).filter(Boolean) : u; let p = t.shouldForwardProp; if (n && a.shouldForwardProp) { const m = a.shouldForwardProp; if (t.shouldForwardProp) { const v = t.shouldForwardProp; p = function (e, t) { return m(e, t) && v(e, t); }; } else p = m; } const g = new Vl(r, f, n ? a.componentStyle : void 0); var y = i.forwardRef(((e, t) => (function (e, t, r) { const n = e.attrs; const a = e.componentStyle; const o = e.defaultProps; const s = e.foldedComponentIds; const u = e.styledComponentId; const l = e.target; const c = i.useContext(Yl); const h = Il(); const f = e.shouldForwardProp || h.shouldForwardProp; const d = (function (e, t, r) { for (var n, i = { ...t, className: void 0, theme: r }, a = 0; a < e.length; a += 1) { const o = Qu(n = e[a]) ? n(i) : n; for (const s in o)i[s] = s === 'className' ? el(i[s], o[s]) : s === 'style' ? ({ ...i[s], ...o[s] }) : o[s]; } return t.className && (i.className = el(i.className, t.className)), i; }(n, t, Su(t, c, o) || _u)); const p = d.as || l; const m = {}; for (const v in d) void 0 === d[v] || v[0] === '$' || v === 'as' || v === 'theme' || (v === 'forwardedAs' ? m.as = d.forwardedAs : f && !f(v, p) || (m[v] = d[v])); const g = (function (e, t) { const r = Il(); return e.generateAndInjectStyles(t, r.styleSheet, r.stylis); }(a, d)); let y = el(s, u); return g && (y += ` ${g}`), d.className && (y += ` ${d.className}`), m[Nu(p) && !Mu.has(p) ? 'class' : 'className'] = y, m.ref = r, (0, i.createElement)(p, m); }(y, e, t)))); return y.attrs = d, y.componentStyle = g, y.shouldForwardProp = p, y.foldedComponentIds = n ? el(a.foldedComponentIds, a.styledComponentId) : '', y.styledComponentId = f, y.target = n ? a.target : e, Object.defineProperty(y, 'defaultProps', { get() { return this._foldedDefaultProps; }, set(e) { this._foldedDefaultProps = n ? (function (e) { for (var t = [], r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; for (let n = 0, i = t; n < i.length; n++)nl(e, i[n], !0); return e; }({}, a.defaultProps, e)) : e; } }), il(y, (() => '.'.concat(y.styledComponentId))), o && Ku(y, e, {
        attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0,
      }), y;
    } function Wl(e, t) { for (var r = [e[0]], n = 0, i = t.length; n < i; n += 1)r.push(t[n], e[n + 1]); return r; } const Xl = function (e) { return Object.assign(e, { isCss: !0 }); }; function Gl(e) { for (var t = [], r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; if (Qu(e) || rl(e)) return Xl(Fl(Wl(xu, gs([e], t, !0)))); const n = e; return t.length === 0 && n.length === 1 && typeof n[0] === 'string' ? Fl(n) : Xl(Fl(Wl(n, t))); } function $l(e, t, r) { if (void 0 === r && (r = _u), !t) throw al(1, t); const n = function (n) { for (var i = [], a = 1; a < arguments.length; a++)i[a - 1] = arguments[a]; return e(t, r, Gl.apply(void 0, gs([n], i, !1))); }; return n.attrs = function (n) { return $l(e, t, { ...r, attrs: Array.prototype.concat(r.attrs, n).filter(Boolean) }); }, n.withConfig = function (n) { return $l(e, t, { ...r, ...n }); }, n; } const Zl = function (e) { return $l(ql, e); }; const Kl = Zl; Mu.forEach(((e) => { Kl[e] = Zl(e); })); !(function () { function e(e, t) { this.rules = e, this.componentId = t, this.isStatic = Bl(e), _l.registerId(this.componentId + 1); }e.prototype.createStyles = function (e, t, r, n) { const i = n(tl(Fl(this.rules, t, r, n)), ''); const a = this.componentId + e; r.insertRules(a, a, i); }, e.prototype.removeStyles = function (e, t) { t.clearRules(this.componentId + e); }, e.prototype.renderStyles = function (e, t, r, n) { e > 2 && _l.registerId(this.componentId + e), this.removeStyles(e, r), this.createStyles(e, t, r, n); }; }()); (function () { function e() { const e = this; this._emitSheetCSS = function () { const t = e.instance.toString(); const r = vl(); const n = tl([r && 'nonce="'.concat(r, '"'), ''.concat(bu, '="true"'), ''.concat('data-styled-version', '="').concat('6.1.0', '"')].filter(Boolean), ' '); return '<style '.concat(n, '>').concat(t, '</style>'); }, this.getStyleTags = function () { if (e.sealed) throw al(2); return e._emitSheetCSS(); }, this.getStyleElement = function () { let t; if (e.sealed) throw al(2); const r = ((t = {})[bu] = '', t['data-styled-version'] = '6.1.0', t.dangerouslySetInnerHTML = { __html: e.instance.toString() }, t); const n = vl(); return n && (r.nonce = n), [i.createElement('style', { ...r, key: 'sc-0-0' })]; }, this.seal = function () { e.sealed = !0; }, this.instance = new _l({ isServer: !0 }), this.sealed = !1; }e.prototype.collectStyles = function (e) { if (this.sealed) throw al(2); return i.createElement(Ol, { sheet: this.instance }, e); }, e.prototype.interleaveWithNodeStream = function (e) { throw al(3); }; }()), '__sc-'.concat(bu, '__'); const Ql = {
      color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0,
    }; const Jl = i.createContext && i.createContext(Ql); let ec = function () { return ec = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) for (const i in t = arguments[r])Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e; }, ec.apply(this, arguments); }; const tc = function (e, t) { const r = {}; for (var n in e)Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]); if (e != null && typeof Object.getOwnPropertySymbols === 'function') { let i = 0; for (n = Object.getOwnPropertySymbols(e); i < n.length; i++)t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]); } return r; }; function rc(e) { return e && e.map(((e, t) => i.createElement(e.tag, { key: t, ...e.attr }, rc(e.child)))); } function nc(e) { return function (t) { return i.createElement(ic, { attr: { ...e.attr }, ...t }, rc(e.child)); }; } function ic(e) {
      const t = function (t) {
        let r; const n = e.attr; const a = e.size; const o = e.title; const s = tc(e, ['attr', 'size', 'title']); const u = a || t.size || '1em'; return t.className && (r = t.className), e.className && (r = (r ? `${r} ` : '') + e.className), i.createElement('svg', {
          stroke: 'currentColor', fill: 'currentColor', strokeWidth: '0', ...t.attr, ...n, ...s, className: r, style: { color: e.color || t.color, ...t.style, ...e.style }, height: u, width: u, xmlns: 'http://www.w3.org/2000/svg',
        }, o && i.createElement('title', null, o), e.children);
      }; return void 0 !== Jl ? i.createElement(Jl.Consumer, null, ((e) => t(e))) : t(Ql);
    } function ac(e) { return nc({ tag: 'svg', attr: { version: '1.1', viewBox: '0 0 17 17' }, child: [{ tag: 'g', attr: {}, child: [] }, { tag: 'path', attr: { d: 'M0.021 1.012v15h17v-15h-17zM8.137 8.509l-7.116 6.197v-12.412l7.116 6.215zM1.459 2.012h14.138l-7.079 6.165-7.059-6.165zM8.517 8.841l7.066 6.171h-14.152l7.086-6.171zM8.898 8.509l7.123-6.204v12.425l-7.123-6.221z' } }] })(e); } const oc = JSON.parse('[{"key":1,"content":"Make sure that your face is well-lit and that you are facing the camera directly."},{"key":2,"content":"If you are denied clearance, make sure you are wearing your mask properly; your chin, nose and mouth should all be completely covered."},{"key":3,"content":"The QR code you receive upon successful verification will last 15 minutes. After that, you must take another photo to reacquire clearance."}]'); function sc(e) { return nc({ tag: 'svg', attr: { viewBox: '0 0 24 24' }, child: [{ tag: 'path', attr: { fill: 'none', d: 'M0 0h24v24H0z' } }, { tag: 'path', attr: { d: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z' } }] })(e); } function uc(e) { return nc({ tag: 'svg', attr: { viewBox: '0 0 24 24' }, child: [{ tag: 'path', attr: { fill: 'none', d: 'M0 0h24v24H0z' } }, { tag: 'path', attr: { d: 'M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z' } }] })(e); } function lc(e) { return nc({ tag: 'svg', attr: { viewBox: '0 0 24 24' }, child: [{ tag: 'path', attr: { fill: 'none', d: 'M0 0h24v24H0V0z' } }, { tag: 'path', attr: { d: 'M11 7h2v2h-2V7zm0 4h2v6h-2v-6zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z' } }] })(e); } function cc(e) { return nc({ tag: 'svg', attr: { viewBox: '0 0 24 24' }, child: [{ tag: 'path', attr: { fill: 'none', d: 'M0 0h24v24H0z' } }, { tag: 'circle', attr: { cx: '12', cy: '12', r: '3.2' } }, { tag: 'path', attr: { d: 'M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z' } }] })(e); } function hc(e) { return nc({ tag: 'svg', attr: { viewBox: '0 0 24 24' }, child: [{ tag: 'path', attr: { fill: 'none', d: 'M0 0h24v24H0V0z' } }, { tag: 'path', attr: { d: 'M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm6.93 6h-2.95a15.65 15.65 0 00-1.38-3.56A8.03 8.03 0 0118.92 8zM12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96zM4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2s.06 1.34.14 2H4.26zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56A7.987 7.987 0 015.08 16zm2.95-8H5.08a7.987 7.987 0 014.33-3.56A15.65 15.65 0 008.03 8zM12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96zM14.34 14H9.66c-.09-.66-.16-1.32-.16-2s.07-1.35.16-2h4.68c.09.65.16 1.32.16 2s-.07 1.34-.16 2zm.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95a8.03 8.03 0 01-4.33 3.56zM16.36 14c.08-.66.14-1.32.14-2s-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2h-3.38z' } }] })(e); } function fc(e) { return nc({ tag: 'svg', attr: { viewBox: '0 0 24 24' }, child: [{ tag: 'path', attr: { fill: 'none', d: 'M0 0h24v24H0V0z' } }, { tag: 'path', attr: { d: 'M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12l4.58-4.59z' } }] })(e); } function dc(e) { return nc({ tag: 'svg', attr: { viewBox: '0 0 24 24' }, child: [{ tag: 'path', attr: { fill: 'none', d: 'M0 0h24v24H0V0z' } }, { tag: 'path', attr: { d: 'M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6-6-6z' } }] })(e); } function pc(e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; const n = {}; return Object.keys(e).forEach(((i) => { n[i] = e[i].reduce(((e, n) => { if (n) { const i = t(n); i !== '' && e.push(i), r && r[n] && e.push(r[n]); } return e; }), []).join(' '); })), n; } const mc = ['variant']; function vc(e) { return e.length === 0; } function gc(e) { const t = e.variant; const r = m(e, mc); let n = t || ''; return Object.keys(r).sort().forEach(((t) => { n += t === 'color' ? vc(n) ? e[t] : la(e[t]) : ''.concat(vc(n) ? t : la(t)).concat(la(e[t].toString())); })), n; } const yc = ['name', 'slot', 'skipVariantsResolver', 'skipSx', 'overridesResolver']; const bc = function (e) { const t = {}; return e && e.forEach(((e) => { const r = gc(e.props); t[r] = e.style; })), t; }; const wc = function (e, t, r) { const n = e.ownerState; const i = void 0 === n ? {} : n; const a = []; return r && r.forEach(((r) => { let n = !0; Object.keys(r.props).forEach(((t) => { i[t] !== r.props[t] && e[t] !== r.props[t] && (n = !1); })), n && a.push(t[gc(r.props)]); })), a; }; function kc(e) { return e !== 'ownerState' && e !== 'theme' && e !== 'sx' && e !== 'as'; } const xc = ko(); function _c(e) { let t; const r = e.defaultTheme; const n = e.theme; const i = e.themeId; return t = n, Object.keys(t).length === 0 ? r : n[i] || n; } const Sc = function (e) { let t; const r = e.styledArg; const n = e.props; const i = r(Tn({}, n, { theme: _c(Tn({}, n, { defaultTheme: e.defaultTheme, themeId: e.themeId })) })); if (i && i.variants && (t = i.variants, delete i.variants), t) { const a = wc(n, bc(t), t); return [i].concat(P(a)); } return i; }; function Mc() {
      const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.themeId; const r = e.defaultTheme; const n = void 0 === r ? xc : r; const i = e.rootShouldForwardProp; const a = void 0 === i ? kc : i; const o = e.slotShouldForwardProp; const s = void 0 === o ? kc : o; const u = function (e) { return fo(Tn({}, e, { theme: _c(Tn({}, e, { defaultTheme: n, themeId: t })) })); }; return u.__mui_systemSx = !0, function (e) {
        const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; !(function (e, t) { Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles)); }(e, ((e) => e.filter(((e) => !(e != null && e.__mui_systemSx)))))); let i; let o; const l = r.name; const c = r.slot; const h = r.skipVariantsResolver; const f = r.skipSx; const p = r.overridesResolver; const v = void 0 === p ? (i = (o = c) ? o.charAt(0).toLowerCase() + o.slice(1) : o) ? function (e, t) { return t[i]; } : null : p; const g = m(r, yc); const y = void 0 !== h ? h : c && c !== 'Root' && c !== 'root' || !1; const b = f || !1; let w = kc; c === 'Root' || c === 'root' ? w = a : c ? w = s : (function (e) { return typeof e === 'string' && e.charCodeAt(0) > 96; }(e)) && (w = void 0); const k = sa(e, Tn({ shouldForwardProp: w, label: undefined }, g)); const x = function (r) {
          for (var i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++)a[o - 1] = arguments[o]; let s; const c = a ? a.map(((e) => {
            if (typeof e === 'function' && e.__emotion_real !== e) {
              return function (r) {
                return Sc({
                  styledArg: e, props: r, defaultTheme: n, themeId: t,
                });
              };
            } if (ca(e)) { let r; let i = e; return e && e.variants && (r = e.variants, delete i.variants, i = function (t) { let n = e; return wc(t, bc(r), r).forEach(((e) => { n = fa(n, e); })), n; }), i; } return e;
          })) : []; let h = r; ca(r) ? r && r.variants && (s = r.variants, delete h.variants, h = function (e) { let t = r; return wc(e, bc(s), s).forEach(((e) => { t = fa(t, e); })), t; }) : typeof r === 'function' && r.__emotion_real !== r && (h = function (e) {
            return Sc({
              styledArg: r, props: e, defaultTheme: n, themeId: t,
            });
          }); l && v && c.push(((e) => { const r = _c(Tn({}, e, { defaultTheme: n, themeId: t })); const i = (function (e, t) { return t.components && t.components[e] && t.components[e].styleOverrides ? t.components[e].styleOverrides : null; }(l, r)); if (i) { const a = {}; return Object.entries(i).forEach(((t) => { const n = d(t, 2); const i = n[0]; const o = n[1]; a[i] = typeof o === 'function' ? o(Tn({}, e, { theme: r })) : o; })), v(e, a); } return null; })), l && !y && c.push(((e) => { const r = _c(Tn({}, e, { defaultTheme: n, themeId: t })); return (function (e, t, r, n) { let i; const a = r == null || (i = r.components) == null || (i = i[n]) == null ? void 0 : i.variants; return wc(e, t, a); }(e, (function (e, t) { let r = []; return t && t.components && t.components[e] && t.components[e].variants && (r = t.components[e].variants), bc(r); }(l, r)), r, l)); })), b || c.push(u); const f = c.length - a.length; if (Array.isArray(r) && f > 0) { const p = new Array(f).fill(''); (h = [].concat(P(r), P(p))).raw = [].concat(P(r.raw), P(p)); } const m = k.apply(void 0, [h].concat(P(c))); return e.muiName && (m.muiName = e.muiName), m;
        }; return k.withConfig && (x.withConfig = k.withConfig), x;
      };
    } const Ec = hs(); const Cc = function (e) { return kc(e) && e !== 'classes'; }; const Pc = Mc({ themeId: fs, defaultTheme: Ec, rootShouldForwardProp: Cc }); function Ac(e, t) { const r = Tn({}, t); return Object.keys(e).forEach(((n) => { if (n.toString().match(/^(components|slots)$/))r[n] = Tn({}, e[n], r[n]); else if (n.toString().match(/^(componentsProps|slotProps)$/)) { const i = e[n] || {}; const a = t[n]; r[n] = {}, a && Object.keys(a) ? i && Object.keys(i) ? (r[n] = Tn({}, a), Object.keys(i).forEach(((e) => { r[n][e] = Ac(i[e], a[e]); }))) : r[n] = a : r[n] = i; } else void 0 === r[n] && (r[n] = e[n]); })), r; } function Tc(e) { const t = e.props; const r = e.name; const n = e.defaultTheme; const i = e.themeId; let a = So(n); i && (a = a[i] || a); const o = (function (e) { const t = e.theme; const r = e.name; const n = e.props; return t && t.components && t.components[r] && t.components[r].defaultProps ? Ac(t.components[r].defaultProps, n) : n; }({ theme: a, name: r, props: t })); return o; } function Rc(e) {
      return Tc({
        props: e.props, name: e.name, defaultTheme: Ec, themeId: fs,
      });
    } const Ic = function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return i.useMemo((() => (t.every(((e) => e == null)) ? null : function (e) { t.forEach(((t) => { !(function (e, t) { typeof e === 'function' ? e(t) : e && (e.current = t); }(t, e)); })); })), t); }; const Oc = typeof window !== 'undefined' ? i.useLayoutEffect : i.useEffect; let Dc; const zc = function (e) { const t = i.useRef(e); return Oc((() => { t.current = e; })), i.useRef((function () { return t.current.apply(void 0, arguments); })).current; }; const Nc = zc; let Lc = !0; let jc = !1; const Fc = {
      text: !0, search: !0, url: !0, tel: !0, email: !0, password: !0, number: !0, date: !0, month: !0, week: !0, time: !0, datetime: !0, 'datetime-local': !0,
    }; function Bc(e) { e.metaKey || e.altKey || e.ctrlKey || (Lc = !0); } function Uc() { Lc = !1; } function Vc() { this.visibilityState === 'hidden' && jc && (Lc = !0); } function Yc(e) { const t = e.target; try { return t.matches(':focus-visible'); } catch (r) {} return Lc || (function (e) { const t = e.type; const r = e.tagName; return !(r !== 'INPUT' || !Fc[t] || e.readOnly) || r === 'TEXTAREA' && !e.readOnly || !!e.isContentEditable; }(t)); } const Hc = function () {
      const e = i.useCallback(((e) => { let t; e != null && ((t = e.ownerDocument).addEventListener('keydown', Bc, !0), t.addEventListener('mousedown', Uc, !0), t.addEventListener('pointerdown', Uc, !0), t.addEventListener('touchstart', Uc, !0), t.addEventListener('visibilitychange', Vc, !0)); }), []); const t = i.useRef(!1); return {
        isFocusVisibleRef: t, onFocus(e) { return !!Yc(e) && (t.current = !0, !0); }, onBlur() { return !!t.current && (jc = !0, window.clearTimeout(Dc), Dc = window.setTimeout((() => { jc = !1; }), 100), t.current = !1, !0); }, ref: e,
      };
    }; const qc = i.createContext(null); function Wc(e, t) { const r = Object.create(null); return e && i.Children.map(e, ((e) => e)).forEach(((e) => { r[e.key] = (function (e) { return t && (0, i.isValidElement)(e) ? t(e) : e; }(e)); })), r; } function Xc(e, t, r) { return r[t] != null ? r[t] : e.props[t]; } function Gc(e, t, r) {
      const n = Wc(e.children); const a = (function (e, t) { function r(r) { return r in t ? t[r] : e[r]; }e = e || {}, t = t || {}; let n; const i = Object.create(null); let a = []; for (const o in e)o in t ? a.length && (i[o] = a, a = []) : a.push(o); const s = {}; for (const u in t) { if (i[u]) for (n = 0; n < i[u].length; n++) { const l = i[u][n]; s[i[u][n]] = r(l); }s[u] = r(u); } for (n = 0; n < a.length; n++)s[a[n]] = r(a[n]); return s; }(t, n)); return Object.keys(a).forEach(((o) => {
        const s = a[o]; if ((0, i.isValidElement)(s)) {
          const u = o in t; const l = o in n; const c = t[o]; const h = (0, i.isValidElement)(c) && !c.props.in; !l || u && !h ? l || !u || h ? l && u && (0, i.isValidElement)(c) && (a[o] = (0, i.cloneElement)(s, {
            onExited: r.bind(null, s), in: c.props.in, exit: Xc(s, 'exit', e), enter: Xc(s, 'enter', e),
          })) : a[o] = (0, i.cloneElement)(s, { in: !1 }) : a[o] = (0, i.cloneElement)(s, {
            onExited: r.bind(null, s), in: !0, exit: Xc(s, 'exit', e), enter: Xc(s, 'enter', e),
          });
        }
      })), a;
    } const $c = Object.values || function (e) { return Object.keys(e).map(((t) => e[t])); }; const Zc = (function (e) {
      let t; let r; function n(t, r) { let n; const i = (n = e.call(this, t, r) || this).handleExited.bind(M(n)); return n.state = { contextValue: { isMounting: !0 }, handleExited: i, firstRender: !0 }, n; }r = e, (t = n).prototype = Object.create(r.prototype), t.prototype.constructor = t, k(t, r); const a = n.prototype; return a.componentDidMount = function () { this.mounted = !0, this.setState({ contextValue: { isMounting: !1 } }); }, a.componentWillUnmount = function () { this.mounted = !1; }, n.getDerivedStateFromProps = function (e, t) {
        let r; let n; const a = t.children; const o = t.handleExited; return {
          children: t.firstRender ? (r = e, n = o, Wc(r.children, ((e) => (0, i.cloneElement)(e, {
            onExited: n.bind(null, e), in: !0, appear: Xc(e, 'appear', r), enter: Xc(e, 'enter', r), exit: Xc(e, 'exit', r),
          })))) : Gc(e, a, o),
          firstRender: !1,
        };
      }, a.handleExited = function (e, t) { const r = Wc(this.props.children); e.key in r || (e.props.onExited && e.props.onExited(t), this.mounted && this.setState(((t) => { const r = Tn({}, t.children); return delete r[e.key], { children: r }; }))); }, a.render = function () { const e = this.props; const t = e.component; const r = e.childFactory; const n = m(e, ['component', 'childFactory']); const a = this.state.contextValue; const o = $c(this.state.children).map(r); return delete n.appear, delete n.enter, delete n.exit, t === null ? i.createElement(qc.Provider, { value: a }, o) : i.createElement(qc.Provider, { value: a }, i.createElement(t, n, o)); }, n;
    }(i.Component)); Zc.propTypes = {}, Zc.defaultProps = { component: 'div', childFactory(e) { return e; } }; const Kc = Zc; __webpack_require__(2110); function Qc() { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return Gi(t); } const Jc = function () {
      const e = Qc.apply(void 0, arguments); const t = `animation-${e.name}`; return {
        name: t, styles: `@keyframes ${t}{${e.styles}}`, anim: 1, toString() { return `_EMO_${this.name}_${this.styles}_EMO_`; },
      };
    }; const eh = function (e) {
      const t = e.className; const r = e.classes; const n = e.pulsate; const a = void 0 !== n && n; const o = e.rippleX; const s = e.rippleY; const u = e.rippleSize; const l = e.in; const c = e.onExited; const h = e.timeout; const f = d(i.useState(!1), 2); const p = f[0]; const m = f[1]; const v = In(t, r.ripple, r.rippleVisible, a && r.ripplePulsate); const g = {
        width: u, height: u, top: -u / 2 + s, left: -u / 2 + o,
      }; const y = In(r.child, p && r.childLeaving, a && r.childPulsate); return l || p || m(!0), i.useEffect((() => { if (!l && c != null) { const e = setTimeout(c, h); return function () { clearTimeout(e); }; } }), [c, l, h]), (0, Mo.jsx)('span', { className: v, style: g, children: (0, Mo.jsx)('span', { className: y }) });
    }; const th = {
      active: 'active', checked: 'checked', completed: 'completed', disabled: 'disabled', error: 'error', expanded: 'expanded', focused: 'focused', focusVisible: 'focusVisible', open: 'open', readOnly: 'readOnly', required: 'required', selected: 'selected',
    }; function rh(e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'Mui'; const n = th[t]; return n ? ''.concat(r, '-').concat(n) : ''.concat(Po.generate(e), '-').concat(t); } function nh(e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'Mui'; const n = {}; return t.forEach(((t) => { n[t] = rh(e, t, r); })), n; } let ih; let ah; let oh; let sh; let uh; let lh; let ch; let hh; const fh = nh('MuiTouchRipple', ['root', 'ripple', 'rippleVisible', 'ripplePulsate', 'child', 'childLeaving', 'childPulsate']); const dh = ['center', 'classes', 'className']; const ph = Jc(uh || (uh = ih || (ih = p(['\n  0% {\n    transform: scale(0);\n    opacity: 0.1;\n  }\n\n  100% {\n    transform: scale(1);\n    opacity: 0.3;\n  }\n'])))); const mh = Jc(lh || (lh = ah || (ah = p(['\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n'])))); const vh = Jc(ch || (ch = oh || (oh = p(['\n  0% {\n    transform: scale(1);\n  }\n\n  50% {\n    transform: scale(0.92);\n  }\n\n  100% {\n    transform: scale(1);\n  }\n'])))); const gh = Pc('span', { name: 'MuiTouchRipple', slot: 'Root' })({
      overflow: 'hidden', pointerEvents: 'none', position: 'absolute', zIndex: 0, top: 0, right: 0, bottom: 0, left: 0, borderRadius: 'inherit',
    }); const yh = Pc(eh, { name: 'MuiTouchRipple', slot: 'Ripple' })(hh || (hh = sh || (sh = p(['\n  opacity: 0;\n  position: absolute;\n\n  &.', ' {\n    opacity: 0.3;\n    transform: scale(1);\n    animation-name: ', ';\n    animation-duration: ', 'ms;\n    animation-timing-function: ', ';\n  }\n\n  &.', ' {\n    animation-duration: ', 'ms;\n  }\n\n  & .', ' {\n    opacity: 1;\n    display: block;\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    background-color: currentColor;\n  }\n\n  & .', ' {\n    opacity: 0;\n    animation-name: ', ';\n    animation-duration: ', 'ms;\n    animation-timing-function: ', ';\n  }\n\n  & .', ' {\n    position: absolute;\n    /* @noflip */\n    left: 0px;\n    top: 0;\n    animation-name: ', ';\n    animation-duration: 2500ms;\n    animation-timing-function: ', ';\n    animation-iteration-count: infinite;\n    animation-delay: 200ms;\n  }\n']))), fh.rippleVisible, ph, 550, ((e) => e.theme.transitions.easing.easeInOut), fh.ripplePulsate, ((e) => e.theme.transitions.duration.shorter), fh.child, fh.childLeaving, mh, 550, ((e) => e.theme.transitions.easing.easeInOut), fh.childPulsate, vh, ((e) => e.theme.transitions.easing.easeInOut)); const bh = i.forwardRef(((e, t) => {
      const r = Rc({ props: e, name: 'MuiTouchRipple' }); const n = r.center; const a = void 0 !== n && n; const o = r.classes; const s = void 0 === o ? {} : o; const u = r.className; const l = m(r, dh); const c = d(i.useState([]), 2); const h = c[0]; const f = c[1]; const p = i.useRef(0); const v = i.useRef(null); i.useEffect((() => { v.current && (v.current(), v.current = null); }), [h]); const g = i.useRef(!1); const y = i.useRef(0); const b = i.useRef(null); const w = i.useRef(null); i.useEffect((() => function () { y.current && clearTimeout(y.current); }), []); const k = i.useCallback(((e) => {
        const t = e.pulsate; const r = e.rippleX; const n = e.rippleY; const i = e.rippleSize; const a = e.cb; f(((e) => [].concat(P(e), [(0, Mo.jsx)(yh, {
          classes: {
            ripple: In(s.ripple, fh.ripple), rippleVisible: In(s.rippleVisible, fh.rippleVisible), ripplePulsate: In(s.ripplePulsate, fh.ripplePulsate), child: In(s.child, fh.child), childLeaving: In(s.childLeaving, fh.childLeaving), childPulsate: In(s.childPulsate, fh.childPulsate),
          },
          timeout: 550,
          pulsate: t,
          rippleX: r,
          rippleY: n,
          rippleSize: i,
        }, p.current)]))), p.current += 1, v.current = a;
      }), [s]); const x = i.useCallback((function () {
        const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {}; const n = t.pulsate; const i = void 0 !== n && n; const o = t.center; const s = void 0 === o ? a || t.pulsate : o; const u = t.fakeElement; const l = void 0 !== u && u; if ((e == null ? void 0 : e.type) === 'mousedown' && g.current)g.current = !1; else {
          (e == null ? void 0 : e.type) === 'touchstart' && (g.current = !0); let c; let h; let f; const d = l ? null : w.current; const p = d ? d.getBoundingClientRect() : {
            width: 0, height: 0, left: 0, top: 0,
          }; if (s || void 0 === e || e.clientX === 0 && e.clientY === 0 || !e.clientX && !e.touches)c = Math.round(p.width / 2), h = Math.round(p.height / 2); else { const m = e.touches && e.touches.length > 0 ? e.touches[0] : e; const v = m.clientX; const x = m.clientY; c = Math.round(v - p.left), h = Math.round(x - p.top); } if (s)(f = Math.sqrt((2 * p.width ** 2 + p.height ** 2) / 3)) % 2 === 0 && (f += 1); else { const _ = 2 * Math.max(Math.abs((d ? d.clientWidth : 0) - c), c) + 2; const S = 2 * Math.max(Math.abs((d ? d.clientHeight : 0) - h), h) + 2; f = Math.sqrt(_ ** 2 + S ** 2); }e != null && e.touches ? b.current === null && (b.current = function () {
            k({
              pulsate: i, rippleX: c, rippleY: h, rippleSize: f, cb: r,
            });
          }, y.current = setTimeout((() => { b.current && (b.current(), b.current = null); }), 80)) : k({
            pulsate: i, rippleX: c, rippleY: h, rippleSize: f, cb: r,
          });
        }
      }), [a, k]); const _ = i.useCallback((() => { x({}, { pulsate: !0 }); }), [x]); var S = i.useCallback(((e, t) => { if (clearTimeout(y.current), (e == null ? void 0 : e.type) === 'touchend' && b.current) return b.current(), b.current = null, void (y.current = setTimeout((() => { S(e, t); }))); b.current = null, f(((e) => (e.length > 0 ? e.slice(1) : e))), v.current = t; }), []); return i.useImperativeHandle(t, (() => ({ pulsate: _, start: x, stop: S })), [_, x, S]), (0, Mo.jsx)(gh, Tn({ className: In(fh.root, s.root, u), ref: w }, l, { children: (0, Mo.jsx)(Kc, { component: null, exit: !0, children: h }) }));
    })); const wh = bh; function kh(e) { return rh('MuiButtonBase', e); } let xh; const _h = nh('MuiButtonBase', ['root', 'disabled', 'focusVisible']); const Sh = ['action', 'centerRipple', 'children', 'className', 'component', 'disabled', 'disableRipple', 'disableTouchRipple', 'focusRipple', 'focusVisibleClassName', 'LinkComponent', 'onBlur', 'onClick', 'onContextMenu', 'onDragLeave', 'onFocus', 'onFocusVisible', 'onKeyDown', 'onKeyUp', 'onMouseDown', 'onMouseLeave', 'onMouseUp', 'onTouchEnd', 'onTouchMove', 'onTouchStart', 'tabIndex', 'TouchRippleProps', 'touchRippleRef', 'type']; const Mh = Pc('button', { name: 'MuiButtonBase', slot: 'Root', overridesResolver(e, t) { return t.root; } })((O(xh = {
      display: 'inline-flex', alignItems: 'center', justifyContent: 'center', position: 'relative', boxSizing: 'border-box', WebkitTapHighlightColor: 'transparent', backgroundColor: 'transparent', outline: 0, border: 0, margin: 0, borderRadius: 0, padding: 0, cursor: 'pointer', userSelect: 'none', verticalAlign: 'middle', MozAppearance: 'none', WebkitAppearance: 'none', textDecoration: 'none', color: 'inherit', '&::-moz-focus-inner': { borderStyle: 'none' },
    }, '&.'.concat(_h.disabled), { pointerEvents: 'none', cursor: 'default' }), O(xh, '@media print', { colorAdjust: 'exact' }), xh)); const Eh = i.forwardRef(((e, t) => {
      const r = Rc({ props: e, name: 'MuiButtonBase' }); const n = r.action; const a = r.centerRipple; const o = void 0 !== a && a; const s = r.children; const u = r.className; const l = r.component; const c = void 0 === l ? 'button' : l; const h = r.disabled; const f = void 0 !== h && h; const p = r.disableRipple; const v = void 0 !== p && p; const g = r.disableTouchRipple; const y = void 0 !== g && g; const b = r.focusRipple; const w = void 0 !== b && b; const k = r.LinkComponent; const x = void 0 === k ? 'a' : k; const _ = r.onBlur; const S = r.onClick; const M = r.onContextMenu; const E = r.onDragLeave; const C = r.onFocus; const P = r.onFocusVisible; const A = r.onKeyDown; const T = r.onKeyUp; const R = r.onMouseDown; const I = r.onMouseLeave; const O = r.onMouseUp; const D = r.onTouchEnd; const z = r.onTouchMove; const N = r.onTouchStart; const L = r.tabIndex; const j = void 0 === L ? 0 : L; const F = r.TouchRippleProps; const B = r.touchRippleRef; const U = r.type; const V = m(r, Sh); const Y = i.useRef(null); const H = i.useRef(null); const q = Ic(H, B); const W = Hc(); const X = W.isFocusVisibleRef; const G = W.onFocus; const $ = W.onBlur; const Z = W.ref; const K = d(i.useState(!1), 2); const Q = K[0]; const J = K[1]; f && Q && J(!1), i.useImperativeHandle(n, (() => ({ focusVisible() { J(!0), Y.current.focus(); } })), []); const ee = d(i.useState(!1), 2); const te = ee[0]; const re = ee[1]; i.useEffect((() => { re(!0); }), []); const ne = te && !v && !f; function ie(e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : y; return Nc(((n) => (t && t(n), !r && H.current && H.current[e](n), !0))); }i.useEffect((() => { Q && w && !v && te && H.current.pulsate(); }), [v, w, Q, te]); const ae = ie('start', R); const oe = ie('stop', M); const se = ie('stop', E); const ue = ie('stop', O); const le = ie('stop', ((e) => { Q && e.preventDefault(), I && I(e); })); const ce = ie('start', N); const he = ie('stop', D); const fe = ie('stop', z); const de = ie('stop', ((e) => { $(e), !1 === X.current && J(!1), _ && _(e); }), !1); const pe = Nc(((e) => { Y.current || (Y.current = e.currentTarget), G(e), !0 === X.current && (J(!0), P && P(e)), C && C(e); })); const me = function () { const e = Y.current; return c && c !== 'button' && !(e.tagName === 'A' && e.href); }; const ve = i.useRef(!1); const ge = Nc(((e) => { w && !ve.current && Q && H.current && e.key === ' ' && (ve.current = !0, H.current.stop(e, (() => { H.current.start(e); }))), e.target === e.currentTarget && me() && e.key === ' ' && e.preventDefault(), A && A(e), e.target === e.currentTarget && me() && e.key === 'Enter' && !f && (e.preventDefault(), S && S(e)); })); const ye = Nc(((e) => { w && e.key === ' ' && H.current && Q && !e.defaultPrevented && (ve.current = !1, H.current.stop(e, (() => { H.current.pulsate(e); }))), T && T(e), S && e.target === e.currentTarget && me() && e.key === ' ' && !e.defaultPrevented && S(e); })); let be = c; be === 'button' && (V.href || V.to) && (be = x); const we = {}; be === 'button' ? (we.type = void 0 === U ? 'button' : U, we.disabled = f) : (V.href || V.to || (we.role = 'button'), f && (we['aria-disabled'] = f)); const ke = Ic(t, Z, Y); const xe = Tn({}, r, {
        centerRipple: o, component: c, disabled: f, disableRipple: v, disableTouchRipple: y, focusRipple: w, tabIndex: j, focusVisible: Q,
      }); const _e = (function (e) { const t = e.disabled; const r = e.focusVisible; const n = e.focusVisibleClassName; const i = pc({ root: ['root', t && 'disabled', r && 'focusVisible'] }, kh, e.classes); return r && n && (i.root += ' '.concat(n)), i; }(xe)); return (0, Mo.jsxs)(Mh, Tn({
        as: be, className: In(_e.root, u), ownerState: xe, onBlur: de, onClick: S, onContextMenu: oe, onFocus: pe, onKeyDown: ge, onKeyUp: ye, onMouseDown: ae, onMouseLeave: le, onMouseUp: ue, onDragLeave: se, onTouchEnd: he, onTouchMove: fe, onTouchStart: ce, ref: ke, tabIndex: f ? -1 : j, type: U,
      }, we, V, { children: [s, ne ? (0, Mo.jsx)(wh, Tn({ ref: q, center: o }, F)) : null] }));
    })); const Ch = Eh; const Ph = la; function Ah(e) { return rh('MuiIconButton', e); } let Th; const Rh = nh('MuiIconButton', ['root', 'disabled', 'colorInherit', 'colorPrimary', 'colorSecondary', 'colorError', 'colorInfo', 'colorSuccess', 'colorWarning', 'edgeStart', 'edgeEnd', 'sizeSmall', 'sizeMedium', 'sizeLarge']); const Ih = ['edge', 'children', 'className', 'color', 'disabled', 'disableFocusRipple', 'size']; const Oh = Pc(Ch, { name: 'MuiIconButton', slot: 'Root', overridesResolver(e, t) { const r = e.ownerState; return [t.root, r.color !== 'default' && t['color'.concat(Ph(r.color))], r.edge && t['edge'.concat(Ph(r.edge))], t['size'.concat(Ph(r.size))]]; } })(((e) => {
      const t = e.theme; const r = e.ownerState; return Tn({
        textAlign: 'center', flex: '0 0 auto', fontSize: t.typography.pxToRem(24), padding: 8, borderRadius: '50%', overflow: 'visible', color: (t.vars || t).palette.action.active, transition: t.transitions.create('background-color', { duration: t.transitions.duration.shortest }),
      }, !r.disableRipple && { '&:hover': { backgroundColor: t.vars ? 'rgba('.concat(t.vars.palette.action.activeChannel, ' / ').concat(t.vars.palette.action.hoverOpacity, ')') : Do(t.palette.action.active, t.palette.action.hoverOpacity), '@media (hover: none)': { backgroundColor: 'transparent' } } }, r.edge === 'start' && { marginLeft: r.size === 'small' ? -3 : -12 }, r.edge === 'end' && { marginRight: r.size === 'small' ? -3 : -12 });
    }), ((e) => { let t; const r = e.theme; const n = e.ownerState; const i = (t = (r.vars || r).palette) == null ? void 0 : t[n.color]; return Tn({}, n.color === 'inherit' && { color: 'inherit' }, n.color !== 'inherit' && n.color !== 'default' && Tn({ color: i == null ? void 0 : i.main }, !n.disableRipple && { '&:hover': Tn({}, i && { backgroundColor: r.vars ? 'rgba('.concat(i.mainChannel, ' / ').concat(r.vars.palette.action.hoverOpacity, ')') : Do(i.main, r.palette.action.hoverOpacity) }, { '@media (hover: none)': { backgroundColor: 'transparent' } }) }), n.size === 'small' && { padding: 5, fontSize: r.typography.pxToRem(18) }, n.size === 'large' && { padding: 12, fontSize: r.typography.pxToRem(28) }, O({}, '&.'.concat(Rh.disabled), { backgroundColor: 'transparent', color: (r.vars || r).palette.action.disabled })); })); const Dh = i.forwardRef(((e, t) => {
      const r = Rc({ props: e, name: 'MuiIconButton' }); const n = r.edge; const i = void 0 !== n && n; const a = r.children; const o = r.className; const s = r.color; const u = void 0 === s ? 'default' : s; const l = r.disabled; const c = void 0 !== l && l; const h = r.disableFocusRipple; const f = void 0 !== h && h; const d = r.size; const p = void 0 === d ? 'medium' : d; const v = m(r, Ih); const g = Tn({}, r, {
        edge: i, color: u, disabled: c, disableFocusRipple: f, size: p,
      }); const y = (function (e) { const t = e.classes; const r = e.disabled; const n = e.color; const i = e.edge; const a = e.size; return pc({ root: ['root', r && 'disabled', n !== 'default' && 'color'.concat(Ph(n)), i && 'edge'.concat(Ph(i)), 'size'.concat(Ph(a))] }, Ah, t); }(g)); return (0, Mo.jsx)(Oh, Tn({
        className: In(y.root, o), centerRipple: !0, focusRipple: !f, disabled: c, ref: t, ownerState: g,
      }, v, { children: a }));
    })); const zh = Dh; const Nh = ['isShown']; const Lh = Kl(ms)(Th || (Th = p(['\n  opacity: ', ";\n  transition: opacity 0.3s ease-in-out;\n  &:before, &:after {\n    content: '';\n    position: absolute;\n    width: ", ';\n    height: ', ';\n    border-radius: ', ';\n    transition: .75s ease-in-out;\n  };\n  &:before {\n    border-top-left-radius: 5px;\n    top: 0;\n    left: 0;\n    border-top: 2px solid rgb(41, 121, 255);\n    border-left: 2px solid rgb(41, 121, 255);\n  };\n  &:after {\n    border-bottom-right-radius: 5px;\n    right: 0;\n    bottom: 0;\n    border-right: 2px solid rgb(41, 121, 255);\n    border-bottom: 2px solid rgb(41, 121, 255);\n  };\n'])), ((e) => (e.isShown ? '1' : '0')), ((e) => (e.isShown ? 'calc(100% - 2px)' : '30px')), ((e) => (e.isShown ? 'calc(100% - 2px)' : '30px')), ((e) => (e.isShown ? '5px' : '0px'))); const jh = function (e) {
      const t = d((0, i.useState)(0), 2); const r = t[0]; const n = t[1]; const a = an(r, {
        exitBeforeEnter: !0, from: { opacity: 0, transform: 'translate3d(100%, 0, 0)' }, enter: { opacity: 1, transform: 'translate3d(0%, 0, 0)' }, leave: { opacity: 0, transform: 'translate3d(-50%, 0, 0)' }, config: { mass: 0.5, tension: 180, friction: 21 },
      }); const o = d(rn(oc.length, ((e) => ({
        height: r === e ? '11px' : '7px', width: r === e ? '11px' : '7px', marginLeft: r === e ? '10%' : '5%', marginRight: r === e ? '10%' : '5%', config: { mass: 0.5, tension: 180, friction: 21 },
      })), [r]), 2); const s = o[0]; const u = (o[1], e.isShown); v(e, Nh); return (0, Mo.jsxs)(Lh, { isShown: u, className: 'help-pager', children: [(0, Mo.jsx)(ac, { size: '30%', class: 'page-image' }), a(((e, t) => (0, Mo.jsx)(Pn.div, { style: z({}, e), children: (0, Mo.jsx)('p', { className: 'page-text', children: oc[t].content }) }))), (0, Mo.jsxs)('div', { className: 'page-navigation', children: [(0, Mo.jsx)(zh, { onClick() { n(Math.max(r - 1, 0)); }, disabled: !u, children: (0, Mo.jsx)(fc, { style: { zIndex: 2 }, size: 'min(8vmin, 30px)' }) }), (0, Mo.jsx)('div', { className: 'dot-container', children: s.map(((e, t) => (0, Mo.jsx)(Pn.div, { className: 'page-dot', style: e }, t))) }), (0, Mo.jsx)(zh, { onClick() { n(Math.min(r + 1, oc.length - 1)); }, disabled: !u, children: (0, Mo.jsx)(dc, { style: { zIndex: 2 }, size: 'min(8vmin, 30px)' }) })] })] });
    }; const Fh = __webpack_require__(4805); const Bh = ['isShowingHelp']; const Uh = (0, i.forwardRef)(((e, t) => {
      const r = e.isShowingHelp; const n = (v(e, Bh), An()); const i = (0, Fh.useMediaQuery)({ query: '(min-aspect-ratio: 1/1)' }); const a = (0, Fh.useMediaQuery)({ query: '(max-aspect-ratio: 21/10) and (min-aspect-ratio: 10/21)' }); let o = {}; o = i ? { height: 0.7 * n.height, width: 0.7 * n.height * 4 / 3 } : { width: 0.9 * n.width, height: 0.9 * n.width * 3 / 4 }; const s = r ? { zIndex: 1 } : {}; const u = nn({ opacity: r && a ? '0%' : '100%', config: { mass: 3, friction: 26, tension: 170 } }).opacity; return (0, Mo.jsxs)('div', {
        className: 'webcam-container',
        children: [(0, Mo.jsx)(Pn.div, {
          className: 'webcam',
          style: { opacity: u },
          children: (0, Mo.jsx)(y(), {
            audio: !1, ref: t, screenshotFormat: 'image/jpeg', videoConstraints: { facingMode: 'user', aspectRatio: 4 / 3 }, style: o, class: 'webcam',
          }),
        }), a && (0, Mo.jsx)('div', { className: 'stacked-container', style: s, children: (0, Mo.jsx)(jh, { isShown: r }) })],
      });
    })); function Vh(e) { return rh('MuiButton', e); } const Yh = nh('MuiButton', ['root', 'text', 'textInherit', 'textPrimary', 'textSecondary', 'textSuccess', 'textError', 'textInfo', 'textWarning', 'outlined', 'outlinedInherit', 'outlinedPrimary', 'outlinedSecondary', 'outlinedSuccess', 'outlinedError', 'outlinedInfo', 'outlinedWarning', 'contained', 'containedInherit', 'containedPrimary', 'containedSecondary', 'containedSuccess', 'containedError', 'containedInfo', 'containedWarning', 'disableElevation', 'focusVisible', 'disabled', 'colorInherit', 'textSizeSmall', 'textSizeMedium', 'textSizeLarge', 'outlinedSizeSmall', 'outlinedSizeMedium', 'outlinedSizeLarge', 'containedSizeSmall', 'containedSizeMedium', 'containedSizeLarge', 'sizeMedium', 'sizeSmall', 'sizeLarge', 'fullWidth', 'startIcon', 'endIcon', 'iconSizeSmall', 'iconSizeMedium', 'iconSizeLarge']); const Hh = i.createContext({}); const qh = i.createContext(void 0); const Wh = ['children', 'color', 'component', 'className', 'disabled', 'disableElevation', 'disableFocusRipple', 'endIcon', 'focusVisibleClassName', 'fullWidth', 'size', 'startIcon', 'type', 'variant']; const Xh = function (e) { return Tn({}, e.size === 'small' && { '& > *:nth-of-type(1)': { fontSize: 18 } }, e.size === 'medium' && { '& > *:nth-of-type(1)': { fontSize: 20 } }, e.size === 'large' && { '& > *:nth-of-type(1)': { fontSize: 22 } }); }; const Gh = Pc(Ch, {
      shouldForwardProp(e) { return Cc(e) || e === 'classes'; }, name: 'MuiButton', slot: 'Root', overridesResolver(e, t) { const r = e.ownerState; return [t.root, t[r.variant], t[''.concat(r.variant).concat(Ph(r.color))], t['size'.concat(Ph(r.size))], t[''.concat(r.variant, 'Size').concat(Ph(r.size))], r.color === 'inherit' && t.colorInherit, r.disableElevation && t.disableElevation, r.fullWidth && t.fullWidth]; },
    })(((e) => {
      let t; let r; let n; const i = e.theme; const a = e.ownerState; const o = i.palette.mode === 'light' ? i.palette.grey[300] : i.palette.grey[800]; const s = i.palette.mode === 'light' ? i.palette.grey.A100 : i.palette.grey[700]; return Tn({}, i.typography.button, (O(t = {
        minWidth: 64, padding: '6px 16px', borderRadius: (i.vars || i).shape.borderRadius, transition: i.transitions.create(['background-color', 'box-shadow', 'border-color', 'color'], { duration: i.transitions.duration.short }), '&:hover': Tn({ textDecoration: 'none', backgroundColor: i.vars ? 'rgba('.concat(i.vars.palette.text.primaryChannel, ' / ').concat(i.vars.palette.action.hoverOpacity, ')') : Do(i.palette.text.primary, i.palette.action.hoverOpacity), '@media (hover: none)': { backgroundColor: 'transparent' } }, a.variant === 'text' && a.color !== 'inherit' && { backgroundColor: i.vars ? 'rgba('.concat(i.vars.palette[a.color].mainChannel, ' / ').concat(i.vars.palette.action.hoverOpacity, ')') : Do(i.palette[a.color].main, i.palette.action.hoverOpacity), '@media (hover: none)': { backgroundColor: 'transparent' } }, a.variant === 'outlined' && a.color !== 'inherit' && { border: '1px solid '.concat((i.vars || i).palette[a.color].main), backgroundColor: i.vars ? 'rgba('.concat(i.vars.palette[a.color].mainChannel, ' / ').concat(i.vars.palette.action.hoverOpacity, ')') : Do(i.palette[a.color].main, i.palette.action.hoverOpacity), '@media (hover: none)': { backgroundColor: 'transparent' } }, a.variant === 'contained' && { backgroundColor: i.vars ? i.vars.palette.Button.inheritContainedHoverBg : s, boxShadow: (i.vars || i).shadows[4], '@media (hover: none)': { boxShadow: (i.vars || i).shadows[2], backgroundColor: (i.vars || i).palette.grey[300] } }, a.variant === 'contained' && a.color !== 'inherit' && { backgroundColor: (i.vars || i).palette[a.color].dark, '@media (hover: none)': { backgroundColor: (i.vars || i).palette[a.color].main } }), '&:active': Tn({}, a.variant === 'contained' && { boxShadow: (i.vars || i).shadows[8] }),
      }, '&.'.concat(Yh.focusVisible), Tn({}, a.variant === 'contained' && { boxShadow: (i.vars || i).shadows[6] })), O(t, '&.'.concat(Yh.disabled), Tn({ color: (i.vars || i).palette.action.disabled }, a.variant === 'outlined' && { border: '1px solid '.concat((i.vars || i).palette.action.disabledBackground) }, a.variant === 'contained' && { color: (i.vars || i).palette.action.disabled, boxShadow: (i.vars || i).shadows[0], backgroundColor: (i.vars || i).palette.action.disabledBackground })), t), a.variant === 'text' && { padding: '6px 8px' }, a.variant === 'text' && a.color !== 'inherit' && { color: (i.vars || i).palette[a.color].main }, a.variant === 'outlined' && { padding: '5px 15px', border: '1px solid currentColor' }, a.variant === 'outlined' && a.color !== 'inherit' && { color: (i.vars || i).palette[a.color].main, border: i.vars ? '1px solid rgba('.concat(i.vars.palette[a.color].mainChannel, ' / 0.5)') : '1px solid '.concat(Do(i.palette[a.color].main, 0.5)) }, a.variant === 'contained' && { color: i.vars ? i.vars.palette.text.primary : (r = (n = i.palette).getContrastText) == null ? void 0 : r.call(n, i.palette.grey[300]), backgroundColor: i.vars ? i.vars.palette.Button.inheritContainedBg : o, boxShadow: (i.vars || i).shadows[2] }, a.variant === 'contained' && a.color !== 'inherit' && { color: (i.vars || i).palette[a.color].contrastText, backgroundColor: (i.vars || i).palette[a.color].main }, a.color === 'inherit' && { color: 'inherit', borderColor: 'currentColor' }, a.size === 'small' && a.variant === 'text' && { padding: '4px 5px', fontSize: i.typography.pxToRem(13) }, a.size === 'large' && a.variant === 'text' && { padding: '8px 11px', fontSize: i.typography.pxToRem(15) }, a.size === 'small' && a.variant === 'outlined' && { padding: '3px 9px', fontSize: i.typography.pxToRem(13) }, a.size === 'large' && a.variant === 'outlined' && { padding: '7px 21px', fontSize: i.typography.pxToRem(15) }, a.size === 'small' && a.variant === 'contained' && { padding: '4px 10px', fontSize: i.typography.pxToRem(13) }, a.size === 'large' && a.variant === 'contained' && { padding: '8px 22px', fontSize: i.typography.pxToRem(15) }, a.fullWidth && { width: '100%' });
    }), ((e) => { let t; return e.ownerState.disableElevation && (O(t = { boxShadow: 'none', '&:hover': { boxShadow: 'none' } }, '&.'.concat(Yh.focusVisible), { boxShadow: 'none' }), O(t, '&:active', { boxShadow: 'none' }), O(t, '&.'.concat(Yh.disabled), { boxShadow: 'none' }), t); })); const $h = Pc('span', { name: 'MuiButton', slot: 'StartIcon', overridesResolver(e, t) { const r = e.ownerState; return [t.startIcon, t['iconSize'.concat(Ph(r.size))]]; } })(((e) => { const t = e.ownerState; return Tn({ display: 'inherit', marginRight: 8, marginLeft: -4 }, t.size === 'small' && { marginLeft: -2 }, Xh(t)); })); const Zh = Pc('span', { name: 'MuiButton', slot: 'EndIcon', overridesResolver(e, t) { const r = e.ownerState; return [t.endIcon, t['iconSize'.concat(Ph(r.size))]]; } })(((e) => { const t = e.ownerState; return Tn({ display: 'inherit', marginRight: -4, marginLeft: 8 }, t.size === 'small' && { marginRight: -2 }, Xh(t)); })); const Kh = i.forwardRef(((e, t) => {
      const r = i.useContext(Hh); const n = i.useContext(qh); const a = Rc({ props: Ac(r, e), name: 'MuiButton' }); const o = a.children; const s = a.color; const u = void 0 === s ? 'primary' : s; const l = a.component; const c = void 0 === l ? 'button' : l; const h = a.className; const f = a.disabled; const d = void 0 !== f && f; const p = a.disableElevation; const v = void 0 !== p && p; const g = a.disableFocusRipple; const y = void 0 !== g && g; const b = a.endIcon; const w = a.focusVisibleClassName; const k = a.fullWidth; const x = void 0 !== k && k; const _ = a.size; const S = void 0 === _ ? 'medium' : _; const M = a.startIcon; const E = a.type; const C = a.variant; const P = void 0 === C ? 'text' : C; const A = m(a, Wh); const T = Tn({}, a, {
        color: u, component: c, disabled: d, disableElevation: v, disableFocusRipple: y, fullWidth: x, size: S, type: E, variant: P,
      }); const R = (function (e) {
        const t = e.color; const r = e.disableElevation; const n = e.fullWidth; const i = e.size; const a = e.variant; const o = e.classes; return Tn({}, o, pc({
          root: ['root', a, ''.concat(a).concat(Ph(t)), 'size'.concat(Ph(i)), ''.concat(a, 'Size').concat(Ph(i)), t === 'inherit' && 'colorInherit', r && 'disableElevation', n && 'fullWidth'], label: ['label'], startIcon: ['startIcon', 'iconSize'.concat(Ph(i))], endIcon: ['endIcon', 'iconSize'.concat(Ph(i))],
        }, Vh, o));
      }(T)); const I = M && (0, Mo.jsx)($h, { className: R.startIcon, ownerState: T, children: M }); const O = b && (0, Mo.jsx)(Zh, { className: R.endIcon, ownerState: T, children: b }); const D = n || ''; return (0, Mo.jsxs)(Gh, Tn({
        ownerState: T, className: In(r.className, R.root, h, D), component: c, disabled: d, focusRipple: !y, focusVisibleClassName: In(R.focusVisible, w), ref: t, type: E,
      }, A, { classes: R, children: [I, o, O] }));
    })); const Qh = Kh; const Jh = i.createContext(null); function ef() { return i.useContext(Jh); } const tf = typeof Symbol === 'function' && Symbol.for ? Symbol.for('mui.nested') : '__THEME_NESTED__'; const rf = function (e) { const t = e.children; const r = e.theme; const n = ef(); const a = i.useMemo((() => { const e = n === null ? r : (function (e, t) { return typeof t === 'function' ? t(e) : Tn({}, e, t); }(n, r)); return e != null && (e[tf] = n !== null), e; }), [r, n]); return (0, Mo.jsx)(Jh.Provider, { value: a, children: t }); }; const nf = {}; function af(e, t, r) { const n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; return i.useMemo((() => { const i = e && t[e] || t; if (typeof r === 'function') { const a = r(i); const o = e ? Tn({}, t, O({}, e, a)) : a; return n ? function () { return o; } : o; } return Tn({}, t, e ? O({}, e, r) : r); }), [e, t, r, n]); } const of = function (e) { const t = e.children; const r = e.theme; const n = e.themeId; const i = xo(nf); const a = ef() || nf; const o = af(n, i, r); const s = af(n, a, r, !0); return (0, Mo.jsx)(rf, { theme: s, children: (0, Mo.jsx)(Ji.Provider, { value: o, children: t }) }); }; const sf = ['theme']; function uf(e) { const t = e.theme; const r = m(e, sf); const n = t[fs]; return (0, Mo.jsx)(of, Tn({}, r, { themeId: n ? fs : void 0, theme: n || t })); } let lf; let cf; let hf; let ff; const df = hs({ palette: { primary: { main: '#2979FF' }, secondary: { main: '#0bb6e0' } } }); const pf = Kl(Pn.div)(lf || (lf = p(['\n  z-index: 10;\n  position: absolute;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  top: 50%;\n  left: 50%;\n  background-color: white;\n  border: solid 2px;\n  border-color: rgba(0, 0.5, 0.9, 0.6);\n  border-radius: 16px;\n  padding: 12px;\n  box-sizing: border-box;\n  @media (max-aspect-ratio: 11/10) {\n    width: 90%;\n  }\n  width: 99vh; \n  max-height: 95%;\n']))); const mf = Kl(Pn.div)(cf || (cf = p(['\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  z-index: 5;\n  transition: opacity .5s ease-in-out;\n  opacity: ', ';\n  background-color: rgba(0, 0, 0, 0.6)\n'])), ((e) => (e.isOpen ? '1' : '0'))); const vf = Kl.img(hf || (hf = p(['\n  height: 100%;\n  @media (max-device-height: 928px) {\n    max-height: 70vh;\n  }\n  max-height: 90vh;\n  @media (max-aspect-ratio: 1/1) {\n    max-width: 90vh;\n  }\n  width: 100%;\n  object-fit: contain;\n  border-radius: 16px;\n']))); const gf = Kl.div(ff || (ff = p(['\n  display: flex;\n  flex-direction: row;\n  justify-content: space-around;\n  align-items: center;\n  padding: 12px 0px 12px 0px;\n  max-width: 600px;\n  width: 100%;\n\n']))); const yf = function (e) {
      const t = e.imageClearer; const r = e.isOpen; const n = e.onClose; const i = e.onConfirm; const a = e.imgSrc; const o = an(r, {
        from: { opacity: 0, transform: 'translate(-50%, -150%)' }, enter: { opacity: 1, transform: 'translate(-50%, -50%)' }, leave: { opacity: 0, transform: 'translate(-50%, 100%)' }, config: { mass: 0.5, tension: 180, friction: 21 }, onRest() { r || t(); },
      }); return (0, Mo.jsx)(Mo.Fragment, {
        children: o(((e, t) => {
          if (t) {
            return (0, Mo.jsxs)(Mo.Fragment, {
              children: [(0, Mo.jsx)(mf, { onClick: n, isOpen: r }), (0, Mo.jsxs)(pf, {
                style: e,
                children: [(0, Mo.jsx)(vf, { src: a, alt: 'captured camera input' }), (0, Mo.jsx)(gf, {
                  children: (0, Mo.jsxs)(uf, {
                    theme: df,
                    children: [(0, Mo.jsx)(Qh, {
                      variant: 'contained', sx: { bgcolor: 'primary.main', margin: '5px' }, onClick: n, children: 'Discard',
                    }), (0, Mo.jsx)(Qh, {
                      variant: 'contained', sx: { bgcolor: 'primary.main', margin: '5px' }, onClick: i, children: 'Send',
                    })],
                  }),
                })],
              })],
            });
          }
        })),
      });
    }; const bf = __webpack_require__(2007); function wf(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function kf(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n); } } function xf(e, t, r) { return t && kf(e.prototype, t), r && kf(e, r), e; } function _f(e, t) { if (typeof t !== 'function' && t !== null) throw new TypeError('Super expression must either be null or a function'); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Mf(e, t); } function Sf(e) { return Sf = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e); }, Sf(e); } function Mf(e, t) { return Mf = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e; }, Mf(e, t); } function Ef(e, t) { return !t || typeof t !== 'object' && typeof t !== 'function' ? (function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }(e)) : t; } function Cf(e) { const t = (function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (() => {}))), !0; } catch (e) { return !1; } }()); return function () { let r; const n = Sf(e); if (t) { const i = Sf(this).constructor; r = Reflect.construct(n, arguments, i); } else r = n.apply(this, arguments); return Ef(this, r); }; } function Pf(e) { return (function (e) { if (Array.isArray(e)) return Af(e); }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && Symbol.iterator in Object(e)) return Array.from(e); }(e)) || (function (e, t) { if (!e) return; if (typeof e === 'string') return Af(e, t); let r = Object.prototype.toString.call(e).slice(8, -1); r === 'Object' && e.constructor && (r = e.constructor.name); if (r === 'Map' || r === 'Set') return Array.from(e); if (r === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Af(e, t); }(e)) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function Af(e, t) { (t == null || t > e.length) && (t = e.length); for (var r = 0, n = new Array(t); r < t; r++)n[r] = e[r]; return n; } function Tf(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2; const r = String(e); if (t === 0) return r; const n = r.match(/(.*?)([0-9]+)(.*)/); const i = n ? n[1] : ''; const a = n ? n[3] : ''; const o = n ? n[2] : r; const s = o.length >= t ? o : (Pf(Array(t)).map((() => '0')).join('') + o).slice(-1 * t); return ''.concat(i).concat(s).concat(a); } const Rf = { daysInHours: !1, zeroPadTime: 2 }; function If(e, t) {
      const r = e.days; const n = e.hours; const i = e.minutes; const a = e.seconds; const o = { ...Rf, ...t }; const s = o.daysInHours; const u = o.zeroPadTime; const l = o.zeroPadDays; const c = void 0 === l ? u : l; const h = Math.min(2, u); const f = s ? Tf(n + 24 * r, u) : Tf(n, h); return {
        days: s ? '' : Tf(r, c), hours: f, minutes: Tf(i, h), seconds: Tf(a, h),
      };
    } const Of = (function (e) { _f(r, e); const t = Cf(r); function r() { let e; return wf(this, r), (e = t.apply(this, arguments)).state = { count: e.props.count || 3 }, e.startCountdown = function () { e.interval = window.setInterval((() => { e.state.count - 1 === 0 ? (e.stopCountdown(), e.props.onComplete && e.props.onComplete()) : e.setState(((e) => ({ count: e.count - 1 }))); }), 1e3); }, e.stopCountdown = function () { clearInterval(e.interval); }, e.addTime = function (t) { e.stopCountdown(), e.setState(((e) => ({ count: e.count + t })), e.startCountdown); }, e; } return xf(r, [{ key: 'componentDidMount', value() { this.startCountdown(); } }, { key: 'componentWillUnmount', value() { clearInterval(this.interval); } }, { key: 'render', value() { return this.props.children ? (0, i.cloneElement)(this.props.children, { count: this.state.count }) : null; } }]), r; }(i.Component)); Of.propTypes = { count: bf.number, children: bf.element, onComplete: bf.func }; const Df = (function (e) {
      _f(r, e); const t = Cf(r); function r(e) { let n; if (wf(this, r), (n = t.call(this, e)).mounted = !1, n.initialTimestamp = n.calcOffsetStartTimestamp(), n.offsetStartTimestamp = n.props.autoStart ? 0 : n.initialTimestamp, n.offsetTime = 0, n.legacyMode = !1, n.legacyCountdownRef = (0, i.createRef)(), n.tick = function () { const e = n.calcTimeDelta(); const t = e.completed && !n.props.overtime ? void 0 : n.props.onTick; n.setTimeDeltaState(e, void 0, t); }, n.start = function () { if (!n.isStarted()) { const e = n.offsetStartTimestamp; n.offsetStartTimestamp = 0, n.offsetTime += e ? n.calcOffsetStartTimestamp() - e : 0; const t = n.calcTimeDelta(); n.setTimeDeltaState(t, 'STARTED', n.props.onStart), n.props.controlled || t.completed && !n.props.overtime || (n.clearTimer(), n.interval = window.setInterval(n.tick, n.props.intervalDelay)); } }, n.pause = function () { n.isPaused() || (n.clearTimer(), n.offsetStartTimestamp = n.calcOffsetStartTimestamp(), n.setTimeDeltaState(n.state.timeDelta, 'PAUSED', n.props.onPause)); }, n.stop = function () { n.isStopped() || (n.clearTimer(), n.offsetStartTimestamp = n.calcOffsetStartTimestamp(), n.offsetTime = n.offsetStartTimestamp - n.initialTimestamp, n.setTimeDeltaState(n.calcTimeDelta(), 'STOPPED', n.props.onStop)); }, n.isStarted = function () { return n.isStatus('STARTED'); }, n.isPaused = function () { return n.isStatus('PAUSED'); }, n.isStopped = function () { return n.isStatus('STOPPED'); }, n.isCompleted = function () { return n.isStatus('COMPLETED'); }, e.date) { const a = n.calcTimeDelta(); n.state = { timeDelta: a, status: a.completed ? 'COMPLETED' : 'STOPPED' }; } else n.legacyMode = !0; return n; } return xf(r, [{ key: 'componentDidMount', value() { this.legacyMode || (this.mounted = !0, this.props.onMount && this.props.onMount(this.calcTimeDelta()), this.props.autoStart && this.start()); } }, { key: 'componentDidUpdate', value(e) { this.legacyMode || this.props.date !== e.date && (this.initialTimestamp = this.calcOffsetStartTimestamp(), this.offsetStartTimestamp = this.initialTimestamp, this.offsetTime = 0, this.setTimeDeltaState(this.calcTimeDelta())); } }, { key: 'componentWillUnmount', value() { this.legacyMode || (this.mounted = !1, this.clearTimer()); } }, {
        key: 'calcTimeDelta',
        value() {
          const e = this.props; const t = e.date; const r = e.now; const n = e.precision; const i = e.controlled; const a = e.overtime; return (function (e) {
            let t; const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = r.now; const i = void 0 === n ? Date.now : n; const a = r.precision; const o = void 0 === a ? 0 : a; const s = r.controlled; const u = r.offsetTime; const l = void 0 === u ? 0 : u; const c = r.overtime; t = typeof e === 'string' ? new Date(e).getTime() : e instanceof Date ? e.getTime() : e, s || (t += l); const h = s ? t : t - i(); const f = Math.min(20, Math.max(0, o)); const d = Math.round(1e3 * parseFloat(((c ? h : Math.max(0, h)) / 1e3).toFixed(f))); const p = Math.abs(d) / 1e3; return {
              total: d, days: Math.floor(p / 86400), hours: Math.floor(p / 3600 % 24), minutes: Math.floor(p / 60 % 60), seconds: Math.floor(p % 60), milliseconds: Number((p % 1 * 1e3).toFixed()), completed: d <= 0,
            };
          }(t, {
            now: r, precision: n, controlled: i, offsetTime: this.offsetTime, overtime: a,
          }));
        },
      }, { key: 'calcOffsetStartTimestamp', value() { return Date.now(); } }, { key: 'addTime', value(e) { this.legacyCountdownRef.current.addTime(e); } }, { key: 'clearTimer', value() { window.clearInterval(this.interval); } }, { key: 'isStatus', value(e) { return this.state.status === e; } }, { key: 'setTimeDeltaState', value(e, t, r) { const n = this; if (this.mounted) { const i = e.completed && !this.state.timeDelta.completed; const a = e.completed && t === 'STARTED'; i && !this.props.overtime && this.clearTimer(); return this.setState(((r) => { let i = t || r.status; return e.completed && !n.props.overtime ? i = 'COMPLETED' : t || i !== 'COMPLETED' || (i = 'STOPPED'), { timeDelta: e, status: i }; }), (() => { r && r(n.state.timeDelta), n.props.onComplete && (i || a) && n.props.onComplete(e, a); })); } } }, {
        key: 'getApi',
        value() {
          return this.api = this.api || {
            start: this.start, pause: this.pause, stop: this.stop, isStarted: this.isStarted, isPaused: this.isPaused, isStopped: this.isStopped, isCompleted: this.isCompleted,
          };
        },
      }, {
        key: 'getRenderProps',
        value() {
          const e = this.props; const t = e.daysInHours; const r = e.zeroPadTime; const n = e.zeroPadDays; const i = this.state.timeDelta; return {
            ...i, api: this.getApi(), props: this.props, formatted: If(i, { daysInHours: t, zeroPadTime: r, zeroPadDays: n }),
          };
        }
      }, { key: 'render', value() { if (this.legacyMode) { const e = this.props; const t = e.count; const r = e.children; const n = e.onComplete; return (0, i.createElement)(Of, { ref: this.legacyCountdownRef, count: t, onComplete: n }, r); } const a = this.props; const o = a.className; const s = a.overtime; const u = a.children; const l = a.renderer; const c = this.getRenderProps(); if (l) return l(c); if (u && this.state.timeDelta.completed && !s) return (0, i.cloneElement)(u, { countdown: c }); const h = c.formatted; const f = h.days; const d = h.hours; const p = h.minutes; const m = h.seconds; return (0, i.createElement)('span', { className: o }, c.total < 0 ? '-' : '', f, f ? ':' : '', d, ':', p, ':', m); } }]), r;
    }(i.Component)); Df.defaultProps = {
      ...Rf, controlled: !1, intervalDelay: 1e3, precision: 0, autoStart: !0,
    }, Df.propTypes = {
      date: (0, bf.oneOfType)([(0, bf.instanceOf)(Date), bf.string, bf.number]), daysInHours: bf.bool, zeroPadTime: bf.number, zeroPadDays: bf.number, controlled: bf.bool, intervalDelay: bf.number, precision: bf.number, autoStart: bf.bool, overtime: bf.bool, className: bf.string, children: bf.element, renderer: bf.func, now: bf.func, onMount: bf.func, onStart: bf.func, onPause: bf.func, onStop: bf.func, onTick: bf.func, onComplete: bf.func,
    }; let zf; let Nf; const Lf = Df; const jf = Mc(); const Ff = Object.defineProperty; const Bf = Object.getOwnPropertySymbols; const Uf = Object.prototype.hasOwnProperty; const Vf = Object.prototype.propertyIsEnumerable; const Yf = function (e, t, r) {
      return t in e ? Ff(e, t, {
        enumerable: !0, configurable: !0, writable: !0, value: r,
      }) : e[t] = r;
    }; const Hf = function (e, t) { for (var r in t || (t = {}))Uf.call(t, r) && Yf(e, r, t[r]); if (Bf) { let n; const i = N(Bf(t)); try { for (i.s(); !(n = i.n()).done;) { r = n.value; Vf.call(t, r) && Yf(e, r, t[r]); } } catch (Rv) { i.e(Rv); } finally { i.f(); } } return e; }; const qf = function (e, t) { const r = {}; for (var n in e)Uf.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]); if (e != null && Bf) { let i; const a = N(Bf(e)); try { for (a.s(); !(i = a.n()).done;) { n = i.value; t.indexOf(n) < 0 && Vf.call(e, n) && (r[n] = e[n]); } } catch (Rv) { a.e(Rv); } finally { a.f(); } } return r; }; !(function (e) { const t = (function () { function t(e, r, n, i) { if ((0, w.Z)(this, t), this.version = e, this.errorCorrectionLevel = r, this.modules = [], this.isFunction = [], e < t.MIN_VERSION || e > t.MAX_VERSION) throw new RangeError('Version value out of range'); if (i < -1 || i > 7) throw new RangeError('Mask value out of range'); this.size = 4 * e + 17; for (var o = [], s = 0; s < this.size; s++)o.push(!1); for (let u = 0; u < this.size; u++) this.modules.push(o.slice()), this.isFunction.push(o.slice()); this.drawFunctionPatterns(); const l = this.addEccAndInterleave(n); if (this.drawCodewords(l), i == -1) for (let c = 1e9, h = 0; h < 8; h++) { this.applyMask(h), this.drawFormatBits(h); const f = this.getPenaltyScore(); f < c && (i = h, c = f), this.applyMask(h); }a(i >= 0 && i <= 7), this.mask = i, this.applyMask(i), this.drawFormatBits(i), this.isFunction = []; } return (0, b.Z)(t, [{ key: 'getModule', value(e, t) { return e >= 0 && e < this.size && t >= 0 && t < this.size && this.modules[t][e]; } }, { key: 'getModules', value() { return this.modules; } }, { key: 'drawFunctionPatterns', value() { for (let e = 0; e < this.size; e++) this.setFunctionModule(6, e, e % 2 == 0), this.setFunctionModule(e, 6, e % 2 == 0); this.drawFinderPattern(3, 3), this.drawFinderPattern(this.size - 4, 3), this.drawFinderPattern(3, this.size - 4); for (let t = this.getAlignmentPatternPositions(), r = t.length, n = 0; n < r; n++) for (let i = 0; i < r; i++)n == 0 && i == 0 || n == 0 && i == r - 1 || n == r - 1 && i == 0 || this.drawAlignmentPattern(t[n], t[i]); this.drawFormatBits(0), this.drawVersion(); } }, { key: 'drawFormatBits', value(e) { for (var t = this.errorCorrectionLevel.formatBits << 3 | e, r = t, n = 0; n < 10; n++)r = r << 1 ^ 1335 * (r >>> 9); const o = 21522 ^ (t << 10 | r); a(o >>> 15 == 0); for (let s = 0; s <= 5; s++) this.setFunctionModule(8, s, i(o, s)); this.setFunctionModule(8, 7, i(o, 6)), this.setFunctionModule(8, 8, i(o, 7)), this.setFunctionModule(7, 8, i(o, 8)); for (let u = 9; u < 15; u++) this.setFunctionModule(14 - u, 8, i(o, u)); for (let l = 0; l < 8; l++) this.setFunctionModule(this.size - 1 - l, 8, i(o, l)); for (let c = 8; c < 15; c++) this.setFunctionModule(8, this.size - 15 + c, i(o, c)); this.setFunctionModule(8, this.size - 8, !0); } }, { key: 'drawVersion', value() { if (!(this.version < 7)) { for (var e = this.version, t = 0; t < 12; t++)e = e << 1 ^ 7973 * (e >>> 11); const r = this.version << 12 | e; a(r >>> 18 == 0); for (let n = 0; n < 18; n++) { const o = i(r, n); const s = this.size - 11 + n % 3; const u = Math.floor(n / 3); this.setFunctionModule(s, u, o), this.setFunctionModule(u, s, o); } } } }, { key: 'drawFinderPattern', value(e, t) { for (let r = -4; r <= 4; r++) for (let n = -4; n <= 4; n++) { const i = Math.max(Math.abs(n), Math.abs(r)); const a = e + n; const o = t + r; a >= 0 && a < this.size && o >= 0 && o < this.size && this.setFunctionModule(a, o, i != 2 && i != 4); } } }, { key: 'drawAlignmentPattern', value(e, t) { for (let r = -2; r <= 2; r++) for (let n = -2; n <= 2; n++) this.setFunctionModule(e + n, t + r, Math.max(Math.abs(n), Math.abs(r)) != 1); } }, { key: 'setFunctionModule', value(e, t, r) { this.modules[t][e] = r, this.isFunction[t][e] = !0; } }, { key: 'addEccAndInterleave', value(e) { const r = this.version; const n = this.errorCorrectionLevel; if (e.length != t.getNumDataCodewords(r, n)) throw new RangeError('Invalid argument'); for (var i = t.NUM_ERROR_CORRECTION_BLOCKS[n.ordinal][r], o = t.ECC_CODEWORDS_PER_BLOCK[n.ordinal][r], s = Math.floor(t.getNumRawDataModules(r) / 8), u = i - s % i, l = Math.floor(s / i), c = [], h = t.reedSolomonComputeDivisor(o), f = 0, d = 0; f < i; f++) { const p = e.slice(d, d + l - o + (f < u ? 0 : 1)); d += p.length; const m = t.reedSolomonComputeRemainder(p, h); f < u && p.push(0), c.push(p.concat(m)); } for (var v = [], g = function (e) { c.forEach(((t, r) => { (e != l - o || r >= u) && v.push(t[e]); })); }, y = 0; y < c[0].length; y++)g(y); return a(v.length == s), v; } }, { key: 'drawCodewords', value(e) { if (e.length != Math.floor(t.getNumRawDataModules(this.version) / 8)) throw new RangeError('Invalid argument'); for (var r = 0, n = this.size - 1; n >= 1; n -= 2) { n == 6 && (n = 5); for (let o = 0; o < this.size; o++) for (let s = 0; s < 2; s++) { const u = n - s; const l = (n + 1 & 2) == 0 ? this.size - 1 - o : o; !this.isFunction[l][u] && r < 8 * e.length && (this.modules[l][u] = i(e[r >>> 3], 7 - (7 & r)), r++); } }a(r == 8 * e.length); } }, { key: 'applyMask', value(e) { if (e < 0 || e > 7) throw new RangeError('Mask value out of range'); for (let t = 0; t < this.size; t++) for (let r = 0; r < this.size; r++) { let n = void 0; switch (e) { case 0: n = (r + t) % 2 == 0; break; case 1: n = t % 2 == 0; break; case 2: n = r % 3 == 0; break; case 3: n = (r + t) % 3 == 0; break; case 4: n = (Math.floor(r / 3) + Math.floor(t / 2)) % 2 == 0; break; case 5: n = r * t % 2 + r * t % 3 == 0; break; case 6: n = (r * t % 2 + r * t % 3) % 2 == 0; break; case 7: n = ((r + t) % 2 + r * t % 3) % 2 == 0; break; default: throw new Error('Unreachable'); }!this.isFunction[t][r] && n && (this.modules[t][r] = !this.modules[t][r]); } } }, { key: 'getPenaltyScore', value() { for (var e = 0, r = 0; r < this.size; r++) { for (var n = !1, i = 0, o = [0, 0, 0, 0, 0, 0, 0], s = 0; s < this.size; s++) this.modules[r][s] == n ? ++i == 5 ? e += t.PENALTY_N1 : i > 5 && e++ : (this.finderPenaltyAddHistory(i, o), n || (e += this.finderPenaltyCountPatterns(o) * t.PENALTY_N3), n = this.modules[r][s], i = 1); e += this.finderPenaltyTerminateAndCount(n, i, o) * t.PENALTY_N3; } for (let u = 0; u < this.size; u++) { for (var l = !1, c = 0, h = [0, 0, 0, 0, 0, 0, 0], f = 0; f < this.size; f++) this.modules[f][u] == l ? ++c == 5 ? e += t.PENALTY_N1 : c > 5 && e++ : (this.finderPenaltyAddHistory(c, h), l || (e += this.finderPenaltyCountPatterns(h) * t.PENALTY_N3), l = this.modules[f][u], c = 1); e += this.finderPenaltyTerminateAndCount(l, c, h) * t.PENALTY_N3; } for (let d = 0; d < this.size - 1; d++) for (let p = 0; p < this.size - 1; p++) { const m = this.modules[d][p]; m == this.modules[d][p + 1] && m == this.modules[d + 1][p] && m == this.modules[d + 1][p + 1] && (e += t.PENALTY_N2); } let v; let g = 0; const y = N(this.modules); try { for (y.s(); !(v = y.n()).done;) { g = v.value.reduce(((e, t) => e + (t ? 1 : 0)), g); } } catch (Rv) { y.e(Rv); } finally { y.f(); } const b = this.size * this.size; const w = Math.ceil(Math.abs(20 * g - 10 * b) / b) - 1; return a(w >= 0 && w <= 9), a((e += w * t.PENALTY_N4) >= 0 && e <= 2568888), e; } }, { key: 'getAlignmentPatternPositions', value() { if (this.version == 1) return []; for (var e = Math.floor(this.version / 7) + 2, t = this.version == 32 ? 26 : 2 * Math.ceil((4 * this.version + 4) / (2 * e - 2)), r = [6], n = this.size - 7; r.length < e; n -= t)r.splice(1, 0, n); return r; } }, { key: 'finderPenaltyCountPatterns', value(e) { const t = e[1]; a(t <= 3 * this.size); const r = t > 0 && e[2] == t && e[3] == 3 * t && e[4] == t && e[5] == t; return (r && e[0] >= 4 * t && e[6] >= t ? 1 : 0) + (r && e[6] >= 4 * t && e[0] >= t ? 1 : 0); } }, { key: 'finderPenaltyTerminateAndCount', value(e, t, r) { return e && (this.finderPenaltyAddHistory(t, r), t = 0), t += this.size, this.finderPenaltyAddHistory(t, r), this.finderPenaltyCountPatterns(r); } }, { key: 'finderPenaltyAddHistory', value(e, t) { t[0] == 0 && (e += this.size), t.pop(), t.unshift(e); } }], [{ key: 'encodeText', value(r, n) { const i = e.QrSegment.makeSegments(r); return t.encodeSegments(i, n); } }, { key: 'encodeBinary', value(r, n) { const i = e.QrSegment.makeBytes(r); return t.encodeSegments([i], n); } }, { key: 'encodeSegments', value(e, r) { let i; let o; const u = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1; const l = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 40; const c = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : -1; const h = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5]; if (!(t.MIN_VERSION <= u && u <= l && l <= t.MAX_VERSION) || c < -1 || c > 7) throw new RangeError('Invalid value'); for (i = u; ;i++) { const f = 8 * t.getNumDataCodewords(i, r); const d = s.getTotalBits(e, i); if (d <= f) { o = d; break; } if (i >= l) throw new RangeError('Data too long'); } for (let p = 0, m = [t.Ecc.MEDIUM, t.Ecc.QUARTILE, t.Ecc.HIGH]; p < m.length; p++) { const v = m[p]; h && o <= 8 * t.getNumDataCodewords(i, v) && (r = v); } let g; const y = []; const b = N(e); try { for (b.s(); !(g = b.n()).done;) { const w = g.value; n(w.mode.modeBits, 4, y), n(w.numChars, w.mode.numCharCountBits(i), y); var k; const x = N(w.getData()); try { for (x.s(); !(k = x.n()).done;) { const _ = k.value; y.push(_); } } catch (Rv) { x.e(Rv); } finally { x.f(); } } } catch (Rv) { b.e(Rv); } finally { b.f(); }a(y.length == o); const S = 8 * t.getNumDataCodewords(i, r); a(y.length <= S), n(0, Math.min(4, S - y.length), y), n(0, (8 - y.length % 8) % 8, y), a(y.length % 8 == 0); for (let M = 236; y.length < S; M ^= 253)n(M, 8, y); for (var E = []; 8 * E.length < y.length;)E.push(0); return y.forEach(((e, t) => E[t >>> 3] |= e << 7 - (7 & t))), new t(i, r, E, c); } }, { key: 'getNumRawDataModules', value(e) { if (e < t.MIN_VERSION || e > t.MAX_VERSION) throw new RangeError('Version number out of range'); let r = (16 * e + 128) * e + 64; if (e >= 2) { const n = Math.floor(e / 7) + 2; r -= (25 * n - 10) * n - 55, e >= 7 && (r -= 36); } return a(r >= 208 && r <= 29648), r; } }, { key: 'getNumDataCodewords', value(e, r) { return Math.floor(t.getNumRawDataModules(e) / 8) - t.ECC_CODEWORDS_PER_BLOCK[r.ordinal][e] * t.NUM_ERROR_CORRECTION_BLOCKS[r.ordinal][e]; } }, { key: 'reedSolomonComputeDivisor', value(e) { if (e < 1 || e > 255) throw new RangeError('Degree out of range'); for (var r = [], n = 0; n < e - 1; n++)r.push(0); r.push(1); for (let i = 1, a = 0; a < e; a++) { for (let o = 0; o < r.length; o++)r[o] = t.reedSolomonMultiply(r[o], i), o + 1 < r.length && (r[o] ^= r[o + 1]); i = t.reedSolomonMultiply(i, 2); } return r; } }, { key: 'reedSolomonComputeRemainder', value(e, r) { let n; const i = r.map(((e) => 0)); const a = N(e); try { const o = function () { const e = n.value ^ i.shift(); i.push(0), r.forEach(((r, n) => i[n] ^= t.reedSolomonMultiply(r, e))); }; for (a.s(); !(n = a.n()).done;)o(); } catch (Rv) { a.e(Rv); } finally { a.f(); } return i; } }, { key: 'reedSolomonMultiply', value(e, t) { if (e >>> 8 != 0 || t >>> 8 != 0) throw new RangeError('Byte out of range'); for (var r = 0, n = 7; n >= 0; n--)r = r << 1 ^ 285 * (r >>> 7), r ^= (t >>> n & 1) * e; return a(r >>> 8 == 0), r; } }]), t; }()); const r = t; function n(e, t, r) { if (t < 0 || t > 31 || e >>> t != 0) throw new RangeError('Value out of range'); for (let n = t - 1; n >= 0; n--)r.push(e >>> n & 1); } function i(e, t) { return (e >>> t & 1) != 0; } function a(e) { if (!e) throw new Error('Assertion error'); }r.MIN_VERSION = 1, r.MAX_VERSION = 40, r.PENALTY_N1 = 3, r.PENALTY_N2 = 3, r.PENALTY_N3 = 40, r.PENALTY_N4 = 10, r.ECC_CODEWORDS_PER_BLOCK = [[-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]], r.NUM_ERROR_CORRECTION_BLOCKS = [[-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]], e.QrCode = r; const o = (function () { function e(t, r, n) { if ((0, w.Z)(this, e), this.mode = t, this.numChars = r, this.bitData = n, r < 0) throw new RangeError('Invalid argument'); this.bitData = n.slice(); } return (0, b.Z)(e, [{ key: 'getData', value() { return this.bitData.slice(); } }], [{ key: 'makeBytes', value(t) { let r; const i = []; const a = N(t); try { for (a.s(); !(r = a.n()).done;) { n(r.value, 8, i); } } catch (Rv) { a.e(Rv); } finally { a.f(); } return new e(e.Mode.BYTE, t.length, i); } }, { key: 'makeNumeric', value(t) { if (!e.isNumeric(t)) throw new RangeError('String contains non-numeric characters'); for (var r = [], i = 0; i < t.length;) { const a = Math.min(t.length - i, 3); n(parseInt(t.substr(i, a), 10), 3 * a + 1, r), i += a; } return new e(e.Mode.NUMERIC, t.length, r); } }, { key: 'makeAlphanumeric', value(t) { if (!e.isAlphanumeric(t)) throw new RangeError('String contains unencodable characters in alphanumeric mode'); let r; const i = []; for (r = 0; r + 2 <= t.length; r += 2) { let a = 45 * e.ALPHANUMERIC_CHARSET.indexOf(t.charAt(r)); n(a += e.ALPHANUMERIC_CHARSET.indexOf(t.charAt(r + 1)), 11, i); } return r < t.length && n(e.ALPHANUMERIC_CHARSET.indexOf(t.charAt(r)), 6, i), new e(e.Mode.ALPHANUMERIC, t.length, i); } }, { key: 'makeSegments', value(t) { return t == '' ? [] : e.isNumeric(t) ? [e.makeNumeric(t)] : e.isAlphanumeric(t) ? [e.makeAlphanumeric(t)] : [e.makeBytes(e.toUtf8ByteArray(t))]; } }, { key: 'makeEci', value(t) { const r = []; if (t < 0) throw new RangeError('ECI assignment value out of range'); if (t < 128)n(t, 8, r); else if (t < 16384)n(2, 2, r), n(t, 14, r); else { if (!(t < 1e6)) throw new RangeError('ECI assignment value out of range'); n(6, 3, r), n(t, 21, r); } return new e(e.Mode.ECI, 0, r); } }, { key: 'isNumeric', value(t) { return e.NUMERIC_REGEX.test(t); } }, { key: 'isAlphanumeric', value(t) { return e.ALPHANUMERIC_REGEX.test(t); } }, { key: 'getTotalBits', value(e, t) { let r; let n = 0; const i = N(e); try { for (i.s(); !(r = i.n()).done;) { const a = r.value; const o = a.mode.numCharCountBits(t); if (a.numChars >= 1 << o) return 1 / 0; n += 4 + o + a.bitData.length; } } catch (Rv) { i.e(Rv); } finally { i.f(); } return n; } }, { key: 'toUtf8ByteArray', value(e) { e = encodeURI(e); for (var t = [], r = 0; r < e.length; r++)e.charAt(r) != '%' ? t.push(e.charCodeAt(r)) : (t.push(parseInt(e.substr(r + 1, 2), 16)), r += 2); return t; } }]), e; }()); var s = o; s.NUMERIC_REGEX = /^[0-9]*$/, s.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/, s.ALPHANUMERIC_CHARSET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:', e.QrSegment = s; }(zf || (zf = {}))), (function (e) { const t = (0, b.Z)((function e(t, r) { (0, w.Z)(this, e), this.ordinal = t, this.formatBits = r; })); const r = t; r.LOW = new t(0, 1), r.MEDIUM = new t(1, 0), r.QUARTILE = new t(2, 3), r.HIGH = new t(3, 2), e.Ecc = r; }((Nf = zf || (zf = {})).QrCode || (Nf.QrCode = {}))), (function (e) { !(function (e) { const t = (function () { function e(t, r) { (0, w.Z)(this, e), this.modeBits = t, this.numBitsCharCount = r; } return (0, b.Z)(e, [{ key: 'numCharCountBits', value(e) { return this.numBitsCharCount[Math.floor((e + 7) / 17)]; } }]), e; }()); const r = t; r.NUMERIC = new t(1, [10, 12, 14]), r.ALPHANUMERIC = new t(2, [9, 11, 13]), r.BYTE = new t(4, [8, 16, 16]), r.KANJI = new t(8, [8, 10, 12]), r.ECI = new t(7, [0, 0, 0]), e.Mode = r; }(e.QrSegment || (e.QrSegment = {}))); }(zf || (zf = {}))); const Wf = zf; const Xf = {
      L: Wf.QrCode.Ecc.LOW, M: Wf.QrCode.Ecc.MEDIUM, Q: Wf.QrCode.Ecc.QUARTILE, H: Wf.QrCode.Ecc.HIGH,
    }; const Gf = '#FFFFFF'; const $f = '#000000'; const Zf = 4; const Kf = 0.1; function Qf(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; const r = []; return e.forEach(((e, n) => { let i = null; e.forEach(((a, o) => { if (!a && i !== null) return r.push('M'.concat(i + t, ' ').concat(n + t, 'h').concat(o - i, 'v1H').concat(i + t, 'z')), void (i = null); if (o !== e.length - 1)a && i === null && (i = o); else { if (!a) return; i === null ? r.push('M'.concat(o + t, ',').concat(n + t, ' h1v1H').concat(o + t, 'z')) : r.push('M'.concat(i + t, ',').concat(n + t, ' h').concat(o + 1 - i, 'v1H').concat(i + t, 'z')); } })); })), r.join(''); } function Jf(e, t) { return e.slice().map(((e, r) => (r < t.y || r >= t.y + t.h ? e : e.map(((e, r) => (r < t.x || r >= t.x + t.w) && e))))); } function ed(e, t, r, n) {
      if (n == null) return null; const i = r ? Zf : 0; const a = e.length + 2 * i; const o = Math.floor(t * Kf); const s = a / t; const u = (n.width || o) * s; const l = (n.height || o) * s; const c = n.x == null ? e.length / 2 - u / 2 : n.x * s; const h = n.y == null ? e.length / 2 - l / 2 : n.y * s; let f = null; if (n.excavate) {
        const d = Math.floor(c); const p = Math.floor(h); f = {
          x: d, y: p, w: Math.ceil(u + c - d), h: Math.ceil(l + h - p),
        };
      } return {
        x: c, y: h, h: l, w: u, excavation: f,
      };
    }!(function () { try { (new Path2D()).addPath(new Path2D()); } catch (e) { return !1; } }()); function td(e) {
      const t = e; const r = t.value; const n = t.size; const a = void 0 === n ? 128 : n; const o = t.level; const s = void 0 === o ? 'L' : o; const u = t.bgColor; const l = void 0 === u ? Gf : u; const c = t.fgColor; const h = void 0 === c ? $f : c; const f = t.includeMargin; const d = void 0 !== f && f; const p = t.imageSettings; const m = qf(t, ['value', 'size', 'level', 'bgColor', 'fgColor', 'includeMargin', 'imageSettings']); let v = Wf.QrCode.encodeText(r, Xf[s]).getModules(); const g = d ? Zf : 0; const y = v.length + 2 * g; const b = ed(v, a, d, p); let w = null; p != null && b != null && (b.excavation != null && (v = Jf(v, b.excavation)), w = i.createElement('image', {
        xlinkHref: p.src, height: b.h, width: b.w, x: b.x + g, y: b.y + g, preserveAspectRatio: 'none',
      })); const k = Qf(v, g); return i.createElement('svg', Hf({ height: a, width: a, viewBox: '0 0 '.concat(y, ' ').concat(y) }, m), i.createElement('path', { fill: l, d: 'M0,0 h'.concat(y, 'v').concat(y, 'H0z'), shapeRendering: 'crispEdges' }), i.createElement('path', { fill: h, d: k, shapeRendering: 'crispEdges' }), w);
    } let rd; let nd; let id; let ad; const od = Kl.div(rd || (rd = p(['\n  width: 90%;\n  height: 60%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  border: #2979FF 2px solid;\n']))); const sd = Kl(td)(nd || (nd = p(['\n  width: 75%;\n  max-width: 300px;\n  height: auto;\n  box-sizing: border-box;\n']))); const ud = Kl.h1(id || (id = p(['\n  font-size: min(5vmin, 30px);\n  text-align: center;\n  font-weight: bold;\n']))); const ld = Kl.div(ad || (ad = p(['\n  font-size: min(4vmin, 25px);\n']))); const cd = jf(Qh)({ color: '#2979FF', fontSize: 'min(4vmin, 25px)' }); const hd = function (e) { const t = e.token; const r = e.expirationDate; const n = e.onRenew; return (0, Mo.jsxs)(od, { children: [(0, Mo.jsx)(ud, { children: 'Your access code is ready' }), (0, Mo.jsx)(sd, { value: t, bgColor: '#00000000' }), (0, Mo.jsxs)(ld, { children: ['The token will expire in ', (0, Mo.jsx)(Lf, { renderer(e) { const t = e.minutes; const r = e.seconds; return ''.concat(t, ':').concat(Tf(r)); }, date: 1e3 * r })] }), (0, Mo.jsx)(cd, { onClick: n, children: 'Renew' })] }); }; function fd(e) { return rh('MuiTypography', e); }nh('MuiTypography', ['root', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'subtitle1', 'subtitle2', 'body1', 'body2', 'inherit', 'button', 'caption', 'overline', 'alignLeft', 'alignRight', 'alignCenter', 'alignJustify', 'noWrap', 'gutterBottom', 'paragraph']); let dd; let pd; let md; let vd; let gd; let yd; let bd; const wd = ['align', 'className', 'component', 'gutterBottom', 'noWrap', 'paragraph', 'variant', 'variantMapping']; const kd = Pc('span', { name: 'MuiTypography', slot: 'Root', overridesResolver(e, t) { const r = e.ownerState; return [t.root, r.variant && t[r.variant], r.align !== 'inherit' && t['align'.concat(Ph(r.align))], r.noWrap && t.noWrap, r.gutterBottom && t.gutterBottom, r.paragraph && t.paragraph]; } })(((e) => { const t = e.theme; const r = e.ownerState; return Tn({ margin: 0 }, r.variant === 'inherit' && { font: 'inherit' }, r.variant !== 'inherit' && t.typography[r.variant], r.align !== 'inherit' && { textAlign: r.align }, r.noWrap && { overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }, r.gutterBottom && { marginBottom: '0.35em' }, r.paragraph && { marginBottom: 16 }); })); const xd = {
      h1: 'h1', h2: 'h2', h3: 'h3', h4: 'h4', h5: 'h5', h6: 'h6', subtitle1: 'h6', subtitle2: 'h6', body1: 'p', body2: 'p', inherit: 'p',
    }; const _d = {
      primary: 'primary.main', textPrimary: 'text.primary', secondary: 'secondary.main', textSecondary: 'text.secondary', error: 'error.main',
    }; const Sd = i.forwardRef(((e, t) => {
      const r = Rc({ props: e, name: 'MuiTypography' }); const n = (function (e) { return _d[e] || e; }(r.color)); const i = vo(Tn({}, r, { color: n })); const a = i.align; const o = void 0 === a ? 'inherit' : a; const s = i.className; const u = i.component; const l = i.gutterBottom; const c = void 0 !== l && l; const h = i.noWrap; const f = void 0 !== h && h; const d = i.paragraph; const p = void 0 !== d && d; const v = i.variant; const g = void 0 === v ? 'body1' : v; const y = i.variantMapping; const b = void 0 === y ? xd : y; const w = m(i, wd); const k = Tn({}, i, {
        align: o, color: n, className: s, component: u, gutterBottom: c, noWrap: f, paragraph: p, variant: g, variantMapping: b,
      }); const x = u || (p ? 'p' : b[g] || xd[g]) || 'span'; const _ = (function (e) { const t = e.align; const r = e.gutterBottom; const n = e.noWrap; const i = e.paragraph; const a = e.variant; const o = e.classes; return pc({ root: ['root', a, e.align !== 'inherit' && 'align'.concat(Ph(t)), r && 'gutterBottom', n && 'noWrap', i && 'paragraph'] }, fd, o); }(k)); return (0, Mo.jsx)(kd, Tn({
        as: x, ref: t, ownerState: k, className: In(_.root, s),
      }, w));
    })); const Md = Sd; const Ed = function (e) { const t = e.text; const r = e.delay; const n = d((0, i.useState)(''), 2); const a = n[0]; const o = n[1]; const s = d((0, i.useState)(0), 2); const u = s[0]; const l = s[1]; return (0, i.useEffect)((() => { if (u < t.length) { const e = setTimeout((() => { o(((e) => e + t[u])), l(((e) => e + 1)); }), r); return function () { return clearTimeout(e); }; } }), [u, r, t]), a; }; const Cd = ['caption', 'Icon', 'selectedTab', 'onClick', 'id', 'parentWidth']; const Pd = Kl(Pn.div)(dd || (dd = p(['\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n']))); const Ad = function (e) {
      const t = e.caption; const r = e.Icon; const n = e.selectedTab; const a = e.onClick; const o = e.id; const s = e.parentWidth; const u = v(e, Cd); const l = d((0, i.useState)(0), 2); const c = l[0]; const h = l[1]; const f = n === o ? 'selected-tab' : 'not-selected-tab'; const p = (0, Fh.useMediaQuery)({ query: '(min-width: 750px)' }); const m = (0, Fh.useMediaQuery)({ query: '(max-height: 525px) and (min-width: 600px)' }); const g = (0, Fh.useMediaQuery)({ query: '(max-width: 318px)' }) ? 30 : 47; const y = function () { h(1), a(); }; const b = nn({ width: ''.concat(n === o ? s - g : g, 'px'), config: { mass: 0.5, friction: 26, tension: 100 } }); const w = nn({ transform: ['rotate(0deg)', 'rotate(-10deg)', 'rotate(10deg)'][c], config: { mass: 0.5, friction: 13, tension: 100 }, onRest() { switch (c) { case 1: h(2); break; case 2: h(0); } } }); return p || m ? (0, Mo.jsxs)(Qh, {
        onClick: y,
        sx: {
          padding: '0 0', minWidth: '47px', width: '100%', height: '100%', lineHeight: 'normal',
        },
        children: [(0, Mo.jsx)(Pd, { style: z({}, w), children: (0, Mo.jsx)(r, z(z({}, u), {}, { className: ''.concat(f, ' tab-icon') })) }), (0, Mo.jsx)(Md, z(z({
          sx: {
            fontSize: 'max(min(7vmin, 45px), 22px)', lineHeight: 'normal', fontFamily: 'Metropolis', fontWeight: 'normal',
          },
        }, u), {}, { className: ''.concat(f), children: t }))],
      }) : (0, Mo.jsx)(Pn.div, {
        style: z({}, b),
        children: (0, Mo.jsxs)(Qh, {
          onClick: y,
          sx: {
            padding: '0 0', minWidth: ''.concat(g, 'px'), width: '100%', height: '100%', lineHeight: 'normal',
          },
          children: [(0, Mo.jsx)(Pd, { style: z({}, w), children: (0, Mo.jsx)(r, z(z({}, u), {}, { className: ''.concat(f, ' tab-icon') })) }), n === o ? (0, Mo.jsx)(Md, z(z({
            sx: {
              fontSize: 'max(min(7vmin, 45px), 22px)', lineHeight: 'normal', fontFamily: 'Metropolis', fontWeight: 'normal',
            },
          }, u), {}, { className: ''.concat(f), children: (0, Mo.jsx)(Ed, { text: t, delay: 50 }) })) : null],
        }),
      });
    }; const Td = Kl.div(pd || (pd = p(['\n    height: min(10vmin, 71px);\n    min-height: 48px;\n    width: 100vw;\n    background-color: #FFFFFF;\n    display: flex;\n    flex-direction: row;\n    justify-content: flex-start;\n    align-items: center;\n    font-weight: bold;\n    box-shadow: 2px 2px 5px gray;\n']))); const Rd = Kl.span(md || (md = p(['\n    height: 100%;\n    font-family: Bavro;\n    color: #2979FF;\n    margin-left: 1%;\n    font-size: max(min(6vmin, 60px), 22px);\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n']))); const Id = function (e) {
      const t = e.selectedTab; const r = e.changeSelectedTab; const n = d((0, i.useState)(null), 2); const a = n[0]; const o = n[1]; const s = new ResizeObserver(((e) => { let t; const r = N(e); try { for (r.s(); !(t = r.n()).done;) { const n = t.value; o(n.contentRect.width); } } catch (Rv) { r.e(Rv); } finally { r.f(); } })); const u = (0, i.useCallback)(((e) => { e !== null ? (o(e.offsetWidth), s.observe(e)) : s.disconnect(); }), [s]); const l = function (e) { return function () { r(e); }; }; return (0, Mo.jsxs)(ms, {
        component: Td,
        children: [(0, Mo.jsx)(Rd, { style: { flex: '0 0 auto', color: '#2979FF', height: '100%' }, children: 'MASKGUARD' }), (0, Mo.jsxs)('div', {
          ref: u,
          className: 'tab-container',
          children: [(0, Mo.jsx)(Ad, {
            parentWidth: a, caption: 'Home', Icon: uc, selectedTab: t, onClick: l(0), id: 0,
          }), (0, Mo.jsx)(Ad, {
            parentWidth: a, caption: 'About', Icon: lc, selectedTab: t, onClick: l(1), id: 1,
          })],
        }), (0, Mo.jsx)('div', {
          style: {
            flex: '0 0 auto', display: 'flex', flexDirection: 'row', justifyContent: 'center', alignItems: 'center', minWidth: '38px',
          },
          children: (0, Mo.jsx)(zh, { children: (0, Mo.jsx)(hc, { size: 'min(7vmin, 55px)', style: { color: '#5494ff', minWidth: '30px', minHeight: '30px' } }) }),
        })],
      });
    }; const Od = Kl.div(vd || (vd = p(['\n    position: relative;\n    @media (min-aspect-ratio: 11/5) {\n      top: calc(-4% - 5px);\n    }\n']))); const Dd = function (e) { const t = An(); let r = {}; return r = (0, Fh.useMediaQuery)({ query: '(min-aspect-ratio: 1/1)' }) ? { height: 0.7 * t.height, width: 0.7 * t.height * 4 / 3 } : { width: 0.9 * t.width, height: 0.9 * t.width * 3 / 4 }, (0, Mo.jsx)(Od, { style: r, children: (0, Mo.jsx)(jh, { isShown: 1 }) }); }; const zd = Kl.div(gd || (gd = p(['\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    width: 100%;\n    height: 100%;\n']))); const Nd = Kl.span(yd || (yd = p(['\n    height: 100%;\n    font-family: Bavro;\n    color: #2979FF;\n    margin-left: 1%;\n    font-size: max(min(6vmin, 60px), 22px);\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n']))); const Ld = Kl(ms)(bd || (bd = p(['\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: space-evenly;\n  position: relative;\n  width: 80%;\n  height: 80%;\n  opacity: ', ";\n  transition: opacity 0.3s ease-in-out;\n  &:before, &:after {\n    content: '';\n    position: absolute;\n    width: ", ';\n    height: ', ';\n    border-radius: ', ';\n    transition: .75s ease-in-out;\n  };\n  &:before {\n    border-top-left-radius: 5px;\n    top: 0;\n    left: 0;\n    border-top: 2px solid rgb(41, 121, 255);\n    border-left: 2px solid rgb(41, 121, 255);\n  };\n  &:after {\n    border-bottom-right-radius: 5px;\n    right: 0;\n    bottom: 0;\n    border-right: 2px solid rgb(41, 121, 255);\n    border-bottom: 2px solid rgb(41, 121, 255);\n  };\n'])), ((e) => (e.isStartingAnimation ? '1' : '0')), ((e) => (e.isStartingAnimation ? 'calc(100% - 2px)' : '30px')), ((e) => (e.isStartingAnimation ? 'calc(100% - 2px)' : '30px')), ((e) => (e.isStartingAnimation ? '5px' : '0px'))); const jd = function (e) {
      const t = e.selectedTab; const r = d((0, i.useState)(!1), 2); const n = r[0]; const a = r[1]; const o = an(t === 1, {
        from: { opacity: 0 }, enter: { opacity: 1 }, leave: { opacity: 0 }, config: { mass: 0.5, tension: 180, friction: 21 },
      }); return (0, i.useEffect)((() => { a(t === 1); }), [t]), (0, Mo.jsx)(Mo.Fragment, { children: o(((e, t) => { if (t) return (0, Mo.jsx)(Pn.div, { className: 'stacked-container', style: e, children: (0, Mo.jsx)(zd, { children: (0, Mo.jsxs)(Ld, { isStartingAnimation: n, children: [(0, Mo.jsx)(Nd, { style: { flex: '0 0 auto', color: '#2979FF', height: '25%' }, children: 'MASKGUARD' }), (0, Mo.jsx)(Md, { children: 'Authors:' }), (0, Mo.jsx)('p', { children: 'Jakub Go\u0142\u0105b' }), (0, Mo.jsx)('p', { children: 'J\u0119drzej G\xf3rski' }), (0, Mo.jsx)('p', { children: 'Jan Majchrzak' })] }) }) }); })) });
    }; const Fd = jf(zh)({
      position: 'absolute',
      right: 0,
      height: '100%',
      marginLeft: 'auto',
      backgroundColor: '#FFFFFF',
      '&:before, &:after': {
        content: '""', position: 'absolute', width: '25%', height: '25%', transition: '.45s ease-in-out',
      },
      '&:before': {
        borderTopLeftRadius: '5px', top: '0', left: '0', borderTop: '2px solid rgba(41, 121, 255, 0.45)', borderLeft: '2px solid rgba(41, 121, 255, 0.45)',
      },
      '&:after': {
        borderBottomRightRadius: '5px', right: '0', bottom: '0', borderRight: '2px solid rgba(41, 121, 255, 0.45)', borderBottom: '2px solid rgba(41, 121, 255, 0.45)',
      },
      '&:hover::before, &:hover::after': { width: 'calc(100% - 2px)', height: 'calc(100% - 2px)', borderRadius: '5px' },
    }); const Bd = function (e) {
      const t = e.isShown; const r = e.toggleShownUpdate; const n = d((0, i.useState)(void 0), 2); const a = n[0]; const o = n[1]; const s = new ResizeObserver(((e) => { let t; const r = N(e); try { for (r.s(); !(t = r.n()).done;) { const n = t.value; o(n.contentRect.height); } } catch (Rv) { r.e(Rv); } finally { r.f(); } })); const u = (0, i.useCallback)(((e) => { e !== null ? (o(e.offsetHeight), s.observe(e)) : s.disconnect(); }), [s]); return (0, Mo.jsx)(Fd, {
        ref: u, style: { width: a }, variant: 'contained', onClick() { r(!t); }, children: (0, Mo.jsx)(sc, { size: '80%', color: '#2979FF', style: { position: 'absolute' } }),
      });
    }; const Ud = { data: '' }; const Vd = function (e) { return typeof window === 'object' ? ((e ? e.querySelector('#_goober') : window._goober) || Object.assign((e || document.head).appendChild(document.createElement('style')), { innerHTML: ' ', id: '_goober' })).firstChild : e || Ud; }; const Yd = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g; const Hd = /\/\*[^]*?\*\/|  +/g; const qd = /\n+/g; const Wd = function e(t, r) { let n = ''; let i = ''; let a = ''; const o = function (o) { const s = t[o]; o[0] == '@' ? o[1] == 'i' ? n = `${o} ${s};` : i += o[1] == 'f' ? e(s, o) : `${o}{${e(s, o[1] == 'k' ? '' : r)}}` : typeof s === 'object' ? i += e(s, r ? r.replace(/([^,])+/g, ((e) => o.replace(/(^:.*)|([^,])+/g, ((t) => (/&/.test(t) ? t.replace(/&/g, e) : e ? `${e } ${ t}` : t))))) : o) : s != null && (o = /^--/.test(o) ? o : o.replace(/[A-Z]/g, '-$&').toLowerCase(), a += e.p ? e.p(o, s) : `${o}:${s};`); }; for (const s in t)o(s); return n + (r && a ? `${r}{${a}}` : a) + i; }; const Xd = {}; const Gd = function e(t) { if (typeof t === 'object') { let r = ''; for (const n in t)r += n + e(t[n]); return r; } return t; }; const $d = function (e, t, r, n, i) { const a = Gd(e); const o = Xd[a] || (Xd[a] = (function (e) { for (var t = 0, r = 11; t < e.length;)r = 101 * r + e.charCodeAt(t++) >>> 0; return `go${r}`; }(a))); if (!Xd[o]) { const s = a !== e ? e : (function (e) { for (var t, r, n = [{}]; t = Yd.exec(e.replace(Hd, ''));)t[4] ? n.shift() : t[3] ? (r = t[3].replace(qd, ' ').trim(), n.unshift(n[0][r] = n[0][r] || {})) : n[0][t[1]] = t[2].replace(qd, ' ').trim(); return n[0]; }(e)); Xd[o] = Wd(i ? O({}, `@keyframes ${o}`, s) : s, r ? '' : `.${o}`); } const u = r && Xd.g ? Xd.g : null; return r && (Xd.g = Xd[o]), (function (e, t, r, n) { n ? t.data = t.data.replace(n, e) : t.data.indexOf(e) === -1 && (t.data = r ? e + t.data : t.data + e); }(Xd[o], t, n, u)), o; }; const Zd = function (e, t, r) { return e.reduce(((e, n, i) => { let a = t[i]; if (a && a.call) { const o = a(r); const s = o && o.props && o.props.className || /^go/.test(o) && o; a = s ? `.${s}` : o && typeof o === 'object' ? o.props ? '' : Wd(o, '') : !1 === o ? '' : o; } return e + n + (a == null ? '' : a); }), ''); }; function Kd(e) { const t = this || {}; const r = e.call ? e(t.p) : e; return $d(r.unshift ? r.raw ? Zd(r, [].slice.call(arguments, 1), t.p) : r.reduce(((e, r) => Object.assign(e, r && r.call ? r(t.p) : r)), {}) : r, Vd(t.target), t.g, t.o, t.k); }Kd.bind({ g: 1 }); let Qd; let Jd; let ep; let tp; let rp; let np; let ip; let ap; let op; let sp; let up; let lp; let cp; let hp; let fp; let dp; let pp; let mp; let vp; const gp = Kd.bind({ k: 1 }); function yp(e, t) { const r = this || {}; return function () { const n = arguments; function i(a, o) { const s = { ...a }; const u = s.className || i.className; r.p = { theme: Jd && Jd(), ...s }, r.o = / *go\d+/.test(u), s.className = Kd.apply(r, n) + (u ? ` ${u}` : ''), t && (s.ref = o); let l = e; return e[0] && (l = s.as || e, delete s.as), ep && l[0] && ep(s), Qd(l, s); } return t ? t(i) : i; }; } const bp = function (e, t) { return (function (e) { return typeof e === 'function'; }(e)) ? e(t) : e; }; const wp = (function () { let e = 0; return function () { return (++e).toString(); }; }()); const kp = (function () { let e; return function () { if (void 0 === e && typeof window < 'u') { const t = matchMedia('(prefers-reduced-motion: reduce)'); e = !t || t.matches; } return e; }; }()); const xp = new Map(); const _p = function (e) { if (!xp.has(e)) { const t = setTimeout((() => { xp.delete(e), Cp({ type: 4, toastId: e }); }), 1e3); xp.set(e, t); } }; const Sp = function e(t, r) { switch (r.type) { case 0: return z(z({}, t), {}, { toasts: [r.toast].concat(P(t.toasts)).slice(0, 20) }); case 1: return r.toast.id && (function (e) { const t = xp.get(e); t && clearTimeout(t); }(r.toast.id)), z(z({}, t), {}, { toasts: t.toasts.map(((e) => (e.id === r.toast.id ? z(z({}, e), r.toast) : e))) }); case 2: var n = r.toast; return t.toasts.find(((e) => e.id === n.id)) ? e(t, { type: 1, toast: n }) : e(t, { type: 0, toast: n }); case 3: var i = r.toastId; return i ? _p(i) : t.toasts.forEach(((e) => { _p(e.id); })), z(z({}, t), {}, { toasts: t.toasts.map(((e) => (e.id === i || void 0 === i ? z(z({}, e), {}, { visible: !1 }) : e))) }); case 4: return void 0 === r.toastId ? z(z({}, t), {}, { toasts: [] }) : z(z({}, t), {}, { toasts: t.toasts.filter(((e) => e.id !== r.toastId)) }); case 5: return z(z({}, t), {}, { pausedAt: r.time }); case 6: var a = r.time - (t.pausedAt || 0); return z(z({}, t), {}, { pausedAt: void 0, toasts: t.toasts.map(((e) => z(z({}, e), {}, { pauseDuration: e.pauseDuration + a }))) }); } }; const Mp = []; let Ep = { toasts: [], pausedAt: void 0 }; var Cp = function (e) { Ep = Sp(Ep, e), Mp.forEach(((e) => { e(Ep); })); }; const Pp = {
      blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3,
    }; const Ap = function (e) {
      return function (t, r) {
        const n = (function (e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'blank'; const r = arguments.length > 2 ? arguments[2] : void 0; return z(z({
            createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: 'status', 'aria-live': 'polite' }, message: e, pauseDuration: 0,
          }, r), {}, { id: (r == null ? void 0 : r.id) || wp() });
        }(t, e, r)); return Cp({ type: 2, toast: n }), n.id;
      };
    }; const Tp = function (e, t) { return Ap('blank')(e, t); }; Tp.error = Ap('error'), Tp.success = Ap('success'), Tp.loading = Ap('loading'), Tp.custom = Ap('custom'), Tp.dismiss = function (e) { Cp({ type: 3, toastId: e }); }, Tp.remove = function (e) { return Cp({ type: 4, toastId: e }); }, Tp.promise = function (e, t, r) { const n = Tp.loading(t.loading, z(z({}, r), r == null ? void 0 : r.loading)); return e.then(((e) => (Tp.success(bp(t.success, e), z(z({ id: n }, r), r == null ? void 0 : r.success)), e))).catch(((e) => { Tp.error(bp(t.error, e), z(z({ id: n }, r), r == null ? void 0 : r.error)); })), e; }; const Rp = function (e, t) { Cp({ type: 1, toast: { id: e, height: t } }); }; const Ip = function () { Cp({ type: 5, time: Date.now() }); }; const Op = function (e) {
      const t = (function () { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = d((0, i.useState)(Ep), 2); const r = t[0]; const n = t[1]; (0, i.useEffect)((() => (Mp.push(n), function () { const e = Mp.indexOf(n); e > -1 && Mp.splice(e, 1); })), [r]); const a = r.toasts.map(((t) => { let r; let n; return z(z(z(z({}, e), e[t.type]), t), {}, { duration: t.duration || ((r = e[t.type]) == null ? void 0 : r.duration) || (e == null ? void 0 : e.duration) || Pp[t.type], style: z(z(z({}, e.style), (n = e[t.type]) == null ? void 0 : n.style), t.style) }); })); return z(z({}, r), {}, { toasts: a }); }(e)); const r = t.toasts; const n = t.pausedAt; (0, i.useEffect)((() => { if (!n) { const e = Date.now(); const t = r.map(((t) => { if (t.duration !== 1 / 0) { const r = (t.duration || 0) + t.pauseDuration - (e - t.createdAt); if (!(r < 0)) return setTimeout((() => Tp.dismiss(t.id)), r); t.visible && Tp.dismiss(t.id); } })); return function () { t.forEach(((e) => e && clearTimeout(e))); }; } }), [r, n]); const a = (0, i.useCallback)((() => { n && Cp({ type: 6, time: Date.now() }); }), [n]); const o = (0, i.useCallback)(((e, t) => { let n; const i = t || {}; const a = i.reverseOrder; const o = void 0 !== a && a; const s = i.gutter; const u = void 0 === s ? 8 : s; const l = i.defaultPosition; const c = r.filter(((t) => (t.position || l) === (e.position || l) && t.height)); const h = c.findIndex(((t) => t.id === e.id)); const f = c.filter(((e, t) => t < h && e.visible)).length; return (n = c.filter(((e) => e.visible))).slice.apply(n, P(o ? [f + 1] : [0, f])).reduce(((e, t) => e + (t.height || 0) + u), 0); }), [r]); return {
        toasts: r,
        handlers: {
          updateHeight: Rp, startPause: Ip, endPause: a, calculateOffset: o,
        },
      };
    }; const Dp = gp(tp || (tp = p(['\nfrom {\n  transform: scale(0) rotate(45deg);\n\topacity: 0;\n}\nto {\n transform: scale(1) rotate(45deg);\n  opacity: 1;\n}']))); const zp = gp(rp || (rp = p(['\nfrom {\n  transform: scale(0);\n  opacity: 0;\n}\nto {\n  transform: scale(1);\n  opacity: 1;\n}']))); const Np = gp(np || (np = p(['\nfrom {\n  transform: scale(0) rotate(90deg);\n\topacity: 0;\n}\nto {\n  transform: scale(1) rotate(90deg);\n\topacity: 1;\n}']))); const Lp = yp('div')(ip || (ip = p(['\n  width: 20px;\n  opacity: 0;\n  height: 20px;\n  border-radius: 10px;\n  background: ', ';\n  position: relative;\n  transform: rotate(45deg);\n\n  animation: ', " 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n  animation-delay: 100ms;\n\n  &:after,\n  &:before {\n    content: '';\n    animation: ", ' 0.15s ease-out forwards;\n    animation-delay: 150ms;\n    position: absolute;\n    border-radius: 3px;\n    opacity: 0;\n    background: ', ';\n    bottom: 9px;\n    left: 4px;\n    height: 2px;\n    width: 12px;\n  }\n\n  &:before {\n    animation: ', ' 0.15s ease-out forwards;\n    animation-delay: 180ms;\n    transform: rotate(90deg);\n  }\n'])), ((e) => e.primary || '#ff4b4b'), Dp, zp, ((e) => e.secondary || '#fff'), Np); const jp = gp(ap || (ap = p(['\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n']))); const Fp = yp('div')(op || (op = p(['\n  width: 12px;\n  height: 12px;\n  box-sizing: border-box;\n  border: 2px solid;\n  border-radius: 100%;\n  border-color: ', ';\n  border-right-color: ', ';\n  animation: ', ' 1s linear infinite;\n'])), ((e) => e.secondary || '#e0e0e0'), ((e) => e.primary || '#616161'), jp); const Bp = gp(sp || (sp = p(['\nfrom {\n  transform: scale(0) rotate(45deg);\n\topacity: 0;\n}\nto {\n  transform: scale(1) rotate(45deg);\n\topacity: 1;\n}']))); const Up = gp(up || (up = p(['\n0% {\n\theight: 0;\n\twidth: 0;\n\topacity: 0;\n}\n40% {\n  height: 0;\n\twidth: 6px;\n\topacity: 1;\n}\n100% {\n  opacity: 1;\n  height: 10px;\n}']))); const Vp = yp('div')(lp || (lp = p(['\n  width: 20px;\n  opacity: 0;\n  height: 20px;\n  border-radius: 10px;\n  background: ', ';\n  position: relative;\n  transform: rotate(45deg);\n\n  animation: ', " 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n  animation-delay: 100ms;\n  &:after {\n    content: '';\n    box-sizing: border-box;\n    animation: ", ' 0.2s ease-out forwards;\n    opacity: 0;\n    animation-delay: 200ms;\n    position: absolute;\n    border-right: 2px solid;\n    border-bottom: 2px solid;\n    border-color: ', ';\n    bottom: 6px;\n    left: 6px;\n    height: 10px;\n    width: 6px;\n  }\n'])), ((e) => e.primary || '#61d345'), Bp, Up, ((e) => e.secondary || '#fff')); const Yp = yp('div')(cp || (cp = p(['\n  position: absolute;\n']))); const Hp = yp('div')(hp || (hp = p(['\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-width: 20px;\n  min-height: 20px;\n']))); const qp = gp(fp || (fp = p(['\nfrom {\n  transform: scale(0.6);\n  opacity: 0.4;\n}\nto {\n  transform: scale(1);\n  opacity: 1;\n}']))); const Wp = yp('div')(dp || (dp = p(['\n  position: relative;\n  transform: scale(0.6);\n  opacity: 0.4;\n  min-width: 20px;\n  animation: ', ' 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n'])), qp); const Xp = function (e) { const t = e.toast; const r = t.icon; const n = t.type; const a = t.iconTheme; return void 0 !== r ? typeof r === 'string' ? i.createElement(Wp, null, r) : r : n === 'blank' ? null : i.createElement(Hp, null, i.createElement(Fp, z({}, a)), n !== 'loading' && i.createElement(Yp, null, n === 'error' ? i.createElement(Lp, z({}, a)) : i.createElement(Vp, z({}, a)))); }; const Gp = function (e) { return '\n0% {transform: translate3d(0,'.concat(-200 * e, '%,0) scale(.6); opacity:.5;}\n100% {transform: translate3d(0,0,0) scale(1); opacity:1;}\n'); }; const $p = function (e) { return '\n0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}\n100% {transform: translate3d(0,'.concat(-150 * e, '%,-1px) scale(.6); opacity:0;}\n'); }; const Zp = yp('div')(pp || (pp = p(['\n  display: flex;\n  align-items: center;\n  background: #fff;\n  color: #363636;\n  line-height: 1.3;\n  will-change: transform;\n  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);\n  max-width: 350px;\n  pointer-events: auto;\n  padding: 8px 10px;\n  border-radius: 8px;\n']))); const Kp = yp('div')(mp || (mp = p(['\n  display: flex;\n  justify-content: center;\n  margin: 4px 10px;\n  color: inherit;\n  flex: 1 1 auto;\n  white-space: pre-line;\n']))); const Qp = i.memo(((e) => { const t = e.toast; const r = e.position; const n = e.style; const a = e.children; const o = t.height ? (function (e, t) { const r = e.includes('top') ? 1 : -1; const n = d(kp() ? ['0%{opacity:0;} 100%{opacity:1;}', '0%{opacity:1;} 100%{opacity:0;}'] : [Gp(r), $p(r)], 2); const i = n[0]; const a = n[1]; return { animation: t ? ''.concat(gp(i), ' 0.35s cubic-bezier(.21,1.02,.73,1) forwards') : ''.concat(gp(a), ' 0.4s forwards cubic-bezier(.06,.71,.55,1)') }; }(t.position || r || 'top-center', t.visible)) : { opacity: 0 }; const s = i.createElement(Xp, { toast: t }); const u = i.createElement(Kp, z({}, t.ariaProps), bp(t.message, t)); return i.createElement(Zp, { className: t.className, style: z(z(z({}, o), n), t.style) }, typeof a === 'function' ? a({ icon: s, message: u }) : i.createElement(i.Fragment, null, s, u)); })); !(function (e, t, r, n) { Wd.p = t, Qd = e, Jd = r, ep = n; }(i.createElement)); const Jp = function (e) { const t = e.id; const r = e.className; const n = e.style; const a = e.onHeightUpdate; const o = e.children; const s = i.useCallback(((e) => { if (e) { const r = function () { const r = e.getBoundingClientRect().height; a(t, r); }; r(), new MutationObserver(r).observe(e, { subtree: !0, childList: !0, characterData: !0 }); } }), [t, a]); return i.createElement('div', { ref: s, className: r, style: n }, o); }; const em = Kd(vp || (vp = p(['\n  z-index: 9999;\n  > * {\n    pointer-events: auto;\n  }\n']))); const tm = function (e) {
      const t = e.reverseOrder; const r = e.position; const n = void 0 === r ? 'top-center' : r; const a = e.toastOptions; const o = e.gutter; const s = e.children; const u = e.containerStyle; const l = e.containerClassName; const c = Op(a); const h = c.toasts; const f = c.handlers; return i.createElement('div', {
        style: z({
          position: 'fixed', zIndex: 9999, top: 16, left: 16, right: 16, bottom: 16, pointerEvents: 'none',
        }, u),
        className: l,
        onMouseEnter: f.startPause,
        onMouseLeave: f.endPause,
      }, h.map(((e) => {
        const r = e.position || n; const a = (function (e, t) {
          const r = e.includes('top'); const n = r ? { top: 0 } : { bottom: 0 }; const i = e.includes('center') ? { justifyContent: 'center' } : e.includes('right') ? { justifyContent: 'flex-end' } : {}; return z(z({
            left: 0, right: 0, display: 'flex', position: 'absolute', transition: kp() ? void 0 : 'all 230ms cubic-bezier(.21,1.02,.73,1)', transform: 'translateY('.concat(t * (r ? 1 : -1), 'px)'),
          }, n), i);
        }(r, f.calculateOffset(e, { reverseOrder: t, gutter: o, defaultPosition: n }))); return i.createElement(Jp, {
          id: e.id, key: e.id, onHeightUpdate: f.updateHeight, className: e.visible ? em : '', style: a,
        }, e.type === 'custom' ? bp(e.message, e) : s ? s(e) : i.createElement(Qp, { toast: e, position: r }));
      })));
    }; const rm = {
      getBit(e) { return this.data[nm(e)] & 1 << im(e) ? 1 : 0; }, setBit(e) { this.data[nm(e)] |= 1 << im(e); }, clearBit(e) { this.data[nm(e)] &= ~(1 << im(e)); }, toggleBit(e) { this.data[nm(e)] ^= 1 << im(e); }, getBitXY(e, t) { return e >= this.width || t >= this.height ? 0 : this.getBit(t * this.width + e); }, setBitXY(e, t) { this.setBit(t * this.width + e); }, clearBitXY(e, t) { this.clearBit(t * this.width + e); }, toggleBitXY(e, t) { this.toggleBit(t * this.width + e); },
    }; function nm(e) { return e >> 3; } function im(e) { return 7 - (7 & e); } function am() { am = function (e, t) { return new r(e, void 0, t); }; const e = RegExp.prototype; const t = new WeakMap(); function r(e, n, i) { const a = new RegExp(e, n); return t.set(a, i || t.get(e)), k(a, r.prototype); } function n(e, r) { const n = t.get(r); return Object.keys(n).reduce(((t, r) => { const i = n[r]; if (typeof i === 'number')t[r] = e[i]; else { for (var a = 0; void 0 === e[i[a]] && a + 1 < i.length;)a++; t[r] = e[i[a]]; } return t; }), Object.create(null)); } return x(r, RegExp), r.prototype.exec = function (t) { const r = e.exec.call(this, t); if (r) { r.groups = n(r, this); const i = r.indices; i && (i.groups = n(i, this)); } return r; }, r.prototype[Symbol.replace] = function (r, i) { if (typeof i === 'string') { const a = t.get(this); return e[Symbol.replace].call(this, r, i.replace(/\$<([^>]+)>/g, ((e, t) => { const r = a[t]; return `$${Array.isArray(r) ? r.join('$') : r}`; }))); } if (typeof i === 'function') { const o = this; return e[Symbol.replace].call(this, r, (function () { let e = arguments; return (0, s.Z)(e[e.length - 1]) != 'object' && (e = [].slice.call(e)).push(n(e, o)), i.apply(this, e); })); } return e[Symbol.replace].call(this, r, i); }, am.apply(this, arguments); } function om(e, t) { e = e || [], typeof (t = t || {}) === 'string' && (t = { type: t }); try { return new Blob(e, t); } catch (i) { if (i.name !== 'TypeError') throw i; for (var r = new (typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder)(), n = 0; n < e.length; n += 1)r.append(e[n]); return r.getBlob(t.type); } } function sm(e, t, r) { return typeof e.toBlob === 'function' ? new Promise(((n) => { e.toBlob(n, t, r); })) : Promise.resolve(function (e) { const t = e.match(/data:([^;]+)/)[1]; const r = e.replace(/^[^,]+,/, ''); return om([um(atob(r))], { type: t }); }(e.toDataURL(t, r))); } function um(e) { for (var t = e.length, r = new ArrayBuffer(t), n = new Uint8Array(r), i = -1; ++i < t;)n[i] = e.charCodeAt(i); return r; } const lm = __webpack_require__(8545); const cm = __webpack_require__(1352); function hm(e) { for (let t = e.length; --t >= 0;)e[t] = 0; } const fm = 256; const dm = 286; const pm = 30; const mm = 15; const vm = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]); const gm = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]); const ym = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]); const bm = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); const wm = new Array(576); hm(wm); const km = new Array(60); hm(km); const xm = new Array(512); hm(xm); const _m = new Array(256); hm(_m); const Sm = new Array(29); hm(Sm); let Mm; let Em; let Cm; const Pm = new Array(pm); function Am(e, t, r, n, i) { this.static_tree = e, this.extra_bits = t, this.extra_base = r, this.elems = n, this.max_length = i, this.has_stree = e && e.length; } function Tm(e, t) { this.dyn_tree = e, this.max_code = 0, this.stat_desc = t; }hm(Pm); const Rm = function (e) { return e < 256 ? xm[e] : xm[256 + (e >>> 7)]; }; const Im = function (e, t) { e.pending_buf[e.pending++] = 255 & t, e.pending_buf[e.pending++] = t >>> 8 & 255; }; const Om = function (e, t, r) { e.bi_valid > 16 - r ? (e.bi_buf |= t << e.bi_valid & 65535, Im(e, e.bi_buf), e.bi_buf = t >> 16 - e.bi_valid, e.bi_valid += r - 16) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += r); }; const Dm = function (e, t, r) { Om(e, r[2 * t], r[2 * t + 1]); }; const zm = function (e, t) { let r = 0; do { r |= 1 & e, e >>>= 1, r <<= 1; } while (--t > 0); return r >>> 1; }; const Nm = function (e, t, r) { let n; let i; const a = new Array(16); let o = 0; for (n = 1; n <= mm; n++)o = o + r[n - 1] << 1, a[n] = o; for (i = 0; i <= t; i++) { const s = e[2 * i + 1]; s !== 0 && (e[2 * i] = zm(a[s]++, s)); } }; const Lm = function (e) { let t; for (t = 0; t < dm; t++)e.dyn_ltree[2 * t] = 0; for (t = 0; t < pm; t++)e.dyn_dtree[2 * t] = 0; for (t = 0; t < 19; t++)e.bl_tree[2 * t] = 0; e.dyn_ltree[512] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0; }; const jm = function (e) { e.bi_valid > 8 ? Im(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0; }; const Fm = function (e, t, r, n) { const i = 2 * t; const a = 2 * r; return e[i] < e[a] || e[i] === e[a] && n[t] <= n[r]; }; const Bm = function (e, t, r) { for (var n = e.heap[r], i = r << 1; i <= e.heap_len && (i < e.heap_len && Fm(t, e.heap[i + 1], e.heap[i], e.depth) && i++, !Fm(t, n, e.heap[i], e.depth));)e.heap[r] = e.heap[i], r = i, i <<= 1; e.heap[r] = n; }; const Um = function (e, t, r) { let n; let i; let a; let o; let s = 0; if (e.sym_next !== 0) do { n = 255 & e.pending_buf[e.sym_buf + s++], n += (255 & e.pending_buf[e.sym_buf + s++]) << 8, i = e.pending_buf[e.sym_buf + s++], n === 0 ? Dm(e, i, t) : (a = _m[i], Dm(e, a + fm + 1, t), (o = vm[a]) !== 0 && (i -= Sm[a], Om(e, i, o)), n--, a = Rm(n), Dm(e, a, r), (o = gm[a]) !== 0 && (n -= Pm[a], Om(e, n, o))); } while (s < e.sym_next); Dm(e, 256, t); }; const Vm = function (e, t) { let r; let n; let i; const a = t.dyn_tree; const o = t.stat_desc.static_tree; const s = t.stat_desc.has_stree; const u = t.stat_desc.elems; let l = -1; for (e.heap_len = 0, e.heap_max = 573, r = 0; r < u; r++)a[2 * r] !== 0 ? (e.heap[++e.heap_len] = l = r, e.depth[r] = 0) : a[2 * r + 1] = 0; for (;e.heap_len < 2;)a[2 * (i = e.heap[++e.heap_len] = l < 2 ? ++l : 0)] = 1, e.depth[i] = 0, e.opt_len--, s && (e.static_len -= o[2 * i + 1]); for (t.max_code = l, r = e.heap_len >> 1; r >= 1; r--)Bm(e, a, r); i = u; do { r = e.heap[1], e.heap[1] = e.heap[e.heap_len--], Bm(e, a, 1), n = e.heap[1], e.heap[--e.heap_max] = r, e.heap[--e.heap_max] = n, a[2 * i] = a[2 * r] + a[2 * n], e.depth[i] = (e.depth[r] >= e.depth[n] ? e.depth[r] : e.depth[n]) + 1, a[2 * r + 1] = a[2 * n + 1] = i, e.heap[1] = i++, Bm(e, a, 1); } while (e.heap_len >= 2); e.heap[--e.heap_max] = e.heap[1], (function (e, t) { let r; let n; let i; let a; let o; let s; const u = t.dyn_tree; const l = t.max_code; const c = t.stat_desc.static_tree; const h = t.stat_desc.has_stree; const f = t.stat_desc.extra_bits; const d = t.stat_desc.extra_base; const p = t.stat_desc.max_length; let m = 0; for (a = 0; a <= mm; a++)e.bl_count[a] = 0; for (u[2 * e.heap[e.heap_max] + 1] = 0, r = e.heap_max + 1; r < 573; r++)(a = u[2 * u[2 * (n = e.heap[r]) + 1] + 1] + 1) > p && (a = p, m++), u[2 * n + 1] = a, n > l || (e.bl_count[a]++, o = 0, n >= d && (o = f[n - d]), s = u[2 * n], e.opt_len += s * (a + o), h && (e.static_len += s * (c[2 * n + 1] + o))); if (m !== 0) { do { for (a = p - 1; e.bl_count[a] === 0;)a--; e.bl_count[a]--, e.bl_count[a + 1] += 2, e.bl_count[p]--, m -= 2; } while (m > 0); for (a = p; a !== 0; a--) for (n = e.bl_count[a]; n !== 0;)(i = e.heap[--r]) > l || (u[2 * i + 1] !== a && (e.opt_len += (a - u[2 * i + 1]) * u[2 * i], u[2 * i + 1] = a), n--); } }(e, t)), Nm(a, l, e.bl_count); }; const Ym = function (e, t, r) { let n; let i; let a = -1; let o = t[1]; let s = 0; let u = 7; let l = 4; for (o === 0 && (u = 138, l = 3), t[2 * (r + 1) + 1] = 65535, n = 0; n <= r; n++)i = o, o = t[2 * (n + 1) + 1], ++s < u && i === o || (s < l ? e.bl_tree[2 * i] += s : i !== 0 ? (i !== a && e.bl_tree[2 * i]++, e.bl_tree[32]++) : s <= 10 ? e.bl_tree[34]++ : e.bl_tree[36]++, s = 0, a = i, o === 0 ? (u = 138, l = 3) : i === o ? (u = 6, l = 3) : (u = 7, l = 4)); }; const Hm = function (e, t, r) { let n; let i; let a = -1; let o = t[1]; let s = 0; let u = 7; let l = 4; for (o === 0 && (u = 138, l = 3), n = 0; n <= r; n++) if (i = o, o = t[2 * (n + 1) + 1], !(++s < u && i === o)) { if (s < l) do { Dm(e, i, e.bl_tree); } while (--s !== 0); else i !== 0 ? (i !== a && (Dm(e, i, e.bl_tree), s--), Dm(e, 16, e.bl_tree), Om(e, s - 3, 2)) : s <= 10 ? (Dm(e, 17, e.bl_tree), Om(e, s - 3, 3)) : (Dm(e, 18, e.bl_tree), Om(e, s - 11, 7)); s = 0, a = i, o === 0 ? (u = 138, l = 3) : i === o ? (u = 6, l = 3) : (u = 7, l = 4); } }; let qm = !1; const Wm = function (e, t, r, n) { Om(e, 0 + (n ? 1 : 0), 3), jm(e), Im(e, r), Im(e, ~r), r && e.pending_buf.set(e.window.subarray(t, t + r), e.pending), e.pending += r; }; const Xm = function (e) { qm || (!(function () { let e; let t; let r; let n; let i; const a = new Array(16); for (r = 0, n = 0; n < 28; n++) for (Sm[n] = r, e = 0; e < 1 << vm[n]; e++)_m[r++] = n; for (_m[r - 1] = n, i = 0, n = 0; n < 16; n++) for (Pm[n] = i, e = 0; e < 1 << gm[n]; e++)xm[i++] = n; for (i >>= 7; n < pm; n++) for (Pm[n] = i << 7, e = 0; e < 1 << gm[n] - 7; e++)xm[256 + i++] = n; for (t = 0; t <= mm; t++)a[t] = 0; for (e = 0; e <= 143;)wm[2 * e + 1] = 8, e++, a[8]++; for (;e <= 255;)wm[2 * e + 1] = 9, e++, a[9]++; for (;e <= 279;)wm[2 * e + 1] = 7, e++, a[7]++; for (;e <= 287;)wm[2 * e + 1] = 8, e++, a[8]++; for (Nm(wm, 287, a), e = 0; e < pm; e++)km[2 * e + 1] = 5, km[2 * e] = zm(e, 5); Mm = new Am(wm, vm, 257, dm, mm), Em = new Am(km, gm, 0, pm, mm), Cm = new Am(new Array(0), ym, 0, 19, 7); }()), qm = !0), e.l_desc = new Tm(e.dyn_ltree, Mm), e.d_desc = new Tm(e.dyn_dtree, Em), e.bl_desc = new Tm(e.bl_tree, Cm), e.bi_buf = 0, e.bi_valid = 0, Lm(e); }; const Gm = function (e, t, r, n) { let i; let a; let o = 0; e.level > 0 ? (e.strm.data_type === 2 && (e.strm.data_type = (function (e) { let t; let r = 4093624447; for (t = 0; t <= 31; t++, r >>>= 1) if (1 & r && e.dyn_ltree[2 * t] !== 0) return 0; if (e.dyn_ltree[18] !== 0 || e.dyn_ltree[20] !== 0 || e.dyn_ltree[26] !== 0) return 1; for (t = 32; t < fm; t++) if (e.dyn_ltree[2 * t] !== 0) return 1; return 0; }(e))), Vm(e, e.l_desc), Vm(e, e.d_desc), o = (function (e) { let t; for (Ym(e, e.dyn_ltree, e.l_desc.max_code), Ym(e, e.dyn_dtree, e.d_desc.max_code), Vm(e, e.bl_desc), t = 18; t >= 3 && e.bl_tree[2 * bm[t] + 1] === 0; t--);return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t; }(e)), i = e.opt_len + 3 + 7 >>> 3, (a = e.static_len + 3 + 7 >>> 3) <= i && (i = a)) : i = a = r + 5, r + 4 <= i && t !== -1 ? Wm(e, t, r, n) : e.strategy === 4 || a === i ? (Om(e, 2 + (n ? 1 : 0), 3), Um(e, wm, km)) : (Om(e, 4 + (n ? 1 : 0), 3), (function (e, t, r, n) { let i; for (Om(e, t - 257, 5), Om(e, r - 1, 5), Om(e, n - 4, 4), i = 0; i < n; i++)Om(e, e.bl_tree[2 * bm[i] + 1], 3); Hm(e, e.dyn_ltree, t - 1), Hm(e, e.dyn_dtree, r - 1); }(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, o + 1)), Um(e, e.dyn_ltree, e.dyn_dtree)), Lm(e), n && jm(e); }; const $m = function (e, t, r) { return e.pending_buf[e.sym_buf + e.sym_next++] = t, e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = r, t === 0 ? e.dyn_ltree[2 * r]++ : (e.matches++, t--, e.dyn_ltree[2 * (_m[r] + fm + 1)]++, e.dyn_dtree[2 * Rm(t)]++), e.sym_next === e.sym_end; }; const Zm = function (e) { Om(e, 2, 3), Dm(e, 256, wm), (function (e) { e.bi_valid === 16 ? (Im(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8); }(e)); }; const Km = {
      _tr_init: Xm, _tr_stored_block: Wm, _tr_flush_block: Gm, _tr_tally: $m, _tr_align: Zm,
    }; const Qm = function (e, t, r, n) { for (var i = 65535 & e | 0, a = e >>> 16 & 65535 | 0, o = 0; r !== 0;) { r -= o = r > 2e3 ? 2e3 : r; do { a = a + (i = i + t[n++] | 0) | 0; } while (--o); i %= 65521, a %= 65521; } return i | a << 16 | 0; }; const Jm = new Uint32Array(function () { for (var e, t = [], r = 0; r < 256; r++) { e = r; for (let n = 0; n < 8; n++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1; t[r] = e; } return t; }()); const ev = function (e, t, r, n) { const i = Jm; const a = n + r; e ^= -1; for (let o = n; o < a; o++)e = e >>> 8 ^ i[255 & (e ^ t[o])]; return -1 ^ e; }; const tv = {
      2: 'need dictionary', 1: 'stream end', 0: '', '-1': 'file error', '-2': 'stream error', '-3': 'data error', '-4': 'insufficient memory', '-5': 'buffer error', '-6': 'incompatible version',
    }; const rv = {
      Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8,
    }; const nv = Km._tr_init; const iv = Km._tr_stored_block; const av = Km._tr_flush_block; const ov = Km._tr_tally; const sv = Km._tr_align; const uv = rv.Z_NO_FLUSH; const lv = rv.Z_PARTIAL_FLUSH; const cv = rv.Z_FULL_FLUSH; const hv = rv.Z_FINISH; const fv = rv.Z_BLOCK; const dv = rv.Z_OK; const pv = rv.Z_STREAM_END; const mv = rv.Z_STREAM_ERROR; const vv = rv.Z_DATA_ERROR; const gv = rv.Z_BUF_ERROR; const yv = rv.Z_DEFAULT_COMPRESSION; const bv = rv.Z_FILTERED; const wv = rv.Z_HUFFMAN_ONLY; const kv = rv.Z_RLE; const xv = rv.Z_FIXED; const _v = rv.Z_DEFAULT_STRATEGY; const Sv = rv.Z_UNKNOWN; const Mv = rv.Z_DEFLATED; const Ev = 258; const Cv = 262; const Pv = 42; const Av = 113; const Tv = 666; const Rv = function (e, t) { return e.msg = tv[t], t; }; const Iv = function (e) { return 2 * e - (e > 4 ? 9 : 0); }; const Ov = function (e) { for (let t = e.length; --t >= 0;)e[t] = 0; }; const Dv = function (e) { let t; let r; let n; const i = e.w_size; n = t = e.hash_size; do { r = e.head[--n], e.head[n] = r >= i ? r - i : 0; } while (--t); n = t = i; do { r = e.prev[--n], e.prev[n] = r >= i ? r - i : 0; } while (--t); }; const zv = function (e, t, r) { return (t << e.hash_shift ^ r) & e.hash_mask; }; const Nv = function (e) { const t = e.state; let r = t.pending; r > e.avail_out && (r = e.avail_out), r !== 0 && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + r), e.next_out), e.next_out += r, t.pending_out += r, e.total_out += r, e.avail_out -= r, t.pending -= r, t.pending === 0 && (t.pending_out = 0)); }; const Lv = function (e, t) { av(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, Nv(e.strm); }; const jv = function (e, t) { e.pending_buf[e.pending++] = t; }; const Fv = function (e, t) { e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = 255 & t; }; const Bv = function (e, t, r, n) { let i = e.avail_in; return i > n && (i = n), i === 0 ? 0 : (e.avail_in -= i, t.set(e.input.subarray(e.next_in, e.next_in + i), r), e.state.wrap === 1 ? e.adler = Qm(e.adler, t, i, r) : e.state.wrap === 2 && (e.adler = ev(e.adler, t, i, r)), e.next_in += i, e.total_in += i, i); }; const Uv = function (e, t) { let r; let n; let i = e.max_chain_length; let a = e.strstart; let o = e.prev_length; let s = e.nice_match; const u = e.strstart > e.w_size - Cv ? e.strstart - (e.w_size - Cv) : 0; const l = e.window; const c = e.w_mask; const h = e.prev; const f = e.strstart + Ev; let d = l[a + o - 1]; let p = l[a + o]; e.prev_length >= e.good_match && (i >>= 2), s > e.lookahead && (s = e.lookahead); do { if (l[(r = t) + o] === p && l[r + o - 1] === d && l[r] === l[a] && l[++r] === l[a + 1]) { a += 2, r++; do {} while (l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && a < f); if (n = Ev - (f - a), a = f - Ev, n > o) { if (e.match_start = t, o = n, n >= s) break; d = l[a + o - 1], p = l[a + o]; } } } while ((t = h[t & c]) > u && --i !== 0); return o <= e.lookahead ? o : e.lookahead; }; const Vv = function (e) { let t; let r; let n; const i = e.w_size; do { if (r = e.window_size - e.lookahead - e.strstart, e.strstart >= i + (i - Cv) && (e.window.set(e.window.subarray(i, i + i - r), 0), e.match_start -= i, e.strstart -= i, e.block_start -= i, e.insert > e.strstart && (e.insert = e.strstart), Dv(e), r += i), e.strm.avail_in === 0) break; if (t = Bv(e.strm, e.window, e.strstart + e.lookahead, r), e.lookahead += t, e.lookahead + e.insert >= 3) for (n = e.strstart - e.insert, e.ins_h = e.window[n], e.ins_h = zv(e, e.ins_h, e.window[n + 1]); e.insert && (e.ins_h = zv(e, e.ins_h, e.window[n + 3 - 1]), e.prev[n & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = n, n++, e.insert--, !(e.lookahead + e.insert < 3));); } while (e.lookahead < Cv && e.strm.avail_in !== 0); }; const Yv = function (e, t) { let r; let n; let i; let a = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5; let o = 0; let s = e.strm.avail_in; do { if (r = 65535, i = e.bi_valid + 42 >> 3, e.strm.avail_out < i) break; if (i = e.strm.avail_out - i, r > (n = e.strstart - e.block_start) + e.strm.avail_in && (r = n + e.strm.avail_in), r > i && (r = i), r < a && (r === 0 && t !== hv || t === uv || r !== n + e.strm.avail_in)) break; o = t === hv && r === n + e.strm.avail_in ? 1 : 0, iv(e, 0, 0, o), e.pending_buf[e.pending - 4] = r, e.pending_buf[e.pending - 3] = r >> 8, e.pending_buf[e.pending - 2] = ~r, e.pending_buf[e.pending - 1] = ~r >> 8, Nv(e.strm), n && (n > r && (n = r), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + n), e.strm.next_out), e.strm.next_out += n, e.strm.avail_out -= n, e.strm.total_out += n, e.block_start += n, r -= n), r && (Bv(e.strm, e.strm.output, e.strm.next_out, r), e.strm.next_out += r, e.strm.avail_out -= r, e.strm.total_out += r); } while (o === 0); return (s -= e.strm.avail_in) && (s >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= s && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - s, e.strm.next_in), e.strstart), e.strstart += s, e.insert += s > e.w_size - e.insert ? e.w_size - e.insert : s), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), o ? 4 : t !== uv && t !== hv && e.strm.avail_in === 0 && e.strstart === e.block_start ? 2 : (i = e.window_size - e.strstart, e.strm.avail_in > i && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, i += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), i > e.strm.avail_in && (i = e.strm.avail_in), i && (Bv(e.strm, e.window, e.strstart, i), e.strstart += i, e.insert += i > e.w_size - e.insert ? e.w_size - e.insert : i), e.high_water < e.strstart && (e.high_water = e.strstart), i = e.bi_valid + 42 >> 3, a = (i = e.pending_buf_size - i > 65535 ? 65535 : e.pending_buf_size - i) > e.w_size ? e.w_size : i, ((n = e.strstart - e.block_start) >= a || (n || t === hv) && t !== uv && e.strm.avail_in === 0 && n <= i) && (r = n > i ? i : n, o = t === hv && e.strm.avail_in === 0 && r === n ? 1 : 0, iv(e, e.block_start, r, o), e.block_start += r, Nv(e.strm)), o ? 3 : 1); }; const Hv = function (e, t) { for (var r, n; ;) { if (e.lookahead < Cv) { if (Vv(e), e.lookahead < Cv && t === uv) return 1; if (e.lookahead === 0) break; } if (r = 0, e.lookahead >= 3 && (e.ins_h = zv(e, e.ins_h, e.window[e.strstart + 3 - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), r !== 0 && e.strstart - r <= e.w_size - Cv && (e.match_length = Uv(e, r)), e.match_length >= 3) if (n = ov(e, e.strstart - e.match_start, e.match_length - 3), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= 3) { e.match_length--; do { e.strstart++, e.ins_h = zv(e, e.ins_h, e.window[e.strstart + 3 - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart; } while (--e.match_length !== 0); e.strstart++; } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = zv(e, e.ins_h, e.window[e.strstart + 1]); else n = ov(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++; if (n && (Lv(e, !1), e.strm.avail_out === 0)) return 1; } return e.insert = e.strstart < 2 ? e.strstart : 2, t === hv ? (Lv(e, !0), e.strm.avail_out === 0 ? 3 : 4) : e.sym_next && (Lv(e, !1), e.strm.avail_out === 0) ? 1 : 2; }; const qv = function (e, t) { for (var r, n, i; ;) { if (e.lookahead < Cv) { if (Vv(e), e.lookahead < Cv && t === uv) return 1; if (e.lookahead === 0) break; } if (r = 0, e.lookahead >= 3 && (e.ins_h = zv(e, e.ins_h, e.window[e.strstart + 3 - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = 2, r !== 0 && e.prev_length < e.max_lazy_match && e.strstart - r <= e.w_size - Cv && (e.match_length = Uv(e, r), e.match_length <= 5 && (e.strategy === bv || e.match_length === 3 && e.strstart - e.match_start > 4096) && (e.match_length = 2)), e.prev_length >= 3 && e.match_length <= e.prev_length) { i = e.strstart + e.lookahead - 3, n = ov(e, e.strstart - 1 - e.prev_match, e.prev_length - 3), e.lookahead -= e.prev_length - 1, e.prev_length -= 2; do { ++e.strstart <= i && (e.ins_h = zv(e, e.ins_h, e.window[e.strstart + 3 - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart); } while (--e.prev_length !== 0); if (e.match_available = 0, e.match_length = 2, e.strstart++, n && (Lv(e, !1), e.strm.avail_out === 0)) return 1; } else if (e.match_available) { if ((n = ov(e, 0, e.window[e.strstart - 1])) && Lv(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0) return 1; } else e.match_available = 1, e.strstart++, e.lookahead--; } return e.match_available && (n = ov(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < 2 ? e.strstart : 2, t === hv ? (Lv(e, !0), e.strm.avail_out === 0 ? 3 : 4) : e.sym_next && (Lv(e, !1), e.strm.avail_out === 0) ? 1 : 2; }; function Wv(e, t, r, n, i) { this.good_length = e, this.max_lazy = t, this.nice_length = r, this.max_chain = n, this.func = i; } const Xv = [new Wv(0, 0, 0, 0, Yv), new Wv(4, 4, 8, 4, Hv), new Wv(4, 5, 16, 8, Hv), new Wv(4, 6, 32, 32, Hv), new Wv(4, 4, 16, 16, qv), new Wv(8, 16, 32, 32, qv), new Wv(8, 16, 128, 128, qv), new Wv(8, 32, 128, 256, qv), new Wv(32, 128, 258, 1024, qv), new Wv(32, 258, 258, 4096, qv)]; function Gv() { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Mv, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), Ov(this.dyn_ltree), Ov(this.dyn_dtree), Ov(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), Ov(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), Ov(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0; } const $v = function (e) { if (!e) return 1; const t = e.state; return !t || t.strm !== e || t.status !== Pv && t.status !== 57 && t.status !== 69 && t.status !== 73 && t.status !== 91 && t.status !== 103 && t.status !== Av && t.status !== Tv ? 1 : 0; }; const Zv = function (e) { if ($v(e)) return Rv(e, mv); e.total_in = e.total_out = 0, e.data_type = Sv; const t = e.state; return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap === 2 ? 57 : t.wrap ? Pv : Av, e.adler = t.wrap === 2 ? 0 : 1, t.last_flush = -2, nv(t), dv; }; const Kv = function (e) { const t = Zv(e); return t === dv && (function (e) { e.window_size = 2 * e.w_size, Ov(e.head), e.max_lazy_match = Xv[e.level].max_lazy, e.good_match = Xv[e.level].good_length, e.nice_match = Xv[e.level].nice_length, e.max_chain_length = Xv[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = 2, e.match_available = 0, e.ins_h = 0; }(e.state)), t; }; const Qv = function (e, t, r, n, i, a) { if (!e) return mv; let o = 1; if (t === yv && (t = 6), n < 0 ? (o = 0, n = -n) : n > 15 && (o = 2, n -= 16), i < 1 || i > 9 || r !== Mv || n < 8 || n > 15 || t < 0 || t > 9 || a < 0 || a > xv || n === 8 && o !== 1) return Rv(e, mv); n === 8 && (n = 9); const s = new Gv(); return e.state = s, s.strm = e, s.status = Pv, s.wrap = o, s.gzhead = null, s.w_bits = n, s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = i + 7, s.hash_size = 1 << s.hash_bits, s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + 3 - 1) / 3), s.window = new Uint8Array(2 * s.w_size), s.head = new Uint16Array(s.hash_size), s.prev = new Uint16Array(s.w_size), s.lit_bufsize = 1 << i + 6, s.pending_buf_size = 4 * s.lit_bufsize, s.pending_buf = new Uint8Array(s.pending_buf_size), s.sym_buf = s.lit_bufsize, s.sym_end = 3 * (s.lit_bufsize - 1), s.level = t, s.strategy = a, s.method = r, Kv(e); }; const Jv = function (e, t) { return Qv(e, t, Mv, 15, 8, _v); }; const eg = function (e, t) { if ($v(e) || t > fv || t < 0) return e ? Rv(e, mv) : mv; const r = e.state; if (!e.output || e.avail_in !== 0 && !e.input || r.status === Tv && t !== hv) return Rv(e, e.avail_out === 0 ? gv : mv); const n = r.last_flush; if (r.last_flush = t, r.pending !== 0) { if (Nv(e), e.avail_out === 0) return r.last_flush = -1, dv; } else if (e.avail_in === 0 && Iv(t) <= Iv(n) && t !== hv) return Rv(e, gv); if (r.status === Tv && e.avail_in !== 0) return Rv(e, gv); if (r.status === Pv && r.wrap === 0 && (r.status = Av), r.status === Pv) { let i = Mv + (r.w_bits - 8 << 4) << 8; if (i |= (r.strategy >= wv || r.level < 2 ? 0 : r.level < 6 ? 1 : r.level === 6 ? 2 : 3) << 6, r.strstart !== 0 && (i |= 32), Fv(r, i += 31 - i % 31), r.strstart !== 0 && (Fv(r, e.adler >>> 16), Fv(r, 65535 & e.adler)), e.adler = 1, r.status = Av, Nv(e), r.pending !== 0) return r.last_flush = -1, dv; } if (r.status === 57) if (e.adler = 0, jv(r, 31), jv(r, 139), jv(r, 8), r.gzhead)jv(r, (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)), jv(r, 255 & r.gzhead.time), jv(r, r.gzhead.time >> 8 & 255), jv(r, r.gzhead.time >> 16 & 255), jv(r, r.gzhead.time >> 24 & 255), jv(r, r.level === 9 ? 2 : r.strategy >= wv || r.level < 2 ? 4 : 0), jv(r, 255 & r.gzhead.os), r.gzhead.extra && r.gzhead.extra.length && (jv(r, 255 & r.gzhead.extra.length), jv(r, r.gzhead.extra.length >> 8 & 255)), r.gzhead.hcrc && (e.adler = ev(e.adler, r.pending_buf, r.pending, 0)), r.gzindex = 0, r.status = 69; else if (jv(r, 0), jv(r, 0), jv(r, 0), jv(r, 0), jv(r, 0), jv(r, r.level === 9 ? 2 : r.strategy >= wv || r.level < 2 ? 4 : 0), jv(r, 3), r.status = Av, Nv(e), r.pending !== 0) return r.last_flush = -1, dv; if (r.status === 69) { if (r.gzhead.extra) { for (var a = r.pending, o = (65535 & r.gzhead.extra.length) - r.gzindex; r.pending + o > r.pending_buf_size;) { const s = r.pending_buf_size - r.pending; if (r.pending_buf.set(r.gzhead.extra.subarray(r.gzindex, r.gzindex + s), r.pending), r.pending = r.pending_buf_size, r.gzhead.hcrc && r.pending > a && (e.adler = ev(e.adler, r.pending_buf, r.pending - a, a)), r.gzindex += s, Nv(e), r.pending !== 0) return r.last_flush = -1, dv; a = 0, o -= s; } const u = new Uint8Array(r.gzhead.extra); r.pending_buf.set(u.subarray(r.gzindex, r.gzindex + o), r.pending), r.pending += o, r.gzhead.hcrc && r.pending > a && (e.adler = ev(e.adler, r.pending_buf, r.pending - a, a)), r.gzindex = 0; }r.status = 73; } if (r.status === 73) { if (r.gzhead.name) { let l; let c = r.pending; do { if (r.pending === r.pending_buf_size) { if (r.gzhead.hcrc && r.pending > c && (e.adler = ev(e.adler, r.pending_buf, r.pending - c, c)), Nv(e), r.pending !== 0) return r.last_flush = -1, dv; c = 0; }l = r.gzindex < r.gzhead.name.length ? 255 & r.gzhead.name.charCodeAt(r.gzindex++) : 0, jv(r, l); } while (l !== 0); r.gzhead.hcrc && r.pending > c && (e.adler = ev(e.adler, r.pending_buf, r.pending - c, c)), r.gzindex = 0; }r.status = 91; } if (r.status === 91) { if (r.gzhead.comment) { let h; let f = r.pending; do { if (r.pending === r.pending_buf_size) { if (r.gzhead.hcrc && r.pending > f && (e.adler = ev(e.adler, r.pending_buf, r.pending - f, f)), Nv(e), r.pending !== 0) return r.last_flush = -1, dv; f = 0; }h = r.gzindex < r.gzhead.comment.length ? 255 & r.gzhead.comment.charCodeAt(r.gzindex++) : 0, jv(r, h); } while (h !== 0); r.gzhead.hcrc && r.pending > f && (e.adler = ev(e.adler, r.pending_buf, r.pending - f, f)); }r.status = 103; } if (r.status === 103) { if (r.gzhead.hcrc) { if (r.pending + 2 > r.pending_buf_size && (Nv(e), r.pending !== 0)) return r.last_flush = -1, dv; jv(r, 255 & e.adler), jv(r, e.adler >> 8 & 255), e.adler = 0; } if (r.status = Av, Nv(e), r.pending !== 0) return r.last_flush = -1, dv; } if (e.avail_in !== 0 || r.lookahead !== 0 || t !== uv && r.status !== Tv) { const d = r.level === 0 ? Yv(r, t) : r.strategy === wv ? (function (e, t) { for (var r; ;) { if (e.lookahead === 0 && (Vv(e), e.lookahead === 0)) { if (t === uv) return 1; break; } if (e.match_length = 0, r = ov(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, r && (Lv(e, !1), e.strm.avail_out === 0)) return 1; } return e.insert = 0, t === hv ? (Lv(e, !0), e.strm.avail_out === 0 ? 3 : 4) : e.sym_next && (Lv(e, !1), e.strm.avail_out === 0) ? 1 : 2; }(r, t)) : r.strategy === kv ? (function (e, t) { for (var r, n, i, a, o = e.window; ;) { if (e.lookahead <= Ev) { if (Vv(e), e.lookahead <= Ev && t === uv) return 1; if (e.lookahead === 0) break; } if (e.match_length = 0, e.lookahead >= 3 && e.strstart > 0 && (n = o[i = e.strstart - 1]) === o[++i] && n === o[++i] && n === o[++i]) { a = e.strstart + Ev; do {} while (n === o[++i] && n === o[++i] && n === o[++i] && n === o[++i] && n === o[++i] && n === o[++i] && n === o[++i] && n === o[++i] && i < a); e.match_length = Ev - (a - i), e.match_length > e.lookahead && (e.match_length = e.lookahead); } if (e.match_length >= 3 ? (r = ov(e, 1, e.match_length - 3), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (r = ov(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), r && (Lv(e, !1), e.strm.avail_out === 0)) return 1; } return e.insert = 0, t === hv ? (Lv(e, !0), e.strm.avail_out === 0 ? 3 : 4) : e.sym_next && (Lv(e, !1), e.strm.avail_out === 0) ? 1 : 2; }(r, t)) : Xv[r.level].func(r, t); if (d !== 3 && d !== 4 || (r.status = Tv), d === 1 || d === 3) return e.avail_out === 0 && (r.last_flush = -1), dv; if (d === 2 && (t === lv ? sv(r) : t !== fv && (iv(r, 0, 0, !1), t === cv && (Ov(r.head), r.lookahead === 0 && (r.strstart = 0, r.block_start = 0, r.insert = 0))), Nv(e), e.avail_out === 0)) return r.last_flush = -1, dv; } return t !== hv ? dv : r.wrap <= 0 ? pv : (r.wrap === 2 ? (jv(r, 255 & e.adler), jv(r, e.adler >> 8 & 255), jv(r, e.adler >> 16 & 255), jv(r, e.adler >> 24 & 255), jv(r, 255 & e.total_in), jv(r, e.total_in >> 8 & 255), jv(r, e.total_in >> 16 & 255), jv(r, e.total_in >> 24 & 255)) : (Fv(r, e.adler >>> 16), Fv(r, 65535 & e.adler)), Nv(e), r.wrap > 0 && (r.wrap = -r.wrap), r.pending !== 0 ? dv : pv); }; const tg = function (e, t) { let r = t.length; if ($v(e)) return mv; const n = e.state; const i = n.wrap; if (i === 2 || i === 1 && n.status !== Pv || n.lookahead) return mv; if (i === 1 && (e.adler = Qm(e.adler, t, r, 0)), n.wrap = 0, r >= n.w_size) { i === 0 && (Ov(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0); const a = new Uint8Array(n.w_size); a.set(t.subarray(r - n.w_size, r), 0), t = a, r = n.w_size; } const o = e.avail_in; const s = e.next_in; const u = e.input; for (e.avail_in = r, e.next_in = 0, e.input = t, Vv(n); n.lookahead >= 3;) { let l = n.strstart; let c = n.lookahead - 2; do { n.ins_h = zv(n, n.ins_h, n.window[l + 3 - 1]), n.prev[l & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = l, l++; } while (--c); n.strstart = l, n.lookahead = 2, Vv(n); } return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = 2, n.match_available = 0, e.next_in = s, e.input = u, e.avail_in = o, n.wrap = i, dv; }; const rg = {
      deflateInit: Jv, deflateInit2: Qv, deflateReset: Kv, deflateResetKeep: Zv, deflateSetHeader(e, t) { return $v(e) || e.state.wrap !== 2 ? mv : (e.state.gzhead = t, dv); }, deflate: eg, deflateEnd(e) { if ($v(e)) return mv; const t = e.state.status; return e.state = null, t === Av ? Rv(e, vv) : dv; }, deflateSetDictionary: tg, deflateInfo: 'pako deflate (from Nodeca project)',
    }; const ng = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t); }; const ig = { assign(e) { for (let t = Array.prototype.slice.call(arguments, 1); t.length;) { const r = t.shift(); if (r) { if (typeof r !== 'object') throw new TypeError(`${r}must be non-object`); for (const n in r)ng(r, n) && (e[n] = r[n]); } } return e; }, flattenChunks(e) { for (var t = 0, r = 0, n = e.length; r < n; r++)t += e[r].length; for (var i = new Uint8Array(t), a = 0, o = 0, s = e.length; a < s; a++) { const u = e[a]; i.set(u, o), o += u.length; } return i; } }; let ag = !0; try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (LS) { ag = !1; } for (var og = new Uint8Array(256), sg = 0; sg < 256; sg++)og[sg] = sg >= 252 ? 6 : sg >= 248 ? 5 : sg >= 240 ? 4 : sg >= 224 ? 3 : sg >= 192 ? 2 : 1; og[254] = og[254] = 1; const ug = { string2buf(e) { if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) return (new TextEncoder()).encode(e); let t; let r; let n; let i; let a; const o = e.length; let s = 0; for (i = 0; i < o; i++)(64512 & (r = e.charCodeAt(i))) === 55296 && i + 1 < o && (64512 & (n = e.charCodeAt(i + 1))) === 56320 && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), s += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4; for (t = new Uint8Array(s), a = 0, i = 0; a < s; i++)(64512 & (r = e.charCodeAt(i))) === 55296 && i + 1 < o && (64512 & (n = e.charCodeAt(i + 1))) === 56320 && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), r < 128 ? t[a++] = r : r < 2048 ? (t[a++] = 192 | r >>> 6, t[a++] = 128 | 63 & r) : r < 65536 ? (t[a++] = 224 | r >>> 12, t[a++] = 128 | r >>> 6 & 63, t[a++] = 128 | 63 & r) : (t[a++] = 240 | r >>> 18, t[a++] = 128 | r >>> 12 & 63, t[a++] = 128 | r >>> 6 & 63, t[a++] = 128 | 63 & r); return t; }, buf2string(e, t) { let r; let n; const i = t || e.length; if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) return (new TextDecoder()).decode(e.subarray(0, t)); const a = new Array(2 * i); for (n = 0, r = 0; r < i;) { let o = e[r++]; if (o < 128)a[n++] = o; else { let s = og[o]; if (s > 4)a[n++] = 65533, r += s - 1; else { for (o &= s === 2 ? 31 : s === 3 ? 15 : 7; s > 1 && r < i;)o = o << 6 | 63 & e[r++], s--; s > 1 ? a[n++] = 65533 : o < 65536 ? a[n++] = o : (o -= 65536, a[n++] = 55296 | o >> 10 & 1023, a[n++] = 56320 | 1023 & o); } } } return (function (e, t) { if (t < 65534 && e.subarray && ag) return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t)); for (var r = '', n = 0; n < t; n++)r += String.fromCharCode(e[n]); return r; }(a, n)); }, utf8border(e, t) { (t = t || e.length) > e.length && (t = e.length); for (var r = t - 1; r >= 0 && (192 & e[r]) === 128;)r--; return r < 0 || r === 0 ? t : r + og[e[r]] > t ? r : t; } }; const lg = function () { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = '', this.state = null, this.data_type = 2, this.adler = 0; }; const cg = Object.prototype.toString; const hg = rv.Z_NO_FLUSH; const fg = rv.Z_SYNC_FLUSH; const dg = rv.Z_FULL_FLUSH; const pg = rv.Z_FINISH; const mg = rv.Z_OK; const vg = rv.Z_STREAM_END; const gg = rv.Z_DEFAULT_COMPRESSION; const yg = rv.Z_DEFAULT_STRATEGY; const bg = rv.Z_DEFLATED; function wg(e) {
      this.options = ig.assign({
        level: gg, method: bg, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: yg,
      }, e || {}); const t = this.options; t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = '', this.ended = !1, this.chunks = [], this.strm = new lg(), this.strm.avail_out = 0; let r = rg.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy); if (r !== mg) throw new Error(tv[r]); if (t.header && rg.deflateSetHeader(this.strm, t.header), t.dictionary) { let n; if (n = typeof t.dictionary === 'string' ? ug.string2buf(t.dictionary) : cg.call(t.dictionary) === '[object ArrayBuffer]' ? new Uint8Array(t.dictionary) : t.dictionary, (r = rg.deflateSetDictionary(this.strm, n)) !== mg) throw new Error(tv[r]); this._dict_set = !0; }
    } function kg(e, t) { const r = new wg(t); if (r.push(e, !0), r.err) throw r.msg || tv[r.err]; return r.result; }wg.prototype.push = function (e, t) { let r; let n; const i = this.strm; const a = this.options.chunkSize; if (this.ended) return !1; for (n = t === ~~t ? t : !0 === t ? pg : hg, typeof e === 'string' ? i.input = ug.string2buf(e) : cg.call(e) === '[object ArrayBuffer]' ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length; ;) if (i.avail_out === 0 && (i.output = new Uint8Array(a), i.next_out = 0, i.avail_out = a), (n === fg || n === dg) && i.avail_out <= 6) this.onData(i.output.subarray(0, i.next_out)), i.avail_out = 0; else { if ((r = rg.deflate(i, n)) === vg) return i.next_out > 0 && this.onData(i.output.subarray(0, i.next_out)), r = rg.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === mg; if (i.avail_out !== 0) { if (n > 0 && i.next_out > 0) this.onData(i.output.subarray(0, i.next_out)), i.avail_out = 0; else if (i.avail_in === 0) break; } else this.onData(i.output); } return !0; }, wg.prototype.onData = function (e) { this.chunks.push(e); }, wg.prototype.onEnd = function (e) { e === mg && (this.result = ig.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg; }; const xg = {
      Deflate: wg, deflate: kg, deflateRaw(e, t) { return (t = t || {}).raw = !0, kg(e, t); }, gzip(e, t) { return (t = t || {}).gzip = !0, kg(e, t); }, constants: rv,
    }; const _g = 16209; const Sg = function (e, t) { let r; let n; let i; let a; let o; let s; let u; let l; let c; let h; let f; let d; let p; let m; let v; let g; let y; let b; let w; let k; let x; let _; let S; let M; const E = e.state; r = e.next_in, S = e.input, n = r + (e.avail_in - 5), i = e.next_out, M = e.output, a = i - (t - e.avail_out), o = i + (e.avail_out - 257), s = E.dmax, u = E.wsize, l = E.whave, c = E.wnext, h = E.window, f = E.hold, d = E.bits, p = E.lencode, m = E.distcode, v = (1 << E.lenbits) - 1, g = (1 << E.distbits) - 1; e:do { d < 15 && (f += S[r++] << d, d += 8, f += S[r++] << d, d += 8), y = p[f & v]; for (;;) { if (f >>>= b = y >>> 24, d -= b, (b = y >>> 16 & 255) === 0)M[i++] = 65535 & y; else { if (!(16 & b)) { if ((64 & b) === 0) { y = p[(65535 & y) + (f & (1 << b) - 1)]; continue; } if (32 & b) { E.mode = 16191; break e; }e.msg = 'invalid literal/length code', E.mode = _g; break e; }w = 65535 & y, (b &= 15) && (d < b && (f += S[r++] << d, d += 8), w += f & (1 << b) - 1, f >>>= b, d -= b), d < 15 && (f += S[r++] << d, d += 8, f += S[r++] << d, d += 8), y = m[f & g]; for (;;) { if (f >>>= b = y >>> 24, d -= b, !(16 & (b = y >>> 16 & 255))) { if ((64 & b) === 0) { y = m[(65535 & y) + (f & (1 << b) - 1)]; continue; }e.msg = 'invalid distance code', E.mode = _g; break e; } if (k = 65535 & y, d < (b &= 15) && (f += S[r++] << d, (d += 8) < b && (f += S[r++] << d, d += 8)), (k += f & (1 << b) - 1) > s) { e.msg = 'invalid distance too far back', E.mode = _g; break e; } if (f >>>= b, d -= b, k > (b = i - a)) { if ((b = k - b) > l && E.sane) { e.msg = 'invalid distance too far back', E.mode = _g; break e; } if (x = 0, _ = h, c === 0) { if (x += u - b, b < w) { w -= b; do { M[i++] = h[x++]; } while (--b); x = i - k, _ = M; } } else if (c < b) { if (x += u + c - b, (b -= c) < w) { w -= b; do { M[i++] = h[x++]; } while (--b); if (x = 0, c < w) { w -= b = c; do { M[i++] = h[x++]; } while (--b); x = i - k, _ = M; } } } else if (x += c - b, b < w) { w -= b; do { M[i++] = h[x++]; } while (--b); x = i - k, _ = M; } for (;w > 2;)M[i++] = _[x++], M[i++] = _[x++], M[i++] = _[x++], w -= 3; w && (M[i++] = _[x++], w > 1 && (M[i++] = _[x++])); } else { x = i - k; do { M[i++] = M[x++], M[i++] = M[x++], M[i++] = M[x++], w -= 3; } while (w > 2); w && (M[i++] = M[x++], w > 1 && (M[i++] = M[x++])); } break; } } break; } } while (r < n && i < o); r -= w = d >> 3, f &= (1 << (d -= w << 3)) - 1, e.next_in = r, e.next_out = i, e.avail_in = r < n ? n - r + 5 : 5 - (r - n), e.avail_out = i < o ? o - i + 257 : 257 - (i - o), E.hold = f, E.bits = d; }; const Mg = 15; const Eg = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]); const Cg = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]); const Pg = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]); const Ag = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]); const Tg = function (e, t, r, n, i, a, o, s) { let u; let l; let c; let h; let f; let d; let p; let m; let v; const g = s.bits; let y = 0; let b = 0; let w = 0; let k = 0; let x = 0; let _ = 0; let S = 0; let M = 0; let E = 0; let C = 0; let P = null; const A = new Uint16Array(16); const T = new Uint16Array(16); let R = null; for (y = 0; y <= Mg; y++)A[y] = 0; for (b = 0; b < n; b++)A[t[r + b]]++; for (x = g, k = Mg; k >= 1 && A[k] === 0; k--);if (x > k && (x = k), k === 0) return i[a++] = 20971520, i[a++] = 20971520, s.bits = 1, 0; for (w = 1; w < k && A[w] === 0; w++);for (x < w && (x = w), M = 1, y = 1; y <= Mg; y++) if (M <<= 1, (M -= A[y]) < 0) return -1; if (M > 0 && (e === 0 || k !== 1)) return -1; for (T[1] = 0, y = 1; y < Mg; y++)T[y + 1] = T[y] + A[y]; for (b = 0; b < n; b++)t[r + b] !== 0 && (o[T[t[r + b]]++] = b); if (e === 0 ? (P = R = o, d = 20) : e === 1 ? (P = Eg, R = Cg, d = 257) : (P = Pg, R = Ag, d = 0), C = 0, b = 0, y = w, f = a, _ = x, S = 0, c = -1, h = (E = 1 << x) - 1, e === 1 && E > 852 || e === 2 && E > 592) return 1; for (;;) { p = y - S, o[b] + 1 < d ? (m = 0, v = o[b]) : o[b] >= d ? (m = R[o[b] - d], v = P[o[b] - d]) : (m = 96, v = 0), u = 1 << y - S, w = l = 1 << _; do { i[f + (C >> S) + (l -= u)] = p << 24 | m << 16 | v | 0; } while (l !== 0); for (u = 1 << y - 1; C & u;)u >>= 1; if (u !== 0 ? (C &= u - 1, C += u) : C = 0, b++, --A[y] === 0) { if (y === k) break; y = t[r + o[b]]; } if (y > x && (C & h) !== c) { for (S === 0 && (S = x), f += w, M = 1 << (_ = y - S); _ + S < k && !((M -= A[_ + S]) <= 0);)_++, M <<= 1; if (E += 1 << _, e === 1 && E > 852 || e === 2 && E > 592) return 1; i[c = C & h] = x << 24 | _ << 16 | f - a | 0; } } return C !== 0 && (i[f + C] = y - S << 24 | 64 << 16 | 0), s.bits = x, 0; }; const Rg = rv.Z_FINISH; const Ig = rv.Z_BLOCK; const Og = rv.Z_TREES; const Dg = rv.Z_OK; const zg = rv.Z_STREAM_END; const Ng = rv.Z_NEED_DICT; const Lg = rv.Z_STREAM_ERROR; const jg = rv.Z_DATA_ERROR; const Fg = rv.Z_MEM_ERROR; const Bg = rv.Z_BUF_ERROR; const Ug = rv.Z_DEFLATED; const Vg = 16180; const Yg = 16190; const Hg = 16191; const qg = 16192; const Wg = 16194; const Xg = 16199; const Gg = 16200; const $g = 16206; const Zg = 16209; const Kg = function (e) { return (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24); }; function Qg() { this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0; } let Jg; let ey; const ty = function (e) { if (!e) return 1; const t = e.state; return !t || t.strm !== e || t.mode < Vg || t.mode > 16211 ? 1 : 0; }; const ry = function (e) { if (ty(e)) return Lg; const t = e.state; return e.total_in = e.total_out = t.total = 0, e.msg = '', t.wrap && (e.adler = 1 & t.wrap), t.mode = Vg, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(852), t.distcode = t.distdyn = new Int32Array(592), t.sane = 1, t.back = -1, Dg; }; const ny = function (e) { if (ty(e)) return Lg; const t = e.state; return t.wsize = 0, t.whave = 0, t.wnext = 0, ry(e); }; const iy = function (e, t) { let r; if (ty(e)) return Lg; const n = e.state; return t < 0 ? (r = 0, t = -t) : (r = 5 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Lg : (n.window !== null && n.wbits !== t && (n.window = null), n.wrap = r, n.wbits = t, ny(e)); }; const ay = function (e, t) { if (!e) return Lg; const r = new Qg(); e.state = r, r.strm = e, r.window = null, r.mode = Vg; const n = iy(e, t); return n !== Dg && (e.state = null), n; }; let oy = !0; const sy = function (e) { if (oy) { Jg = new Int32Array(512), ey = new Int32Array(32); for (var t = 0; t < 144;)e.lens[t++] = 8; for (;t < 256;)e.lens[t++] = 9; for (;t < 280;)e.lens[t++] = 7; for (;t < 288;)e.lens[t++] = 8; for (Tg(1, e.lens, 0, 288, Jg, 0, e.work, { bits: 9 }), t = 0; t < 32;)e.lens[t++] = 5; Tg(2, e.lens, 0, 32, ey, 0, e.work, { bits: 5 }), oy = !1; }e.lencode = Jg, e.lenbits = 9, e.distcode = ey, e.distbits = 5; }; const uy = function (e, t, r, n) { let i; const a = e.state; return a.window === null && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new Uint8Array(a.wsize)), n >= a.wsize ? (a.window.set(t.subarray(r - a.wsize, r), 0), a.wnext = 0, a.whave = a.wsize) : ((i = a.wsize - a.wnext) > n && (i = n), a.window.set(t.subarray(r - n, r - n + i), a.wnext), (n -= i) ? (a.window.set(t.subarray(r - n, r), 0), a.wnext = n, a.whave = a.wsize) : (a.wnext += i, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += i))), 0; }; const ly = function (e, t) { let r; let n; let i; let a; let o; let s; let u; let l; let c; let h; let f; let d; let p; let m; let v; let g; let y; let b; let w; let k; let x; let _; let S; let M; let E = 0; const C = new Uint8Array(4); const P = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); if (ty(e) || !e.output || !e.input && e.avail_in !== 0) return Lg; (r = e.state).mode === Hg && (r.mode = qg), o = e.next_out, i = e.output, u = e.avail_out, a = e.next_in, n = e.input, s = e.avail_in, l = r.hold, c = r.bits, h = s, f = u, _ = Dg; e:for (;;) switch (r.mode) { case Vg: if (r.wrap === 0) { r.mode = qg; break; } for (;c < 16;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; } if (2 & r.wrap && l === 35615) { r.wbits === 0 && (r.wbits = 15), r.check = 0, C[0] = 255 & l, C[1] = l >>> 8 & 255, r.check = ev(r.check, C, 2, 0), l = 0, c = 0, r.mode = 16181; break; } if (r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & l) << 8) + (l >> 8)) % 31) { e.msg = 'incorrect header check', r.mode = Zg; break; } if ((15 & l) !== Ug) { e.msg = 'unknown compression method', r.mode = Zg; break; } if (c -= 4, x = 8 + (15 & (l >>>= 4)), r.wbits === 0 && (r.wbits = x), x > 15 || x > r.wbits) { e.msg = 'invalid window size', r.mode = Zg; break; }r.dmax = 1 << r.wbits, r.flags = 0, e.adler = r.check = 1, r.mode = 512 & l ? 16189 : Hg, l = 0, c = 0; break; case 16181: for (;c < 16;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; } if (r.flags = l, (255 & r.flags) !== Ug) { e.msg = 'unknown compression method', r.mode = Zg; break; } if (57344 & r.flags) { e.msg = 'unknown header flags set', r.mode = Zg; break; }r.head && (r.head.text = l >> 8 & 1), 512 & r.flags && 4 & r.wrap && (C[0] = 255 & l, C[1] = l >>> 8 & 255, r.check = ev(r.check, C, 2, 0)), l = 0, c = 0, r.mode = 16182; case 16182: for (;c < 32;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; }r.head && (r.head.time = l), 512 & r.flags && 4 & r.wrap && (C[0] = 255 & l, C[1] = l >>> 8 & 255, C[2] = l >>> 16 & 255, C[3] = l >>> 24 & 255, r.check = ev(r.check, C, 4, 0)), l = 0, c = 0, r.mode = 16183; case 16183: for (;c < 16;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; }r.head && (r.head.xflags = 255 & l, r.head.os = l >> 8), 512 & r.flags && 4 & r.wrap && (C[0] = 255 & l, C[1] = l >>> 8 & 255, r.check = ev(r.check, C, 2, 0)), l = 0, c = 0, r.mode = 16184; case 16184: if (1024 & r.flags) { for (;c < 16;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; }r.length = l, r.head && (r.head.extra_len = l), 512 & r.flags && 4 & r.wrap && (C[0] = 255 & l, C[1] = l >>> 8 & 255, r.check = ev(r.check, C, 2, 0)), l = 0, c = 0; } else r.head && (r.head.extra = null); r.mode = 16185; case 16185: if (1024 & r.flags && ((d = r.length) > s && (d = s), d && (r.head && (x = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Uint8Array(r.head.extra_len)), r.head.extra.set(n.subarray(a, a + d), x)), 512 & r.flags && 4 & r.wrap && (r.check = ev(r.check, n, d, a)), s -= d, a += d, r.length -= d), r.length)) break e; r.length = 0, r.mode = 16186; case 16186: if (2048 & r.flags) { if (s === 0) break e; d = 0; do { x = n[a + d++], r.head && x && r.length < 65536 && (r.head.name += String.fromCharCode(x)); } while (x && d < s); if (512 & r.flags && 4 & r.wrap && (r.check = ev(r.check, n, d, a)), s -= d, a += d, x) break e; } else r.head && (r.head.name = null); r.length = 0, r.mode = 16187; case 16187: if (4096 & r.flags) { if (s === 0) break e; d = 0; do { x = n[a + d++], r.head && x && r.length < 65536 && (r.head.comment += String.fromCharCode(x)); } while (x && d < s); if (512 & r.flags && 4 & r.wrap && (r.check = ev(r.check, n, d, a)), s -= d, a += d, x) break e; } else r.head && (r.head.comment = null); r.mode = 16188; case 16188: if (512 & r.flags) { for (;c < 16;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; } if (4 & r.wrap && l !== (65535 & r.check)) { e.msg = 'header crc mismatch', r.mode = Zg; break; }l = 0, c = 0; }r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), e.adler = r.check = 0, r.mode = Hg; break; case 16189: for (;c < 32;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; }e.adler = r.check = Kg(l), l = 0, c = 0, r.mode = Yg; case Yg: if (r.havedict === 0) return e.next_out = o, e.avail_out = u, e.next_in = a, e.avail_in = s, r.hold = l, r.bits = c, Ng; e.adler = r.check = 1, r.mode = Hg; case Hg: if (t === Ig || t === Og) break e; case qg: if (r.last) { l >>>= 7 & c, c -= 7 & c, r.mode = $g; break; } for (;c < 3;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; } switch (r.last = 1 & l, c -= 1, 3 & (l >>>= 1)) { case 0: r.mode = 16193; break; case 1: if (sy(r), r.mode = Xg, t === Og) { l >>>= 2, c -= 2; break e; } break; case 2: r.mode = 16196; break; case 3: e.msg = 'invalid block type', r.mode = Zg; }l >>>= 2, c -= 2; break; case 16193: for (l >>>= 7 & c, c -= 7 & c; c < 32;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; } if ((65535 & l) !== (l >>> 16 ^ 65535)) { e.msg = 'invalid stored block lengths', r.mode = Zg; break; } if (r.length = 65535 & l, l = 0, c = 0, r.mode = Wg, t === Og) break e; case Wg: r.mode = 16195; case 16195: if (d = r.length) { if (d > s && (d = s), d > u && (d = u), d === 0) break e; i.set(n.subarray(a, a + d), o), s -= d, a += d, u -= d, o += d, r.length -= d; break; }r.mode = Hg; break; case 16196: for (;c < 14;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; } if (r.nlen = 257 + (31 & l), l >>>= 5, c -= 5, r.ndist = 1 + (31 & l), l >>>= 5, c -= 5, r.ncode = 4 + (15 & l), l >>>= 4, c -= 4, r.nlen > 286 || r.ndist > 30) { e.msg = 'too many length or distance symbols', r.mode = Zg; break; }r.have = 0, r.mode = 16197; case 16197: for (;r.have < r.ncode;) { for (;c < 3;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; }r.lens[P[r.have++]] = 7 & l, l >>>= 3, c -= 3; } for (;r.have < 19;)r.lens[P[r.have++]] = 0; if (r.lencode = r.lendyn, r.lenbits = 7, S = { bits: r.lenbits }, _ = Tg(0, r.lens, 0, 19, r.lencode, 0, r.work, S), r.lenbits = S.bits, _) { e.msg = 'invalid code lengths set', r.mode = Zg; break; }r.have = 0, r.mode = 16198; case 16198: for (;r.have < r.nlen + r.ndist;) { for (;g = (E = r.lencode[l & (1 << r.lenbits) - 1]) >>> 16 & 255, y = 65535 & E, !((v = E >>> 24) <= c);) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; } if (y < 16)l >>>= v, c -= v, r.lens[r.have++] = y; else { if (y === 16) { for (M = v + 2; c < M;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; } if (l >>>= v, c -= v, r.have === 0) { e.msg = 'invalid bit length repeat', r.mode = Zg; break; }x = r.lens[r.have - 1], d = 3 + (3 & l), l >>>= 2, c -= 2; } else if (y === 17) { for (M = v + 3; c < M;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; }c -= v, x = 0, d = 3 + (7 & (l >>>= v)), l >>>= 3, c -= 3; } else { for (M = v + 7; c < M;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; }c -= v, x = 0, d = 11 + (127 & (l >>>= v)), l >>>= 7, c -= 7; } if (r.have + d > r.nlen + r.ndist) { e.msg = 'invalid bit length repeat', r.mode = Zg; break; } for (;d--;)r.lens[r.have++] = x; } } if (r.mode === Zg) break; if (r.lens[256] === 0) { e.msg = 'invalid code -- missing end-of-block', r.mode = Zg; break; } if (r.lenbits = 9, S = { bits: r.lenbits }, _ = Tg(1, r.lens, 0, r.nlen, r.lencode, 0, r.work, S), r.lenbits = S.bits, _) { e.msg = 'invalid literal/lengths set', r.mode = Zg; break; } if (r.distbits = 6, r.distcode = r.distdyn, S = { bits: r.distbits }, _ = Tg(2, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, S), r.distbits = S.bits, _) { e.msg = 'invalid distances set', r.mode = Zg; break; } if (r.mode = Xg, t === Og) break e; case Xg: r.mode = Gg; case Gg: if (s >= 6 && u >= 258) { e.next_out = o, e.avail_out = u, e.next_in = a, e.avail_in = s, r.hold = l, r.bits = c, Sg(e, f), o = e.next_out, i = e.output, u = e.avail_out, a = e.next_in, n = e.input, s = e.avail_in, l = r.hold, c = r.bits, r.mode === Hg && (r.back = -1); break; } for (r.back = 0; g = (E = r.lencode[l & (1 << r.lenbits) - 1]) >>> 16 & 255, y = 65535 & E, !((v = E >>> 24) <= c);) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; } if (g && (240 & g) === 0) { for (b = v, w = g, k = y; g = (E = r.lencode[k + ((l & (1 << b + w) - 1) >> b)]) >>> 16 & 255, y = 65535 & E, !(b + (v = E >>> 24) <= c);) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; }l >>>= b, c -= b, r.back += b; } if (l >>>= v, c -= v, r.back += v, r.length = y, g === 0) { r.mode = 16205; break; } if (32 & g) { r.back = -1, r.mode = Hg; break; } if (64 & g) { e.msg = 'invalid literal/length code', r.mode = Zg; break; }r.extra = 15 & g, r.mode = 16201; case 16201: if (r.extra) { for (M = r.extra; c < M;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; }r.length += l & (1 << r.extra) - 1, l >>>= r.extra, c -= r.extra, r.back += r.extra; }r.was = r.length, r.mode = 16202; case 16202: for (;g = (E = r.distcode[l & (1 << r.distbits) - 1]) >>> 16 & 255, y = 65535 & E, !((v = E >>> 24) <= c);) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; } if ((240 & g) === 0) { for (b = v, w = g, k = y; g = (E = r.distcode[k + ((l & (1 << b + w) - 1) >> b)]) >>> 16 & 255, y = 65535 & E, !(b + (v = E >>> 24) <= c);) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; }l >>>= b, c -= b, r.back += b; } if (l >>>= v, c -= v, r.back += v, 64 & g) { e.msg = 'invalid distance code', r.mode = Zg; break; }r.offset = y, r.extra = 15 & g, r.mode = 16203; case 16203: if (r.extra) { for (M = r.extra; c < M;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; }r.offset += l & (1 << r.extra) - 1, l >>>= r.extra, c -= r.extra, r.back += r.extra; } if (r.offset > r.dmax) { e.msg = 'invalid distance too far back', r.mode = Zg; break; }r.mode = 16204; case 16204: if (u === 0) break e; if (d = f - u, r.offset > d) { if ((d = r.offset - d) > r.whave && r.sane) { e.msg = 'invalid distance too far back', r.mode = Zg; break; }d > r.wnext ? (d -= r.wnext, p = r.wsize - d) : p = r.wnext - d, d > r.length && (d = r.length), m = r.window; } else m = i, p = o - r.offset, d = r.length; d > u && (d = u), u -= d, r.length -= d; do { i[o++] = m[p++]; } while (--d); r.length === 0 && (r.mode = Gg); break; case 16205: if (u === 0) break e; i[o++] = r.length, u--, r.mode = Gg; break; case $g: if (r.wrap) { for (;c < 32;) { if (s === 0) break e; s--, l |= n[a++] << c, c += 8; } if (f -= u, e.total_out += f, r.total += f, 4 & r.wrap && f && (e.adler = r.check = r.flags ? ev(r.check, i, f, o - f) : Qm(r.check, i, f, o - f)), f = u, 4 & r.wrap && (r.flags ? l : Kg(l)) !== r.check) { e.msg = 'incorrect data check', r.mode = Zg; break; }l = 0, c = 0; }r.mode = 16207; case 16207: if (r.wrap && r.flags) { for (;c < 32;) { if (s === 0) break e; s--, l += n[a++] << c, c += 8; } if (4 & r.wrap && l !== (4294967295 & r.total)) { e.msg = 'incorrect length check', r.mode = Zg; break; }l = 0, c = 0; }r.mode = 16208; case 16208: _ = zg; break e; case Zg: _ = jg; break e; case 16210: return Fg; default: return Lg; } return e.next_out = o, e.avail_out = u, e.next_in = a, e.avail_in = s, r.hold = l, r.bits = c, (r.wsize || f !== e.avail_out && r.mode < Zg && (r.mode < $g || t !== Rg)) && uy(e, e.output, e.next_out, f - e.avail_out), h -= e.avail_in, f -= e.avail_out, e.total_in += h, e.total_out += f, r.total += f, 4 & r.wrap && f && (e.adler = r.check = r.flags ? ev(r.check, i, f, e.next_out - f) : Qm(r.check, i, f, e.next_out - f)), e.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === Hg ? 128 : 0) + (r.mode === Xg || r.mode === Wg ? 256 : 0), (h === 0 && f === 0 || t === Rg) && _ === Dg && (_ = Bg), _; }; const cy = {
      inflateReset: ny, inflateReset2: iy, inflateResetKeep: ry, inflateInit(e) { return ay(e, 15); }, inflateInit2: ay, inflate: ly, inflateEnd(e) { if (ty(e)) return Lg; const t = e.state; return t.window && (t.window = null), e.state = null, Dg; }, inflateGetHeader(e, t) { if (ty(e)) return Lg; const r = e.state; return (2 & r.wrap) === 0 ? Lg : (r.head = t, t.done = !1, Dg); }, inflateSetDictionary(e, t) { let r; const n = t.length; return ty(e) || (r = e.state).wrap !== 0 && r.mode !== Yg ? Lg : r.mode === Yg && Qm(1, t, n, 0) !== r.check ? jg : uy(e, t, n, n) ? (r.mode = 16210, Fg) : (r.havedict = 1, Dg); }, inflateInfo: 'pako inflate (from Nodeca project)',
    }; const hy = function () { this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = '', this.comment = '', this.hcrc = 0, this.done = !1; }; const fy = Object.prototype.toString; const dy = rv.Z_NO_FLUSH; const py = rv.Z_FINISH; const my = rv.Z_OK; const vy = rv.Z_STREAM_END; const gy = rv.Z_NEED_DICT; const yy = rv.Z_STREAM_ERROR; const by = rv.Z_DATA_ERROR; const wy = rv.Z_MEM_ERROR; function ky(e) { this.options = ig.assign({ chunkSize: 65536, windowBits: 15, to: '' }, e || {}); const t = this.options; t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (15 & t.windowBits) === 0 && (t.windowBits |= 15), this.err = 0, this.msg = '', this.ended = !1, this.chunks = [], this.strm = new lg(), this.strm.avail_out = 0; let r = cy.inflateInit2(this.strm, t.windowBits); if (r !== my) throw new Error(tv[r]); if (this.header = new hy(), cy.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary === 'string' ? t.dictionary = ug.string2buf(t.dictionary) : fy.call(t.dictionary) === '[object ArrayBuffer]' && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (r = cy.inflateSetDictionary(this.strm, t.dictionary)) !== my)) throw new Error(tv[r]); } function xy(e, t) { const r = new ky(t); if (r.push(e), r.err) throw r.msg || tv[r.err]; return r.result; }ky.prototype.push = function (e, t) { let r; let n; let i; const a = this.strm; const o = this.options.chunkSize; const s = this.options.dictionary; if (this.ended) return !1; for (n = t === ~~t ? t : !0 === t ? py : dy, fy.call(e) === '[object ArrayBuffer]' ? a.input = new Uint8Array(e) : a.input = e, a.next_in = 0, a.avail_in = a.input.length; ;) { for (a.avail_out === 0 && (a.output = new Uint8Array(o), a.next_out = 0, a.avail_out = o), (r = cy.inflate(a, n)) === gy && s && ((r = cy.inflateSetDictionary(a, s)) === my ? r = cy.inflate(a, n) : r === by && (r = gy)); a.avail_in > 0 && r === vy && a.state.wrap > 0 && e[a.next_in] !== 0;)cy.inflateReset(a), r = cy.inflate(a, n); switch (r) { case yy: case by: case gy: case wy: return this.onEnd(r), this.ended = !0, !1; } if (i = a.avail_out, a.next_out && (a.avail_out === 0 || r === vy)) if (this.options.to === 'string') { const u = ug.utf8border(a.output, a.next_out); const l = a.next_out - u; const c = ug.buf2string(a.output, u); a.next_out = l, a.avail_out = o - l, l && a.output.set(a.output.subarray(u, u + l), 0), this.onData(c); } else this.onData(a.output.length === a.next_out ? a.output : a.output.subarray(0, a.next_out)); if (r !== my || i !== 0) { if (r === vy) return r = cy.inflateEnd(this.strm), this.onEnd(r), this.ended = !0, !0; if (a.avail_in === 0) break; } } return !0; }, ky.prototype.onData = function (e) { this.chunks.push(e); }, ky.prototype.onEnd = function (e) { e === my && (this.options.to === 'string' ? this.result = this.chunks.join('') : this.result = ig.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg; }; for (var _y = {
        Inflate: ky, inflate: xy, inflateRaw(e, t) { return (t = t || {}).raw = !0, xy(e, t); }, ungzip: xy, constants: rv,
      }, Sy = xg.deflate, My = _y.Inflate, Ey = _y.inflate, Cy = [137, 80, 78, 71, 13, 10, 26, 10], Py = [], Ay = 0; Ay < 256; Ay++) { for (var Ty = Ay, Ry = 0; Ry < 8; Ry++)1 & Ty ? Ty = 3988292384 ^ Ty >>> 1 : Ty >>>= 1; Py[Ay] = Ty; } let Iy; let Oy; let Dy; let zy; const Ny = 4294967295; function Ly(e, t) { return ((function (e, t, r) { for (var n = e, i = 0; i < r; i++)n = Py[255 & (n ^ t[i])] ^ n >>> 8; return n; }(Ny, e, t)) ^ Ny) >>> 0; }!(function (e) { e[e.UNKNOWN = -1] = 'UNKNOWN', e[e.GREYSCALE = 0] = 'GREYSCALE', e[e.TRUECOLOUR = 2] = 'TRUECOLOUR', e[e.INDEXED_COLOUR = 3] = 'INDEXED_COLOUR', e[e.GREYSCALE_ALPHA = 4] = 'GREYSCALE_ALPHA', e[e.TRUECOLOUR_ALPHA = 6] = 'TRUECOLOUR_ALPHA'; }(Iy || (Iy = {}))), (function (e) { e[e.UNKNOWN = -1] = 'UNKNOWN', e[e.DEFLATE = 0] = 'DEFLATE'; }(Oy || (Oy = {}))), (function (e) { e[e.UNKNOWN = -1] = 'UNKNOWN', e[e.ADAPTIVE = 0] = 'ADAPTIVE'; }(Dy || (Dy = {}))), (function (e) { e[e.UNKNOWN = -1] = 'UNKNOWN', e[e.NO_INTERLACE = 0] = 'NO_INTERLACE', e[e.ADAM7 = 1] = 'ADAM7'; }(zy || (zy = {}))); const jy = new Uint8Array(0); const Fy = new Uint16Array([255]); const By = new Uint8Array(Fy.buffer)[0] === 255; const Uy = (function (e) {
      x(r, e); const t = C(r); function r(e) {
        let n; const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; (0, w.Z)(this, r), n = t.call(this, e); const a = i.checkCrc; const o = void 0 !== a && a; return n._checkCrc = o, n._inflator = new My(), n._png = {
          width: -1, height: -1, channels: -1, data: new Uint8Array(0), depth: 1, text: {},
        }, n._end = !1, n._hasPalette = !1, n._palette = [], n._hasTransparency = !1, n._transparency = new Uint16Array(0), n._compressionMethod = Oy.UNKNOWN, n._filterMethod = Dy.UNKNOWN, n._interlaceMethod = zy.UNKNOWN, n._colorType = Iy.UNKNOWN, n.setBigEndian(), n;
      } return (0, b.Z)(r, [{ key: 'decode', value() { for (this.decodeSignature(); !this._end;) this.decodeChunk(); return this.decodeImage(), this._png; } }, { key: 'decodeSignature', value() { for (let e = 0; e < Cy.length; e++) if (this.readUint8() !== Cy[e]) throw new Error('wrong PNG signature. Byte at '.concat(e, ' should be ').concat(Cy[e], '.')); } }, { key: 'decodeChunk', value() { const e = this.readUint32(); const t = this.readChars(4); const r = this.offset; switch (t) { case 'IHDR': this.decodeIHDR(); break; case 'PLTE': this.decodePLTE(e); break; case 'IDAT': this.decodeIDAT(e); break; case 'IEND': this._end = !0; break; case 'tRNS': this.decodetRNS(e); break; case 'iCCP': this.decodeiCCP(e); break; case 'tEXt': this.decodetEXt(e); break; case 'pHYs': this.decodepHYs(); break; default: this.skip(e); } if (this.offset - r !== e) throw new Error('Length mismatch while decoding chunk '.concat(t)); if (this._checkCrc) { const n = this.readUint32(); const i = e + 4; const a = Ly(new Uint8Array(this.buffer, this.byteOffset + this.offset - i - 4, i), i); if (a !== n) throw new Error('CRC mismatch for chunk '.concat(t, '. Expected ').concat(n, ', found ').concat(a)); } else this.skip(4); } }, { key: 'decodeIHDR', value() { const e = this._png; e.width = this.readUint32(), e.height = this.readUint32(), e.depth = (function (e) { if (e !== 1 && e !== 2 && e !== 4 && e !== 8 && e !== 16) throw new Error('invalid bit depth: '.concat(e)); return e; }(this.readUint8())); let t; const r = this.readUint8(); switch (this._colorType = r, r) { case Iy.GREYSCALE: t = 1; break; case Iy.TRUECOLOUR: t = 3; break; case Iy.INDEXED_COLOUR: t = 1; break; case Iy.GREYSCALE_ALPHA: t = 2; break; case Iy.TRUECOLOUR_ALPHA: t = 4; break; default: throw new Error('Unknown color type: '.concat(r)); } if (this._png.channels = t, this._compressionMethod = this.readUint8(), this._compressionMethod !== Oy.DEFLATE) throw new Error('Unsupported compression method: '.concat(this._compressionMethod)); this._filterMethod = this.readUint8(), this._interlaceMethod = this.readUint8(); } }, { key: 'decodePLTE', value(e) { if (e % 3 !== 0) throw new RangeError('PLTE field length must be a multiple of 3. Got '.concat(e)); const t = e / 3; this._hasPalette = !0; const r = []; this._palette = r; for (let n = 0; n < t; n++)r.push([this.readUint8(), this.readUint8(), this.readUint8()]); } }, { key: 'decodeIDAT', value(e) { this._inflator.push(new Uint8Array(this.buffer, this.offset + this.byteOffset, e)), this.skip(e); } }, { key: 'decodetRNS', value(e) { switch (this._colorType) { case Iy.GREYSCALE: case Iy.TRUECOLOUR: if (e % 2 !== 0) throw new RangeError('tRNS chunk length must be a multiple of 2. Got '.concat(e)); if (e / 2 > this._png.width * this._png.height) throw new Error('tRNS chunk contains more alpha values than there are pixels ('.concat(e / 2, ' vs ').concat(this._png.width * this._png.height, ')')); this._hasTransparency = !0, this._transparency = new Uint16Array(e / 2); for (let t = 0; t < e / 2; t++) this._transparency[t] = this.readUint16(); break; case Iy.INDEXED_COLOUR: if (e > this._palette.length) throw new Error('tRNS chunk contains more alpha values than there are palette colors ('.concat(e, ' vs ').concat(this._palette.length, ')')); for (var r = 0; r < e; r++) { const n = this.readByte(); this._palette[r].push(n); } for (;r < this._palette.length; r++) this._palette[r].push(255); break; default: throw new Error('tRNS chunk is not supported for color type '.concat(this._colorType)); } } }, { key: 'decodeiCCP', value(e) { for (var t, r = ''; (t = this.readChar()) !== '\0';)r += t; const n = this.readUint8(); if (n !== Oy.DEFLATE) throw new Error('Unsupported iCCP compression method: '.concat(n)); const i = this.readBytes(e - r.length - 2); this._png.iccEmbeddedProfile = { name: r, profile: Ey(i) }; } }, { key: 'decodetEXt', value(e) { for (var t, r = ''; (t = this.readChar()) !== '\0';)r += t; this._png.text[r] = this.readChars(e - r.length - 1); } }, { key: 'decodepHYs', value() { const e = this.readUint32(); const t = this.readUint32(); const r = this.readByte(); this._png.resolution = { x: e, y: t, unit: r }; } }, { key: 'decodeImage', value() { if (this._inflator.err) throw new Error('Error while decompressing the data: '.concat(this._inflator.err)); const e = this._inflator.result; if (this._filterMethod !== Dy.ADAPTIVE) throw new Error('Filter method '.concat(this._filterMethod, ' not supported')); if (this._interlaceMethod !== zy.NO_INTERLACE) throw new Error('Interlace method '.concat(this._interlaceMethod, ' not supported')); this.decodeInterlaceNull(e); } }, { key: 'decodeInterlaceNull', value(e) { for (var t, r, n, i = this._png.height, a = this._png.channels * this._png.depth / 8, o = this._png.width * a, s = new Uint8Array(this._png.height * o), u = jy, l = 0, c = 0; c < i; c++) { switch (t = e.subarray(l + 1, l + 1 + o), r = s.subarray(c * o, (c + 1) * o), e[l]) { case 0: Vy(t, r, o); break; case 1: Yy(t, r, o, a); break; case 2: Hy(t, r, u, o); break; case 3: qy(t, r, u, o, a); break; case 4: Wy(t, r, u, o, a); break; default: throw new Error('Unsupported filter: '.concat(e[l])); }u = r, l += o + 1; } if (this._hasPalette && (this._png.palette = this._palette), this._hasTransparency && (this._png.transparency = this._transparency), this._png.depth === 16) { const h = new Uint16Array(s.buffer); if (By) for (let f = 0; f < h.length; f++)h[f] = (255 & (n = h[f])) << 8 | n >> 8 & 255; this._png.data = h; } else this._png.data = s; } }]), r;
    }(cm.IOBuffer)); function Vy(e, t, r) { for (let n = 0; n < r; n++)t[n] = e[n]; } function Yy(e, t, r, n) { for (var i = 0; i < n; i++)t[i] = e[i]; for (;i < r; i++)t[i] = e[i] + t[i - n] & 255; } function Hy(e, t, r, n) { let i = 0; if (r.length === 0) for (;i < n; i++)t[i] = e[i]; else for (;i < n; i++)t[i] = e[i] + r[i] & 255; } function qy(e, t, r, n, i) { let a = 0; if (r.length === 0) { for (;a < i; a++)t[a] = e[a]; for (;a < n; a++)t[a] = e[a] + (t[a - i] >> 1) & 255; } else { for (;a < i; a++)t[a] = e[a] + (r[a] >> 1) & 255; for (;a < n; a++)t[a] = e[a] + (t[a - i] + r[a] >> 1) & 255; } } function Wy(e, t, r, n, i) { let a = 0; if (r.length === 0) { for (;a < i; a++)t[a] = e[a]; for (;a < n; a++)t[a] = e[a] + t[a - i] & 255; } else { for (;a < i; a++)t[a] = e[a] + r[a] & 255; for (;a < n; a++)t[a] = e[a] + Xy(t[a - i], r[a], r[a - i]) & 255; } } function Xy(e, t, r) { const n = e + t - r; const i = Math.abs(n - e); const a = Math.abs(n - t); const o = Math.abs(n - r); return i <= a && i <= o ? e : a <= o ? t : r; } let Gy; const $y = { level: 3 }; const Zy = (function (e) {
      x(r, e); const t = C(r); function r(e) { let n; const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return (0, w.Z)(this, r), (n = t.call(this))._colorType = Iy.UNKNOWN, n._zlibOptions = z(z({}, $y), i.zlib), n._png = n._checkData(e), n.setBigEndian(), n; } return (0, b.Z)(r, [{ key: 'encode', value() { return this.encodeSignature(), this.encodeIHDR(), this.encodeData(), this.encodeIEND(), this.toArray(); } }, { key: 'encodeSignature', value() { this.writeBytes(Cy); } }, { key: 'encodeIHDR', value() { this.writeUint32(13), this.writeChars('IHDR'), this.writeUint32(this._png.width), this.writeUint32(this._png.height), this.writeByte(this._png.depth), this.writeByte(this._colorType), this.writeByte(Oy.DEFLATE), this.writeByte(Dy.ADAPTIVE), this.writeByte(zy.NO_INTERLACE), this.writeCrc(17); } }, { key: 'encodeIEND', value() { this.writeUint32(0), this.writeChars('IEND'), this.writeCrc(4); } }, { key: 'encodeIDAT', value(e) { this.writeUint32(e.length), this.writeChars('IDAT'), this.writeBytes(e), this.writeCrc(e.length + 4); } }, { key: 'encodeData', value() { for (var e = this._png, t = e.width, r = e.height, n = e.channels, i = e.depth, a = e.data, o = n * t, s = (new cm.IOBuffer()).setBigEndian(), u = 0, l = 0; l < r; l++) if (s.writeByte(0), i === 8)u = Qy(a, s, o, u); else { if (i !== 16) throw new Error('unreachable'); u = Jy(a, s, o, u); } const c = s.toArray(); const h = Sy(c, this._zlibOptions); this.encodeIDAT(h); } }, {
        key: '_checkData',
        value(e) {
          const t = (function (e) { const t = e.channels; const r = void 0 === t ? 4 : t; const n = e.depth; const i = void 0 === n ? 8 : n; if (r !== 4 && r !== 3 && r !== 2 && r !== 1) throw new RangeError('unsupported number of channels: '.concat(r)); if (i !== 8 && i !== 16) throw new RangeError('unsupported bit depth: '.concat(i)); const a = { channels: r, depth: i, colorType: Iy.UNKNOWN }; switch (r) { case 4: a.colorType = Iy.TRUECOLOUR_ALPHA; break; case 3: a.colorType = Iy.TRUECOLOUR; break; case 1: a.colorType = Iy.GREYSCALE; break; case 2: a.colorType = Iy.GREYSCALE_ALPHA; break; default: throw new Error('unsupported number of channels'); } return a; }(e)); const r = t.colorType; const n = t.channels; const i = t.depth; const a = {
            width: Ky(e.width, 'width'), height: Ky(e.height, 'height'), channels: n, data: e.data, depth: i, text: {},
          }; this._colorType = r; const o = a.width * a.height * n; if (a.data.length !== o) throw new RangeError('wrong data size. Found '.concat(a.data.length, ', expected ').concat(o)); return a;
        },
      }, { key: 'writeCrc', value(e) { this.writeUint32(Ly(new Uint8Array(this.buffer, this.byteOffset + this.offset - e, e), e)); } }]), r;
    }(cm.IOBuffer)); function Ky(e, t) { if (Number.isInteger(e) && e > 0) return e; throw new TypeError(''.concat(t, ' must be a positive integer')); } function Qy(e, t, r, n) { for (let i = 0; i < r; i++)t.writeByte(e[n++]); return n; } function Jy(e, t, r, n) { for (let i = 0; i < r; i++)t.writeUint16(e[n++]); return n; }!(function (e) { e[e.UNKNOWN = 0] = 'UNKNOWN', e[e.METRE = 1] = 'METRE'; }(Gy || (Gy = {}))); for (var eb = __webpack_require__(1684), tb = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', rb = new Uint8Array(256), nb = 0; nb < tb.length; nb++)rb[tb.charCodeAt(nb)] = nb; function ib(e, t) { const r = (function (e) { let t; const r = e.length; let n = ''; for (t = 0; t < r; t += 3)n += tb[e[t] >> 2], n += tb[(3 & e[t]) << 4 | e[t + 1] >> 4], n += tb[(15 & e[t + 1]) << 2 | e[t + 2] >> 6], n += tb[63 & e[t + 2]]; return r % 3 === 2 ? n = ''.concat(n.substring(0, n.length - 1), '=') : r % 3 === 1 && (n = ''.concat(n.substring(0, n.length - 2), '==')), n; }(e)); return 'data:'.concat(t, ';base64,').concat(r); } const ab = self.ImageData; const ob = self.Image; function sb(e, t) { const r = self.document.createElement('canvas'); return r.width = e, r.height = t, r; } function ub(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = { width: e.width, height: e.height, data: e.getRGBAData() }; return (0, eb.encode)(r, t.quality).data; } function lb(e, t) {
      const r = {
        width: e.width, height: e.height, channels: e.channels, depth: e.bitDepth, data: e.data,
      }; return r.depth !== 1 && r.depth !== 32 || (r.depth = 8, r.channels = 4, r.data = e.getRGBAData()), (function (e, t) { return new Zy(e, t).encode(); }(r, t));
    } const cb = {
      save(e) { const t = this; const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = r.useCanvas; const i = void 0 !== n && n; const a = r.encoder; const o = void 0 === a ? void 0 : a; let s = r.format; if (!s) { const u = am(/\.([a-zA-Z]+)$/, { format: 1 }).exec(e); u && (s = u.groups.format.toLowerCase()); } if (!s) throw new Error('file format not provided'); return new Promise(((e, r) => { let n; let a; switch (s.toLowerCase()) { case 'png': i ? n = t.getCanvas().pngStream() : a = lb(t, o); break; case 'jpg': case 'jpeg': i ? n = t.getCanvas().jpegStream() : a = ub(t, o); break; case 'bmp': a = (0, lm.c)(t, o); break; default: throw new RangeError('invalid output format: '.concat(s)); } if (n) { const u = (function () { throw new Error('createWriteStream does not exist in the browser'); }()); u.on('finish', e), u.on('error', r), n.pipe(u); } else a && (function () { throw new Error('writeFile does not exist in the browser'); }()); })); }, toDataURL() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'image/png'; let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; typeof e === 'object' && (t = e, e = 'image/png'); const r = t; const n = r.useCanvas; const i = void 0 !== n && n; const a = r.encoder; const o = void 0 === a ? void 0 : a; function s(t, r) { return ib(t(r, o), e); } return (e = (function (e) { return e.includes('/') || (e = 'image/'.concat(e)), e; }(e))) === 'image/bmp' ? s(lm.c, this) : e !== 'image/png' || i ? e !== 'image/jpeg' || i ? this.getCanvas().toDataURL(e) : s(ub, this) : s(lb, this); }, toBuffer() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.format; const r = void 0 === t ? 'png' : t; const n = e.encoder; const i = void 0 === n ? void 0 : n; switch (r.toLowerCase()) { case 'png': return lb(this, i); case 'jpeg': case 'jpg': return ub(this, i); case 'bmp': return (0, lm.c)(this, i); default: throw new RangeError('invalid output format: '.concat(r)); } }, toBase64() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'image/png'; const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (t.async) return this.toDataURL(e, t).then(((e) => e.substring(e.indexOf(',') + 1))); const r = this.toDataURL(e, t); return r.substring(r.indexOf(',') + 1); }, toBlob() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'image/png'; const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.8; return sm(this.getCanvas(), e, t); }, getCanvas() { const e = new ab(this.getRGBAData({ clamped: !0 }), this.width, this.height); const t = sb(this.width, this.height); return t.getContext('2d').putImageData(e, 0, 0), t; },
    }; const hb = __webpack_require__(5357); const fb = __webpack_require__.n(hb); const db = { configurable: !0, enumerable: !1, get: void 0 }; var pb = 'GREY'; var mb = 'RGB'; var vb = 'HSL'; var gb = 'HSV'; var yb = 'CMYK'; const bb = 'BINARY'; const wb = 'RGBA'; const kb = {}; kb[bb] = {
      components: 1, alpha: 0, bitDepth: 1, colorModel: pb,
    }, kb.GREYA = {
      components: 1, alpha: 1, bitDepth: 8, colorModel: pb,
    }, kb.GREY = {
      components: 1, alpha: 0, bitDepth: 8, colorModel: pb,
    }, kb[wb] = {
      components: 3, alpha: 1, bitDepth: 8, colorModel: mb,
    }, kb.RGB = {
      components: 3, alpha: 0, bitDepth: 8, colorModel: mb,
    }, kb.CMYK = {
      components: 4, alpha: 0, bitDepth: 8, colorModel: yb,
    }, kb.CMYKA = {
      components: 4, alpha: 1, bitDepth: 8, colorModel: yb,
    }; const xb = [1, 8, 16, 32]; const _b = __webpack_require__(6984); const Sb = __webpack_require__(946); const Mb = __webpack_require__.n(Sb); var Eb = {
      33434: 'ExposureTime', 33437: 'FNumber', 34850: 'ExposureProgram', 34852: 'SpectralSensitivity', 34855: 'ISOSpeedRatings', 34856: 'OECF', 34864: 'SensitivityType', 34865: 'StandardOutputSensitivity', 34866: 'RecommendedExposureIndex', 34867: 'ISOSpeed', 34868: 'ISOSpeedLatitudeyyy', 34869: 'ISOSpeedLatitudezzz', 36864: 'ExifVersion', 36867: 'DateTimeOriginal', 36868: 'DateTimeDigitized', 37121: 'ComponentsConfiguration', 37122: 'CompressedBitsPerPixel', 37377: 'ShutterSpeedValue', 37378: 'ApertureValue', 37379: 'BrightnessValue', 37380: 'ExposureBiasValue', 37381: 'MaxApertureValue', 37382: 'SubjectDistance', 37383: 'MeteringMode', 37384: 'LightSource', 37385: 'Flash', 37386: 'FocalLength', 37396: 'SubjectArea', 37500: 'MakerNote', 37510: 'UserComment', 37520: 'SubsecTime', 37521: 'SubsecTimeOriginal', 37522: 'SubsecTimeDigitized', 40960: 'FlashpixVersion', 40961: 'ColorSpace', 40962: 'PixelXDimension', 40963: 'PixelYDimension', 40964: 'RelatedSoundFile', 41483: 'FlashEnergy', 41484: 'SpatialFrequencyResponse', 41486: 'FocalPlaneXResolution', 41487: 'FocalPlaneYResolution', 41488: 'FocalPlaneResolutionUnit', 41492: 'SubjectLocation', 41493: 'ExposureIndex', 41495: 'SensingMethod', 41728: 'FileSource', 41729: 'SceneType', 41730: 'CFAPattern', 41985: 'CustomRendered', 41986: 'ExposureMode', 41987: 'WhiteBalance', 41988: 'DigitalZoomRatio', 41989: 'FocalLengthIn35mmFilm', 41990: 'SceneCaptureType', 41991: 'GainControl', 41992: 'Contrast', 41993: 'Saturation', 41994: 'Sharpness', 41995: 'DeviceSettingDescription', 41996: 'SubjectDistanceRange', 42016: 'ImageUniqueID', 42032: 'CameraOwnerName', 42033: 'BodySerialNumber', 42034: 'LensSpecification', 42035: 'LensMake', 42036: 'LensModel', 42037: 'LensSerialNumber', 42240: 'Gamma',
    }; var Cb = {}; for (const Pb in Eb)Cb[Eb[Pb]] = Number(Pb); var Ab = {
      0: 'GPSVersionID', 1: 'GPSLatitudeRef', 2: 'GPSLatitude', 3: 'GPSLongitudeRef', 4: 'GPSLongitude', 5: 'GPSAltitudeRef', 6: 'GPSAltitude', 7: 'GPSTimeStamp', 8: 'GPSSatellites', 9: 'GPSStatus', 10: 'GPSMeasureMode', 11: 'GPSDOP', 12: 'GPSSpeedRef', 13: 'GPSSpeed', 14: 'GPSTrackRef', 15: 'GPSTrack', 16: 'GPSImgDirectionRef', 17: 'GPSImgDirection', 18: 'GPSMapDatum', 19: 'GPSDestLatitudeRef', 20: 'GPSDestLatitude', 21: 'GPSDestLongitudeRef', 22: 'GPSDestLongitude', 23: 'GPSDestBearingRef', 24: 'GPSDestBearing', 25: 'GPSDestDistanceRef', 26: 'GPSDestDistance', 27: 'GPSProcessingMethod', 28: 'GPSAreaInformation', 29: 'GPSDateStamp', 30: 'GPSDifferential', 31: 'GPSHPositioningError',
    }; var Tb = {}; for (const Rb in Ab)Tb[Ab[Rb]] = Number(Rb); var Ib = {
      254: 'NewSubfileType', 255: 'SubfileType', 256: 'ImageWidth', 257: 'ImageLength', 258: 'BitsPerSample', 259: 'Compression', 262: 'PhotometricInterpretation', 263: 'Threshholding', 264: 'CellWidth', 265: 'CellLength', 266: 'FillOrder', 270: 'ImageDescription', 271: 'Make', 272: 'Model', 273: 'StripOffsets', 274: 'Orientation', 277: 'SamplesPerPixel', 278: 'RowsPerStrip', 279: 'StripByteCounts', 280: 'MinSampleValue', 281: 'MaxSampleValue', 282: 'XResolution', 283: 'YResolution', 284: 'PlanarConfiguration', 288: 'FreeOffsets', 289: 'FreeByteCounts', 290: 'GrayResponseUnit', 291: 'GrayResponseCurve', 296: 'ResolutionUnit', 305: 'Software', 306: 'DateTime', 315: 'Artist', 316: 'HostComputer', 320: 'ColorMap', 338: 'ExtraSamples', 33432: 'Copyright', 269: 'DocumentName', 285: 'PageName', 286: 'XPosition', 287: 'YPosition', 292: 'T4Options', 293: 'T6Options', 297: 'PageNumber', 301: 'TransferFunction', 317: 'Predictor', 318: 'WhitePoint', 319: 'PrimaryChromaticities', 321: 'HalftoneHints', 322: 'TileWidth', 323: 'TileLength', 324: 'TileOffsets', 325: 'TileByteCounts', 326: 'BadFaxLines', 327: 'CleanFaxData', 328: 'ConsecutiveBadFaxLines', 330: 'SubIFDs', 332: 'InkSet', 333: 'InkNames', 334: 'NumberOfInks', 336: 'DotRange', 337: 'TargetPrinter', 339: 'SampleFormat', 340: 'SMinSampleValue', 341: 'SMaxSampleValue', 342: 'TransferRange', 343: 'ClipPath', 344: 'XClipPathUnits', 345: 'YClipPathUnits', 346: 'Indexed', 347: 'JPEGTables', 351: 'OPIProxy', 400: 'GlobalParametersIFD', 401: 'ProfileType', 402: 'FaxProfile', 403: 'CodingMethods', 404: 'VersionYear', 405: 'ModeNumber', 433: 'Decode', 434: 'DefaultImageColor', 512: 'JPEGProc', 513: 'JPEGInterchangeFormat', 514: 'JPEGInterchangeFormatLength', 515: 'JPEGRestartInterval', 517: 'JPEGLosslessPredictors', 518: 'JPEGPointTransforms', 519: 'JPEGQTables', 520: 'JPEGDCTables', 521: 'JPEGACTables', 529: 'YCbCrCoefficients', 530: 'YCbCrSubSampling', 531: 'YCbCrPositioning', 532: 'ReferenceBlackWhite', 559: 'StripRowCounts', 700: 'XMP', 32781: 'ImageID', 34732: 'ImageLayer', 32932: 'WangAnnotatio', 33445: 'MDFileTag', 33446: 'MDScalePixel', 33447: 'MDColorTable', 33448: 'MDLabName', 33449: 'MDSampleInfo', 33450: 'MDPrepDate', 33451: 'MDPrepTime', 33452: 'MDFileUnits', 33550: 'ModelPixelScaleTag', 33723: 'IPTC', 33918: 'INGRPacketDataTag', 33919: 'INGRFlagRegisters', 33920: 'IrasBTransformationMatrix', 33922: 'ModelTiepointTag', 34264: 'ModelTransformationTag', 34377: 'Photoshop', 34665: 'ExifIFD', 34675: 'ICCProfile', 34735: 'GeoKeyDirectoryTag', 34736: 'GeoDoubleParamsTag', 34737: 'GeoAsciiParamsTag', 34853: 'GPSIFD', 34908: 'HylaFAXFaxRecvParams', 34909: 'HylaFAXFaxSubAddress', 34910: 'HylaFAXFaxRecvTime', 37724: 'ImageSourceData', 40965: 'InteroperabilityIFD', 42112: 'GDAL_METADATA', 42113: 'GDAL_NODATA', 50215: 'OceScanjobDescription', 50216: 'OceApplicationSelector', 50217: 'OceIdentificationNumber', 50218: 'OceImageLogicCharacteristics', 50706: 'DNGVersion', 50707: 'DNGBackwardVersion', 50708: 'UniqueCameraModel', 50709: 'LocalizedCameraModel', 50710: 'CFAPlaneColor', 50711: 'CFALayout', 50712: 'LinearizationTable', 50713: 'BlackLevelRepeatDim', 50714: 'BlackLevel', 50715: 'BlackLevelDeltaH', 50716: 'BlackLevelDeltaV', 50717: 'WhiteLevel', 50718: 'DefaultScale', 50719: 'DefaultCropOrigin', 50720: 'DefaultCropSize', 50721: 'ColorMatrix1', 50722: 'ColorMatrix2', 50723: 'CameraCalibration1', 50724: 'CameraCalibration2', 50725: 'ReductionMatrix1', 50726: 'ReductionMatrix2', 50727: 'AnalogBalance', 50728: 'AsShotNeutral', 50729: 'AsShotWhiteXY', 50730: 'BaselineExposure', 50731: 'BaselineNoise', 50732: 'BaselineSharpness', 50733: 'BayerGreenSplit', 50734: 'LinearResponseLimit', 50735: 'CameraSerialNumber', 50736: 'LensInfo', 50737: 'ChromaBlurRadius', 50738: 'AntiAliasStrength', 50740: 'DNGPrivateData', 50741: 'MakerNoteSafety', 50778: 'CalibrationIlluminant1', 50779: 'CalibrationIlluminant2', 50780: 'BestQualityScale', 50784: 'AliasLayerMetadata',
    }; var Ob = {}; for (const Db in Ib)Ob[Ib[Db]] = Number(Db); const zb = { standard: n, exif: t, gps: r }; const Nb = (function () { function e(t) { if ((0, w.Z)(this, e), !t) throw new Error('missing kind'); this.data = new Uint8Array(), this.fields = new Map(), this.kind = t, this._hasMap = !1, this._map = {}; } return (0, b.Z)(e, [{ key: 'get', value(e) { if (typeof e === 'number') return this.fields.get(e); if (typeof e === 'string') return this.fields.get(zb[this.kind].tagsByName[e]); throw new Error('expected a number or string'); } }, { key: 'map', get() { if (!this._hasMap) { let e; const t = zb[this.kind].tagsById; const r = N(this.fields.keys()); try { for (r.s(); !(e = r.n()).done;) { const n = e.value; t[n] && (this._map[t[n]] = this.fields.get(n)); } } catch (Rv) { r.e(Rv); } finally { r.f(); } this._hasMap = !0; } return this._map; } }]), e; }()); const Lb = new Map([[1, [1, jb]], [2, [1, function (e, t) { for (var r = [], n = '', i = 0; i < t; i++) { const a = String.fromCharCode(e.readUint8()); a === '\0' ? (r.push(n), n = '') : n += a; } return r.length === 1 ? r[0] : r; }]], [3, [2, function (e, t) { if (t === 1) return e.readUint16(); for (var r = new Uint16Array(t), n = 0; n < t; n++)r[n] = e.readUint16(); return r; }]], [4, [4, function (e, t) { if (t === 1) return e.readUint32(); for (var r = new Uint32Array(t), n = 0; n < t; n++)r[n] = e.readUint32(); return r; }]], [5, [8, function (e, t) { if (t === 1) return e.readUint32() / e.readUint32(); for (var r = new Array(t), n = 0; n < t; n++)r[n] = e.readUint32() / e.readUint32(); return r; }]], [6, [1, function (e, t) { if (t === 1) return e.readInt8(); for (var r = new Int8Array(t), n = 0; n < t; n++)r[n] = e.readInt8(); return r; }]], [7, [1, jb]], [8, [2, function (e, t) { if (t === 1) return e.readInt16(); for (var r = new Int16Array(t), n = 0; n < t; n++)r[n] = e.readInt16(); return r; }]], [9, [4, function (e, t) { if (t === 1) return e.readInt32(); for (var r = new Int32Array(t), n = 0; n < t; n++)r[n] = e.readInt32(); return r; }]], [10, [8, function (e, t) { if (t === 1) return e.readInt32() / e.readInt32(); for (var r = new Array(t), n = 0; n < t; n++)r[n] = e.readInt32() / e.readInt32(); return r; }]], [11, [4, function (e, t) { if (t === 1) return e.readFloat32(); for (var r = new Float32Array(t), n = 0; n < t; n++)r[n] = e.readFloat32(); return r; }]], [12, [8, function (e, t) { if (t === 1) return e.readFloat64(); for (var r = new Float64Array(t), n = 0; n < t; n++)r[n] = e.readFloat64(); return r; }]]]); function jb(e, t) { if (t === 1) return e.readUint8(); for (var r = new Uint8Array(t), n = 0; n < t; n++)r[n] = e.readUint8(); return r; } let Fb = []; const Bb = [511, 1023, 2047, 4095]; const Ub = [0, 0, 0, 0, 0, 0, 0, 0, 0, 511, 1023, 2047, 4095]; const Vb = (function () { function e(t) { (0, w.Z)(this, e), this.nextData = 0, this.nextBits = 0, this.bytePointer = 0, this.tableLength = 258, this.currentBitLength = 9, this.stripArray = new Uint8Array(t.buffer, t.byteOffset, t.byteLength), this.outData = new cm.IOBuffer(t.byteLength), this.initializeTable(); } return (0, b.Z)(e, [{ key: 'decode', value() { for (let e = 0, t = 0; (e = this.getNextCode()) !== 257;) if (e === 256) { if (this.initializeTable(), (e = this.getNextCode()) === 257) break; this.writeString(this.stringFromCode(e)), t = e; } else if (this.isInTable(e)) this.writeString(this.stringFromCode(e)), this.addStringToTable(this.stringFromCode(t).concat(this.stringFromCode(e)[0])), t = e; else { const r = this.stringFromCode(t).concat(this.stringFromCode(t)[0]); this.writeString(r), this.addStringToTable(r), t = e; } const n = this.outData.toArray(); return new DataView(n.buffer, n.byteOffset, n.byteLength); } }, { key: 'initializeTable', value() { !(function () { if (Fb.length === 0) { for (let e = 0; e < 256; e++)Fb.push([e]); for (let t = [], r = 256; r < 4096; r++)Fb.push(t); } }()), this.tableLength = 258, this.currentBitLength = 9; } }, { key: 'writeString', value(e) { this.outData.writeBytes(e); } }, { key: 'stringFromCode', value(e) { return Fb[e]; } }, { key: 'isInTable', value(e) { return e < this.tableLength; } }, { key: 'addStringToTable', value(e) { if (Fb[this.tableLength++] = e, Fb.length > 4096) throw Fb = [], new Error('LZW decoding error. Please open an issue at https://github.com/image-js/tiff/issues/new/choose (include a test image).'); this.tableLength === Ub[this.currentBitLength] && this.currentBitLength++; } }, { key: 'getNextCode', value() { this.nextData = this.nextData << 8 | 255 & this.stripArray[this.bytePointer++], this.nextBits += 8, this.nextBits < this.currentBitLength && (this.nextData = this.nextData << 8 | 255 & this.stripArray[this.bytePointer++], this.nextBits += 8); const e = this.nextData >> this.nextBits - this.currentBitLength & Bb[this.currentBitLength - 9]; return this.nextBits -= this.currentBitLength, this.bytePointer > this.stripArray.length ? 257 : e; } }]), e; }()); function Yb(e) { return new Vb(e).decode(); } const Hb = /^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/; const qb = (function (e) {
      x(r, e); const t = C(r); function r() { return (0, w.Z)(this, r), t.call(this, 'standard'); } return (0, b.Z)(r, [{ key: 'size', get() { return this.width * this.height; } }, { key: 'width', get() { return this.imageWidth; } }, { key: 'height', get() { return this.imageLength; } }, { key: 'components', get() { return this.samplesPerPixel; } }, {
        key: 'date',
        get() {
          const e = new Date(); const
            t = Hb.exec(this.dateTime); if (t === null) throw new Error('invalid dateTime: '.concat(this.dateTime)); return e.setFullYear(Number(t[1]), Number(t[2]) - 1, Number(t[3])), e.setHours(Number(t[4]), Number(t[5]), Number(t[6])), e;
        },
      }, { key: 'newSubfileType', get() { return this.get('NewSubfileType'); } }, { key: 'imageWidth', get() { return this.get('ImageWidth'); } }, { key: 'imageLength', get() { return this.get('ImageLength'); } }, { key: 'bitsPerSample', get() { const e = this.get('BitsPerSample'); return e && typeof e !== 'number' ? e[0] : e; } }, { key: 'alpha', get() { const e = this.extraSamples; return !!e && e[0] !== 0; } }, { key: 'associatedAlpha', get() { const e = this.extraSamples; return !!e && e[0] === 1; } }, { key: 'extraSamples', get() { return Wb(this.get('ExtraSamples')); } }, { key: 'compression', get() { return this.get('Compression') || 1; } }, { key: 'type', get() { return this.get('PhotometricInterpretation'); } }, { key: 'fillOrder', get() { return this.get('FillOrder') || 1; } }, { key: 'documentName', get() { return this.get('DocumentName'); } }, { key: 'imageDescription', get() { return this.get('ImageDescription'); } }, { key: 'stripOffsets', get() { return Wb(this.get('StripOffsets')); } }, { key: 'orientation', get() { return this.get('Orientation'); } }, { key: 'samplesPerPixel', get() { return this.get('SamplesPerPixel') || 1; } }, { key: 'rowsPerStrip', get() { return this.get('RowsPerStrip'); } }, { key: 'stripByteCounts', get() { return Wb(this.get('StripByteCounts')); } }, { key: 'minSampleValue', get() { return this.get('MinSampleValue') || 0; } }, { key: 'maxSampleValue', get() { return this.get('MaxSampleValue') || 2 ** this.bitsPerSample - 1; } }, { key: 'xResolution', get() { return this.get('XResolution'); } }, { key: 'yResolution', get() { return this.get('YResolution'); } }, { key: 'planarConfiguration', get() { return this.get('PlanarConfiguration') || 1; } }, { key: 'resolutionUnit', get() { return this.get('ResolutionUnit') || 2; } }, { key: 'dateTime', get() { return this.get('DateTime'); } }, { key: 'predictor', get() { return this.get('Predictor') || 1; } }, { key: 'sampleFormat', get() { return this.get('SampleFormat') || 1; } }, { key: 'sMinSampleValue', get() { return this.get('SMinSampleValue') || this.minSampleValue; } }, { key: 'sMaxSampleValue', get() { return this.get('SMaxSampleValue') || this.maxSampleValue; } }, { key: 'palette', get() { const e = 2 ** this.bitsPerSample; const t = this.get('ColorMap'); if (t) { if (t.length !== 3 * e) throw new Error('ColorMap size must be '.concat(e)); for (var r = [], n = 0; n < e; n++)r.push([t[n], t[n + e], t[n + 2 * e]]); return r; } } }]), r;
    }(Nb)); function Wb(e) { return typeof e === 'number' ? [e] : e; } function Xb(e) { const t = new Uint8Array(e.buffer, e.byteOffset, e.byteLength); const r = Ey(t); return new DataView(r.buffer, r.byteOffset, r.byteLength); } const Gb = { ignoreImageData: !1, onlyFirst: !1 }; const $b = (function (e) { x(r, e); const t = C(r); function r(e) { let n; return (0, w.Z)(this, r), (n = t.call(this, e))._nextIFD = 0, n; } return (0, b.Z)(r, [{ key: 'isMultiPage', get() { let e = 0; for (this.decodeHeader(); this._nextIFD;) if (e++, this.decodeIFD({ ignoreImageData: !0 }, !0), e === 2) return !0; if (e === 1) return !1; throw Zb('ifdCount', e); } }, { key: 'pageCount', get() { let e = 0; for (this.decodeHeader(); this._nextIFD;)e++, this.decodeIFD({ ignoreImageData: !0 }, !0); if (e > 0) return e; throw Zb('ifdCount', e); } }, { key: 'decode', value() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; e = { ...Gb, ...e }; const t = []; for (this.decodeHeader(); this._nextIFD;) if (t.push(this.decodeIFD(e, !0)), e.onlyFirst) return [t[0]]; return t; } }, { key: 'decodeHeader', value() { const e = this.readUint16(); if (e === 18761) this.setLittleEndian(); else { if (e !== 19789) throw new Error('invalid byte order: 0x'.concat(e.toString(16))); this.setBigEndian(); } if (this.readUint16() !== 42) throw new Error('not a TIFF file'); this._nextIFD = this.readUint32(); } }, { key: 'decodeIFD', value(e, t) { let r; if (this.seek(this._nextIFD), t)r = new qb(); else { if (!e.kind) throw new Error('kind is missing'); r = new Nb(e.kind); } for (let n = this.readUint16(), i = 0; i < n; i++) this.decodeIFDEntry(r); if (!e.ignoreImageData) { if (!(r instanceof qb)) throw new Error('must be a tiff ifd'); this.decodeImageData(r); } return this._nextIFD = this.readUint32(), r; } }, { key: 'decodeIFDEntry', value(e) { const t = this.offset; const r = this.readUint16(); const n = this.readUint16(); const i = this.readUint32(); if (n < 1 || n > 12) this.skip(4); else { const a = (function (e, t) { const r = Lb.get(e); if (!r) throw new Error('type not found: '.concat(e)); return r[0] * t; }(n, i)); a > 4 && this.seek(this.readUint32()); const o = (function (e, t, r) { const n = Lb.get(t); if (!n) throw new Error('type not found: '.concat(t)); return n[1](e, r); }(this, n, i)); if (e.fields.set(r, o), r === 34665 || r === 34853) { const s = this.offset; let u = 'exif'; r === 34665 ? u = 'exif' : r === 34853 && (u = 'gps'), this._nextIFD = o, e[u] = this.decodeIFD({ kind: u, ignoreImageData: !0 }, !1), this.offset = s; } this.seek(t), this.skip(12); } } }, { key: 'decodeImageData', value(e) { const t = e.orientation; if (t && t !== 1) throw Zb('orientation', t); switch (e.type) { case 0: case 1: case 2: case 3: this.readStripData(e); break; default: throw Zb('image type', e.type); } if (this.applyPredictor(e), this.convertAlpha(e), e.type === 0) for (let r = e.bitsPerSample, n = 2 ** r - 1, i = 0; i < e.data.length; i++)e.data[i] = n - e.data[i]; } }, { key: 'readStripData', value(e) { for (var t = e.width, r = e.height, n = e.bitsPerSample, i = e.sampleFormat, a = t * r * e.samplesPerPixel, o = (function (e, t, r) { if (t === 8) return new Uint8Array(e); if (t === 16) return new Uint16Array(e); if (t === 32 && r === 3) return new Float32Array(e); throw Zb('bit depth / sample format', ''.concat(t, ' / ').concat(r)); }(a, n, i)), s = e.rowsPerStrip * t * e.samplesPerPixel, u = e.stripOffsets, l = e.stripByteCounts || (function (e) { if (e.compression !== 1) throw new Error('missing mandatory StripByteCounts field in compressed image'); const t = e.rowsPerStrip * e.width * e.samplesPerPixel * (e.bitsPerSample / 8); return new Array(e.stripOffsets.length).fill(t); }(e)), c = a, h = 0, f = 0; f < u.length; f++) { const d = new DataView(this.buffer, this.byteOffset + u[f], l[f]); const p = c > s ? s : c; c -= p; let m = d; switch (e.compression) { case 1: break; case 5: m = Yb(d); break; case 8: m = Xb(d); break; case 2: throw Zb('Compression', 'CCITT Group 3'); case 32773: throw Zb('Compression', 'PackBits'); default: throw Zb('Compression', e.compression); }h = this.fillUncompressed(n, i, o, m, h, p); }e.data = o; } }, { key: 'fillUncompressed', value(e, t, r, n, i, a) { if (e === 8) return (function (e, t, r, n) { for (let i = 0; i < n; i++)e[r++] = t.getUint8(i); return r; }(r, n, i, a)); if (e === 16) return (function (e, t, r, n, i) { for (let a = 0; a < 2 * n; a += 2)e[r++] = t.getUint16(a, i); return r; }(r, n, i, a, this.isLittleEndian())); if (e === 32 && t === 3) return (function (e, t, r, n, i) { for (let a = 0; a < 4 * n; a += 4)e[r++] = t.getFloat32(a, i); return r; }(r, n, i, a, this.isLittleEndian())); throw Zb('bitDepth', e); } }, { key: 'applyPredictor', value(e) { const t = e.bitsPerSample; switch (e.predictor) { case 1: break; case 2: if (t === 8)!(function (e, t, r) { for (let n = 0; n < e.length;) { for (let i = r; i < t * r; i += r) for (let a = 0; a < r; a++)e[n + i + a] = e[n + i + a] + e[n + i - (r - a)] & 255; n += t * r; } }(e.data, e.width, e.components)); else { if (t !== 16) throw new Error('Horizontal differencing is only supported for images with a bit depth of '.concat(t)); !(function (e, t, r) { for (let n = 0; n < e.length;) { for (let i = r; i < t * r; i += r) for (let a = 0; a < r; a++)e[n + i + a] = e[n + i + a] + e[n + i - (r - a)] & 65535; n += t * r; } }(e.data, e.width, e.components)); } break; default: throw new Error('invalid predictor: '.concat(e.predictor)); } } }, { key: 'convertAlpha', value(e) { if (e.alpha && e.associatedAlpha) for (let t = e.data, r = e.components, n = e.maxSampleValue, i = 0; i < t.length; i += r) for (let a = t[i + r - 1], o = 0; o < r - 1; o++)t[i + o] = Math.round(t[i + o] * n / a); } }]), r; }(cm.IOBuffer)); function Zb(e, t) { return new Error('Unsupported '.concat(e, ': ').concat(t)); } function Kb() {
      const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.algorithm; const r = void 0 === t ? 'matchToPrevious' : t; const n = e.ignoreBorder; const i = void 0 === n ? [0, 0] : n; this.checkProcessable('matchAndCrop', { bitDepth: [8, 16] }); const a = r === 'matchToPrevious'; let o = this[0]; const s = []; s[0] = { position: [0, 0], image: this[0] }; for (let u = [0, 0], l = 1; l < this.length; l++) { const c = o.getBestMatch(this[l], { border: i }); s[l] = { position: [c[0] + u[0], c[1] + u[1]], image: this[l] }, a && (u[0] += c[0], u[1] += c[1], o = this[l]); } for (var h = 0, f = 0, d = 0, p = 0, m = 0; m < s.length; m++) { const v = s[m]; v.position[0] > h && (h = v.position[0]), v.position[0] < f && (f = v.position[0]), v.position[1] > d && (d = v.position[1]), v.position[1] < p && (p = v.position[1]); }f = 0 - f, p = 0 - p; for (let g = 0; g < s.length; g++) {
        const y = s[g]; y.crop = y.image.crop({
          x: h - y.position[0], y: d - y.position[1], width: o.width - f - h, height: o.height - p - d,
        });
      } for (var b = [], w = 0; w < s.length; w++)b[w] = s[w].crop; return new lw(b);
    } function Qb() { this.checkProcessable('min', { bitDepth: [8, 16] }); for (var e = this[0].min, t = 1; t < this.length; t++) for (let r = 0; r < e.length; r++)e[r] = Math.min(e[r], this[t].min[r]); return e; } function Jb() { this.checkProcessable('min', { bitDepth: [8, 16] }); for (var e = this[0].max, t = 1; t < this.length; t++) for (let r = 0; r < e.length; r++)e[r] = Math.max(e[r], this[t].max[r]); return e; } function ew(e) { const t = e.reduce(((e, t) => e + t)); if (t === 0) throw new Error('unreachable'); for (var r, n = 0, i = 0, a = t / 2; ;) { if (e[n] > 0) { if (void 0 !== r) return (r + n) / 2; if ((i += e[n]) > a) return n; i === a && (r = n); }n++; } } function tw(e) { for (var t = 0, r = 0, n = 0; n < e.length; n++)t += e[n], r += e[n] * n; return t === 0 ? 0 : r / t; } function rw() { this.checkProcessable('median', { bitDepth: [8, 16] }); for (var e = this.getHistograms({ maxSlots: this[0].maxValue + 1 }), t = new Array(e.length), r = 0; r < e.length; r++) { const n = e[r]; t[r] = ew(n); } return t; } function nw(e) { this.checkProcessable('min', { bitDepth: [8, 16] }); for (var t = this[0].getHistogram(e), r = 1; r < this.length; r++) for (let n = this[r].getHistogram(e), i = 0; i < t.length; i++)t[i] += n[i]; return t; } function iw(e) { this.checkProcessable('min', { bitDepth: [8, 16] }); for (var t = this[0].getHistograms(e), r = t[0].length, n = 1; n < this.length; n++) for (let i = this[n].getHistograms(e), a = 0; a < t.length; a++) for (let o = 0; o < r; o++)t[a][o] += i[a][o]; return t; } function aw() { this.checkProcessable('averageImage', { bitDepth: [8, 16] }); for (var e = new Uint32Array(this[0].data.length), t = 0; t < this.length; t++) for (let r = this[t], n = 0; n < this[0].data.length; n++)e[n] += r.data[n]; for (var i = mS.createFrom(this[0]), a = i.data, o = 0; o < this[0].data.length; o++)a[o] = e[o] / this.length; return i; } function ow() { this.checkProcessable('max', { bitDepth: [8, 16] }); const e = mS.createFrom(this[0]); e.data.fill(0); let t; const r = N(this); try { for (r.s(); !(t = r.n()).done;) for (let n = t.value, i = 0; i < e.data.length; i++)e.data[i] = Math.max(n.data[i], e.data[i]); } catch (Rv) { r.e(Rv); } finally { r.f(); } return e; } function sw() { this.checkProcessable('max', { bitDepth: [8, 16] }); const e = mS.createFrom(this[0]); e.data.fill(e.maxValue); let t; const r = N(this); try { for (r.s(); !(t = r.n()).done;) for (let n = t.value, i = 0; i < e.data.length; i++)e.data[i] = Math.min(n.data[i], e.data[i]); } catch (Rv) { r.e(Rv); } finally { r.f(); } return e; } const uw = { configurable: !0, enumerable: !1, get: void 0 }; var lw = (function (e) { x(r, e); const t = C(r); function r(e) { let n; if ((0, w.Z)(this, r), Array.isArray(e)) { n = t.call(this, e.length); for (let i = 0; i < e.length; i++)n[i] = e[i]; } else n = typeof e === 'number' ? t.call(this, e) : t.call(this); return n.computed = null, E(n); } return (0, b.Z)(r, [{ key: 'checkProcessable', value(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (typeof e !== 'string') throw new TypeError('checkProcessable requires as first parameter the processName (a string)'); if (this.size === 0) throw new TypeError('The process: '.concat(e, ' can not be applied on an empty stack')); this[0].checkProcessable(e, t); for (let r = 1; r < this.length; r++) { if ((void 0 === t.sameSize || t.sameSize) && this[0].width !== this[r].width) throw new TypeError('The process: '.concat(e, ' can not be applied if width is not identical in all images')); if ((void 0 === t.sameSize || t.sameSize) && this[0].height !== this[r].height) throw new TypeError('The process: '.concat(e, ' can not be applied if height is not identical in all images')); if ((void 0 === t.sameAlpha || t.sameAlpha) && this[0].alpha !== this[r].alpha) throw new TypeError('The process: '.concat(e, ' can not be applied if alpha is not identical in all images')); if ((void 0 === t.sameBitDepth || t.sameBitDepth) && this[0].bitDepth !== this[r].bitDepth) throw new TypeError('The process: '.concat(e, ' can not be applied if bitDepth is not identical in all images')); if ((void 0 === t.sameColorModel || t.sameColorModel) && this[0].colorModel !== this[r].colorModel) throw new TypeError('The process: '.concat(e, ' can not be applied if colorModel is not identical in all images')); if ((void 0 === t.sameNumberChannels || t.sameNumberChannels) && this[0].channels !== this[r].channels) throw new TypeError('The process: '.concat(e, ' can not be applied if channels is not identical in all images')); } } }], [{ key: 'load', value(e) { return Promise.all(e.map(mS.load)).then(((e) => new r(e))); } }, { key: 'extendMethod', value(e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const i = n.inPlace; const a = void 0 !== i && i; const o = n.returnThis; const s = void 0 === o || o; const u = n.partialArgs; const l = void 0 === u ? [] : u; return r.prototype[e] = a ? function () { this.computed = null; for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)r[n] = arguments[n]; const i = t.apply(this, [].concat(P(l), r)); return s ? this : i; } : function () { for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)r[n] = arguments[n]; return t.apply(this, [].concat(P(l), r)); }, r; } }, { key: 'extendProperty', value(e, t) { const n = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).partialArgs; const i = void 0 === n ? [] : n; return uw.get = function () { if (this.computed === null) this.computed = {}; else if (fb()(e, this.computed)) return this.computed[e]; const r = t.apply(this, i); return this.computed[e] = r, r; }, Object.defineProperty(r.prototype, e, uw), r; } }]), r; }(R(Array))); Array[Symbol.species] || (lw.prototype.map = function (e, t) { if (typeof e !== 'function') throw new TypeError(''.concat(e, ' is not a function')); for (var r = new lw(this.length), n = 0; n < this.length; n++)r[n] = e.call(t, this[n], n, this); return r; }), (function (e) { e.extendMethod('matchAndCrop', Kb), e.extendMethod('getMin', Qb), e.extendMethod('getMax', Jb), e.extendMethod('getMedian', rw), e.extendMethod('getHistogram', nw), e.extendMethod('getHistograms', iw), e.extendMethod('getAverage', aw), e.extendMethod('getAverageImage', aw), e.extendMethod('getMaxImage', ow), e.extendMethod('getMinImage', sw); }(lw)); const cw = /^data:[a-z]+\/(?:[a-z]+);base64,/; function hw(e, t, r) {
      const n = Mb()(e); if (n) {
        switch (n.mime) {
          case 'image/png': return (function (e) { let t; const r = (function (e, t) { return new Uy(e, t).decode(); }(e)); const n = r.channels; let i = 0; n === 2 || n === 4 ? (t = n - 1, i = 1) : t = n; if (r.palette) return (function (e) { for (var t = e.width * e.height, r = e.palette[0].length, n = new Uint8Array(t * r), i = 8 / e.depth, a = e.depth < 8 ? i : 1, o = parseInt('1'.repeat(e.depth), 2), s = r === 4, u = 0, l = 0; l < t; l++) { const c = Math.floor(l / a); let h = e.data[c]; e.depth < 8 && (h = h >>> e.depth * (i - 1 - l % i) & o); const f = e.palette[h]; n[u++] = f[0], n[u++] = f[1], n[u++] = f[2], s && (n[u++] = f[3]); } return new mS(e.width, e.height, n, { components: 3, alpha: s, bitDepth: 8 }); }(r)); return new mS(r.width, r.height, r.data, { components: t, alpha: i, bitDepth: r.depth }); }(e)); case 'image/jpeg': return (function (e) {
            let t; const r = (0, _b.decode)(e); r.exif && (t = fw(r.exif)); const n = (0, eb.decode)(e, { useTArray: !0, maxMemoryUsageInMB: 1024 }); let i = new mS(n.width, n.height, n.data, { meta: t }); if (t && t.tiff.tags.Orientation) {
              const a = t.tiff.tags.Orientation; a > 2 && (i = i.rotate({
                3: 180, 4: 180, 5: 90, 6: 90, 7: 270, 8: 270,
              }[a])), [2, 4, 5, 7].includes(a) && (i = i.flipX());
            } return i;
          }(e)); case 'image/tiff': return (function (e, t) { const r = (function (e, t) { return new $b(e).decode(t); }(e)); return r.length === 1 ? dw(r[0], t) : new lw(r.map(((e) => dw(e, t)))); }(e, r)); default: return pw(i(n.mime));
        }
      } return pw(i('application/octet-stream')); function i(r) { return t || ib(e, r); }
    } function fw(e) { const t = { tiff: { fields: e.fields, tags: e.map } }; return e.exif && (t.exif = e.exif), e.gps && (t.gps = e.gps), t; } function dw(e, t) {
      if (t || e.type !== 3) {
        return new mS(e.width, e.height, e.data, {
          components: e.type === 2 ? 3 : 1, alpha: e.alpha, colorModel: e.type === 2 ? mb : pb, bitDepth: e.bitsPerSample.length ? e.bitsPerSample[0] : e.bitsPerSample, meta: fw(e),
        });
      } for (var r = new Uint16Array(3 * e.width * e.height), n = e.palette, i = 0, a = 0; a < e.data.length; a++) { const o = n[e.data[a]]; r[i++] = o[0], r[i++] = o[1], r[i++] = o[2]; } return new mS(e.width, e.height, r, {
        components: 3, alpha: e.alpha, colorModel: mb, bitDepth: 16, meta: fw(e),
      });
    } function pw(e, t) { return t = t || {}, new Promise(((r, n) => { const i = new ob(); i.onload = function () { const e = i.width; const n = i.height; const a = sb(e, n).getContext('2d'); a.drawImage(i, 0, 0, e, n); const o = a.getImageData(0, 0, e, n).data; r(new mS(e, n, o, t)); }, i.onerror = function () { n(new Error('Could not load '.concat(e))); }, i.src = e; })); } const mw = {
      getValueXY(e, t, r) { return this.data[(t * this.width + e) * this.channels + r]; }, setValueXY(e, t, r, n) { return this.data[(t * this.width + e) * this.channels + r] = n, this.computed = null, this; }, getValue(e, t) { return this.data[e * this.channels + t]; }, setValue(e, t, r) { return this.data[e * this.channels + t] = r, this.computed = null, this; }, getPixelXY(e, t) { return this.getPixel(t * this.width + e); }, setPixelXY(e, t, r) { return this.setPixel(t * this.width + e, r); }, getPixel(e) { for (var t = new Array(this.channels), r = e * this.channels, n = 0; n < this.channels; n++)t[n] = this.data[r + n]; return t; }, setPixel(e, t) { for (let r = e * this.channels, n = 0; n < t.length; n++) this.data[r + n] = t[n]; return this.computed = null, this; },
    }; function vw(e) {
      return {
        width: e.width, height: e.height, components: e.components, alpha: e.alpha, colorModel: e.colorModel, bitDepth: e.bitDepth,
      };
    } function gw(e, t, r) { const n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; const i = t.out; if (void 0 === i) return n.copy ? e.clone() : mS.createFrom(e, r); if (!mS.isImage(i)) throw new TypeError('out must be an Image object'); const a = Object.assign(vw(e), r); for (const o in a) if (i[o] !== a[o]) throw new RangeError('cannot use out. Its '.concat(o, ' must be "').concat(a[o], '" (found "').concat(i[o], '")')); return i; } function yw(e, t, r) { if (void 0 !== t.inPlace && typeof t.inPlace !== 'boolean') throw new TypeError('inPlace option must be a boolean'); if (t.inPlace) { if (void 0 !== t.out) throw new TypeError('out option must not be set if inPlace option is true'); return e; } return gw(e, t, null, r); } function bw() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.checkProcessable('abs', { bitDepth: [32] }); const t = yw(this, e); return (function (e, t) { for (let r = 0; r < e.data.length; r++)t.data[r] = Math.abs(e.data[r]); }(this, t)), t; } function ww() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.checkProcessable('invert', { bitDepth: [1, 8, 16] }); const t = yw(this, e); return this.bitDepth === 1 ? (function (e, t) { for (let r = 0; r < e.data.length; r++)t.data[r] = ~e.data[r]; }(this, t)) : ((function (e, t) { for (let r = 0; r < e.data.length; r += e.channels) for (let n = 0; n < e.components; n++)t.data[r + n] = e.maxValue - e.data[r + n]; }(this, t)), this !== t && (function (e, t) { if (e.alpha === 1 && t.alpha === 1) for (let r = 0; r < e.size; r++)t.data[r * t.channels + t.components] = e.data[r * e.channels + e.components]; }(this, t))), t; } function kw() { this.checkProcessable('flipX', { bitDepth: [8, 16] }); for (let e = 0; e < this.height; e++) for (let t = e * this.width * this.channels, r = 0; r < Math.floor(this.width / 2); r++) for (let n = r * this.channels + t, i = (this.width - r - 1) * this.channels + t, a = 0; a < this.channels; a++) { const o = this.data[n + a]; this.data[n + a] = this.data[i + a], this.data[i + a] = o; } return this; } function xw() { this.checkProcessable('flipY', { bitDepth: [8, 16] }); for (let e = 0; e < Math.floor(this.height / 2); e++) for (let t = 0; t < this.width; t++) for (let r = t * this.channels + e * this.width * this.channels, n = t * this.channels + (this.height - 1 - e) * this.channels * this.width, i = 0; i < this.channels; i++) { const a = this.data[r + i]; this.data[r + i] = this.data[n + i], this.data[n + i] = a; } return this; } function _w() { const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).radius; const t = void 0 === e ? 1 : e; if (t < 1) throw new Error('radius must be greater than 1'); for (var r = 2 * t + 1, n = new Array(r), i = 0; i < r; i++) { n[i] = new Array(r); for (let a = 0; a < r; a++)n[i][a] = 1 / (r * r); } return this.convolution(n); } const Sw = __webpack_require__(6425); const Mw = __webpack_require__.n(Sw); function Ew(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.channels; let n = t.allowAlpha; const i = t.defaultAlpha; return typeof n !== 'boolean' && (n = !0), typeof r === 'undefined' ? (function (e, t) { for (var r = t ? e.channels : e.components, n = new Array(r), i = 0; i < r; i++)n[i] = i; return n; }(e, i)) : (function (e, t, r) { Array.isArray(t) || (t = [t]); for (let n = 0; n < t.length; n++)t[n] = Cw(e, t[n], r); return t; }(e, r, n)); } function Cw(e, t) { const r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; if (void 0 === t) throw new RangeError('validateChannel : the channel has to be >=0 and <'.concat(e.channels)); if (typeof t === 'string') { switch (e.colorModel) { case pb: break; case mb: if ('rgb'.includes(t)) switch (t) { case 'r': t = 0; break; case 'g': t = 1; break; case 'b': t = 2; } break; case vb: if ('hsl'.includes(t)) switch (t) { case 'h': t = 0; break; case 's': t = 1; break; case 'l': t = 2; } break; case gb: if ('hsv'.includes(t)) switch (t) { case 'h': t = 0; break; case 's': t = 1; break; case 'v': t = 2; } break; case yb: if ('cmyk'.includes(t)) switch (t) { case 'c': t = 0; break; case 'm': t = 1; break; case 'y': t = 2; break; case 'k': t = 3; } break; default: throw new Error('Unexpected color model: '.concat(e.colorModel)); } if (t === 'a') { if (!e.alpha) throw new Error('validateChannel : the image does not contain alpha channel'); t = e.components; } if (typeof t === 'string') throw new Error('validateChannel : undefined channel: '.concat(t)); } if (t >= e.channels) throw new RangeError('validateChannel : the channel has to be >=0 and <'.concat(e.channels)); if (!r && t >= e.components) throw new RangeError('validateChannel : alpha channel may not be selected'); return t; } function Pw() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.radius; const r = void 0 === t ? 1 : t; const n = e.border; const i = void 0 === n ? 'copy' : n; let a = e.channels; if (this.checkProcessable('medianFilter', { bitDepth: [8, 16] }), r < 1) throw new Error('radius must be greater than 0'); a = Ew(this, a, !0); for (var o = r, s = r, u = mS.createFrom(this), l = new Array((2 * o + 1) * (2 * s + 1)), c = 0; c < a.length; c++) for (let h = a[c], f = s; f < this.height - s; f++) for (let d = o; d < this.width - o; d++) { for (let p = 0, m = -s; m <= s; m++) for (let v = -o; v <= o; v++) { const g = ((f + m) * this.width + d + v) * this.channels + h; l[p++] = this.data[g]; } const y = (f * this.width + d) * this.channels + h; u.data[y] = Mw()(l); } if (this.alpha && !a.includes(this.channels)) for (let b = this.components; b < this.data.length; b += this.channels)u.data[b] = this.data[b]; return u.setBorder({ size: [o, s], algorithm: i }), u; } function Aw() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.radius; const r = void 0 === t ? 1 : t; const n = e.sigma; const i = e.channels; const a = e.border; const o = void 0 === a ? 'copy' : a; this.checkProcessable('gaussian', { bitDepth: [8, 16] }); const s = (function (e, t) { for (var r = 2 * e + 1, n = new Array(r), i = t || 0.3 * (0.5 * (r - 1) - 1) + 0.8, a = -0.5 / (i * i), o = 0, s = 0; s < r; s++) { const u = s - e; const l = Math.exp(a * u * u); n[s] = l, o += l; } for (let c = 0; c < r; c++)n[c] /= o; return n; }(r, n)); return this.convolution([s, s], { border: o, channels: i, algorithm: 'separable' }); } const Tw = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]; const Rw = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]]; const Iw = [[3, 0, -3], [10, 0, -10], [3, 0, -3]]; const Ow = [[3, 10, 3], [0, 0, 0], [-3, -10, -3]]; const Dw = __webpack_require__(2111); const zw = __webpack_require__(7390); const Nw = __webpack_require__.n(zw); function Lw(e, t) { return Math.round(Math.min(Math.max(e, 0), t.maxValue)); } function jw(e, t, r) { if (void 0 === r) { const n = e.length + t.length - 1; r = new Array(n); }!(function (e) { for (let t = 0; t < e.length; t++)e[t] = 0; }(r)); for (let i = 0; i < e.length; i++) for (let a = 0; a < t.length; a++)r[i + a] += e[i] * t[a]; return r; }__webpack_require__(567), __webpack_require__(1257); function Fw(e, t, r, n) { let i; let a; let o; let s; const u = new Array(e.length); o = ((s = t[1]).length - 1) / 2, a = new Array(r + s.length - 1), i = new Array(r); for (let l = 0; l < n; l++) { for (let c = 0; c < r; c++)i[c] = e[l * r + c]; jw(i, s, a); for (let h = 0; h < r; h++)u[l * r + h] = a[o + h]; }o = ((s = t[0]).length - 1) / 2, a = new Array(n + s.length - 1), i = new Array(n); for (let f = 0; f < r; f++) { for (let d = 0; d < n; d++)i[d] = u[d * r + f]; jw(i, s, a); for (let p = 0; p < n; p++)u[p * r + f] = a[o + p]; } return u; } const Bw = __webpack_require__(1316); const Uw = (Bw.AbstractMatrix, Bw.CHO, Bw.CholeskyDecomposition, Bw.EVD, Bw.EigenvalueDecomposition, Bw.LU, Bw.LuDecomposition, Bw.Matrix); const Vw = (Bw.MatrixColumnSelectionView, Bw.MatrixColumnView, Bw.MatrixFlipColumnView, Bw.MatrixFlipRowView, Bw.MatrixRowSelectionView, Bw.MatrixRowView, Bw.MatrixSelectionView, Bw.MatrixSubView, Bw.MatrixTransposeView, Bw.NIPALS, Bw.Nipals, Bw.QR, Bw.QrDecomposition, Bw.SVD); const Yw = Bw.SingularValueDecomposition; const Hw = (Bw.WrapperMatrix1D, Bw.WrapperMatrix2D, Bw.correlation, Bw.covariance, Bw.Matrix, Bw.Matrix, Bw.determinant, Bw.inverse); const qw = (Bw.linearDependencies, Bw.pseudoInverse, Bw.solve); Bw.wrap; function Ww(e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; let r = t.channels; const n = t.bitDepth; const i = t.normalize; const a = void 0 !== i && i; const o = t.divisor; let s = void 0 === o ? 1 : o; const u = t.border; const l = void 0 === u ? 'copy' : u; const c = t.algorithm; let h = void 0 === c ? 'auto' : c; const f = {}; n && (f.bitDepth = n); let d; let p; const m = mS.createFrom(this, f); if (r = Ew(this, r, !0), h !== 'separable') { const v = (function (e) { let t; let r; if (!Array.isArray(e)) throw new Error('validateKernel: Invalid Kernel: '.concat(e)); if (Array.isArray(e[0])) { if ((1 & e.length) === 0 || (1 & e[0].length) === 0) throw new RangeError('validateKernel: Kernel rows and columns should be odd numbers'); t = Math.floor(e.length / 2), r = Math.floor(e[0].length / 2); } else { const n = Math.sqrt(e.length); if (!Nw()(n)) throw new RangeError('validateKernel: Kernel array should be a square'); r = t = Math.floor(Math.sqrt(e.length) / 2); for (var i = new Array(n), a = 0; a < n; a++) { i[a] = new Array(n); for (let o = 0; o < n; o++)i[a][o] = e[a * n + o]; }e = i; } return { kernel: e, kWidth: r, kHeight: t }; }(e)); e = v.kernel; } else if (!Array.isArray(e) || e.length !== 2) throw new RangeError('separable convolution requires two arrays of numbers to represent the kernel'); if (h === 'auto') { const g = (function (e) { const t = new Vw(e, { autoTranspose: !0 }); if (t.rank !== 1) return null; const r = Math.sqrt(t.s[0]); return [t.U.to2DArray().map(((e) => e[0] * r)), t.V.to2DArray().map(((e) => e[0] * r))]; }(e)); g !== null ? (h = 'separable', e = g) : h = (e.length > 9 || e[0].length > 9) && this.width <= 4096 && this.height <= 4096 ? 'fft' : 'direct'; }h === 'separable' ? (d = Math.floor(e[0].length / 2), p = Math.floor(e[1].length / 2)) : (d = Math.floor(e.length / 2), p = Math.floor(e[0].length / 2)); let y; let b; let w; let k; let x; let _; const S = m.isClamped; const M = new Array(this.height * this.width); for (k = 0; k < r.length; k++) {
        for (x = r[k], w = 0; w < this.height; w++) for (b = 0; b < this.width; b++)M[y = w * this.width + b] = this.data[y * this.channels + x]; if (h === 'direct') {
          _ = (0, Dw.direct)(M, e, {
            rows: this.height, cols: this.width, normalize: a, divisor: s,
          });
        } else if (h === 'separable') { if (_ = Fw(M, e, this.width, this.height), a) { s = 0; for (let E = 0; E < e[0].length; E++) for (let C = 0; C < e[1].length; C++)s += e[0][E] * e[1][C]; } if (s !== 1) for (let P = 0; P < _.length; P++)_[P] /= s; } else {
          _ = (0, Dw.fft)(M, e, {
            rows: this.height, cols: this.width, normalize: a, divisor: s,
          });
        } for (w = 0; w < this.height; w++) for (b = 0; b < this.width; b++)y = w * this.width + b, m.data[y * this.channels + x] = S ? Lw(_[y], m) : _[y];
      } if (this.alpha && !r.includes(this.channels)) for (b = this.components; b < this.data.length; b += this.channels)m.data[b] = this.data[b]; return l !== 'periodic' && m.setBorder({ size: [p, d], algorithm: l }), m;
    } function Xw() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.direction; const r = void 0 === t ? 'xy' : t; const n = e.border; const i = void 0 === n ? 'copy' : n; const a = e.kernelX; const o = e.kernelY; const s = e.channels; const u = e.bitDepth; const l = void 0 === u ? this.bitDepth : u; switch (this.checkProcessable('gradientFilter', { bitDepth: [8, 16] }), r) { case 'x': if (!a) throw new Error('kernelX option is missing'); return Ww.call(this, a, { channels: s, border: i, bitDepth: l }); case 'y': if (!o) throw new Error('kernelY option is missing'); return Ww.call(this, o, { channels: s, border: i, bitDepth: l }); case 'xy': if (!a) throw new Error('kernelX option is missing'); if (!o) throw new Error('kernelY option is missing'); var c = Ww.call(this, a, { channels: s, border: i, bitDepth: 32 }); var h = Ww.call(this, o, { channels: s, border: i, bitDepth: 32 }); return c.hypotenuse(h, { bitDepth: l, channels: s }); default: throw new Error('Unknown parameter direction: '.concat(r)); } } function Gw(e) { return Xw.call(this, { ...e, kernelX: Tw, kernelY: Rw }); } function $w(e) { return Xw.call(this, { ...e, kernelX: Iw, kernelY: Ow }); } const Zw = __webpack_require__(49); const Kw = __webpack_require__.n(Zw); function Qw() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.algorithm; const r = void 0 === t ? 'range' : t; let n = e.channels; const i = e.min; let a = void 0 === i ? this.min : i; const o = e.max; let s = void 0 === o ? this.max : o; if (this.checkProcessable('level', { bitDepth: [8, 16, 32] }), (n = Ew(this, { channels: n })).length !== this.channel && (Array.isArray(a) && a.length === this.channels && (a = a.filter(((e, t) => n.includes(t)))), Array.isArray(s) && s.length === this.channels && (s = s.filter(((e, t) => n.includes(t))))), r !== 'range') throw new Error('level: algorithm not implement: '.concat(r)); return a < 0 && (a = 0), s > this.maxValue && (s = this.maxValue), Array.isArray(a) || (a = Kw()(n.length, a)), Array.isArray(s) || (s = Kw()(n.length, s)), (function (e, t, r, n) { for (var i = 1e-5, a = new Array(n.length), o = 0; o < n.length; o++)t[o] === 0 && r[o] === e.maxValue || r[o] === t[o] ? a[o] = 0 : a[o] = (e.maxValue + 1 - i) / (r[o] - t[o]), t[o] += (0.5 - i / 2) / a[o]; for (let s = 0; s < n.length; s++) { const u = n[s]; if (a[s] !== 0) for (let l = 0; l < e.data.length; l += e.channels)e.data[l + u] = Math.min(Math.max(0, (e.data[l + u] - t[s]) * a[s] + 0.5 | 0), e.maxValue); } }(this, a, s, n)), this; } const Jw = __webpack_require__(6990); const ek = __webpack_require__.n(Jw); function tk(e) { if (isNaN(e)) { if (e instanceof mS) return e.data; if (!ek()(e)) throw new Error('checkNumberArray: the value should be either a number, array or Image'); return e; } if (e <= 0) throw new Error('checkNumberArray: the value must be greater than 0'); return e; } function rk(e) { let t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).channels; if (this.checkProcessable('add', { bitDepth: [8, 16] }), t = Ew(this, { channels: t }), e = tk(e), isNaN(e)) { if (this.data.length !== e.length) throw new Error('add: the data size is different'); for (let r = 0; r < t.length; r++) for (let n = t[r], i = 0; i < this.data.length; i += this.channels) this.data[i + n] = Math.max(0, Math.min(this.maxValue, this.data[i + n] + e[i + n] >> 0)); } else for (let a = 0; a < t.length; a++) for (let o = t[a], s = 0; s < this.data.length; s += this.channels) this.data[s + o] = Math.min(this.maxValue, this.data[s + o] + e >> 0); return this; } function nk(e) { let t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).channels; if (this.checkProcessable('subtract', { bitDepth: [8, 16] }), t = Ew(this, { channels: t }), e = tk(e), isNaN(e)) { if (this.data.length !== e.length) throw new Error('subtract: the data size is different'); for (let r = 0; r < t.length; r++) for (let n = t[r], i = 0; i < this.data.length; i += this.channels) this.data[i + n] = Math.max(0, Math.min(this.maxValue, this.data[i + n] - e[i + n] >> 0)); } else for (let a = 0; a < t.length; a++) for (let o = t[a], s = 0; s < this.data.length; s += this.channels) this.data[s + o] = Math.max(0, this.data[s + o] - e >> 0); return this; } function ik(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; let r = t.channels; const n = t.absolute; const i = void 0 !== n && n; if (this.checkProcessable('subtractImage', { bitDepth: [8, 16] }), this.width !== e.width || this.height !== e.height) throw new Error('subtractImage: both images must have the same size'); if (this.alpha !== e.alpha || this.bitDepth !== e.bitDepth) throw new Error('subtractImage: both images must have the same alpha and bitDepth'); if (this.channels !== e.channels) throw new Error('subtractImage: both images must have the same number of channels'); const a = this.clone(); r = Ew(this, { channels: r }); for (let o = 0; o < r.length; o++) for (let s = r[o]; s < this.data.length; s += this.channels) { const u = this.data[s] - e.data[s]; a.data[s] = i ? Math.abs(u) : Math.max(u, 0); } return a; } function ak(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.bitDepth; const n = void 0 === r ? this.bitDepth : r; let i = t.channels; if (this.checkProcessable('hypotenuse', { bitDepth: [8, 16, 32] }), this.width !== e.width || this.height !== e.height) throw new Error('hypotenuse: both images must have the same size'); if (this.alpha !== e.alpha || this.bitDepth !== e.bitDepth) throw new Error('hypotenuse: both images must have the same alpha and bitDepth'); if (this.channels !== e.channels) throw new Error('hypotenuse: both images must have the same number of channels'); const a = mS.createFrom(this, { bitDepth: n }); i = Ew(this, { channels: i }); for (let o = a.isClamped, s = 0; s < i.length; s++) for (let u = i[s]; u < this.data.length; u += this.channels) { const l = Math.hypot(this.data[u], e.data[u]); a.data[u] = o ? Math.min(Math.max(Math.round(l), 0), a.maxValue) : l; } return a; } function ok(e) { let t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).channels; if (this.checkProcessable('multiply', { bitDepth: [8, 16] }), e <= 0) throw new Error('multiply: the value must be greater than 0'); if (t = Ew(this, { channels: t }), e = tk(e), isNaN(e)) { if (this.data.length !== e.length) throw new Error('multiply: the data size is different'); for (let r = 0; r < t.length; r++) for (let n = t[r], i = 0; i < this.data.length; i += this.channels) this.data[i + n] = Math.max(0, Math.min(this.maxValue, this.data[i + n] * e[i + n] >> 0)); } else for (let a = 0; a < t.length; a++) for (let o = t[a], s = 0; s < this.data.length; s += this.channels) this.data[s + o] = Math.min(this.maxValue, this.data[s + o] * e >> 0); return this; } function sk(e) { let t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).channels; if (this.checkProcessable('divide', { bitDepth: [8, 16] }), t = Ew(this, { channels: t }), e = tk(e), isNaN(e)) { if (this.data.length !== e.length) throw new Error('divide: the: the data size is different'); for (let r = 0; r < t.length; r++) for (let n = t[r], i = 0; i < this.data.length; i += this.channels) this.data[i + n] = Math.max(0, Math.min(this.maxValue, this.data[i + n] / e[i + n] >> 0)); } else for (let a = 0; a < t.length; a++) for (let o = t[a], s = 0; s < this.data.length; s += this.channels) this.data[s + o] = Math.min(this.maxValue, this.data[s + o] / e >> 0); return this; } const uk = __webpack_require__(8061); const lk = (function () {
      function e() { if ((0, w.Z)(this, e), (this instanceof e ? this.constructor : void 0) === e) throw new Error('BaseRegression must be subclassed'); } return (0, b.Z)(e, [{ key: 'predict', value(e) { if (typeof e === 'number') return this._predict(e); if ((0, uk.isAnyArray)(e)) { for (var t = [], r = 0; r < e.length; r++)t.push(this._predict(e[r])); return t; } throw new TypeError('x must be a number or array'); } }, { key: '_predict', value() { throw new Error('_predict must be implemented'); } }, { key: 'train', value() {} }, { key: 'toString', value() { return ''; } }, { key: 'toLaTeX', value() { return ''; } }, {
        key: 'score',
        value(e, t) {
          if (!(0, uk.isAnyArray)(e) || !(0, uk.isAnyArray)(t) || e.length !== t.length) throw new Error('x and y must be arrays of the same length'); for (var r = e.length, n = new Array(r), i = 0; i < r; i++)n[i] = this._predict(e[i]); for (var a = 0, o = 0, s = 0, u = 0, l = 0, c = 0, h = 0, f = 0; f < r; f++)a += n[f], o += t[f], l += n[f] * n[f], c += t[f] * t[f], h += n[f] * t[f], t[f] !== 0 && (s += (t[f] - n[f]) * (t[f] - n[f]) / t[f]), u += (t[f] - n[f]) * (t[f] - n[f]); const d = (r * h - a * o) / Math.sqrt((r * l - a * a) * (r * c - o * o)); return {
            r: d, r2: d * d, chi2: s, rmsd: Math.sqrt(u / r),
          };
        },
      }]), e;
    }()); const ck = __webpack_require__(1533); const hk = __webpack_require__.n(ck); const fk = {
      lambda: 0.1, kernelType: 'gaussian', kernelOptions: {}, computeCoefficient: !1,
    }; const dk = (function (e) {
      x(r, e); const t = C(r); function r(e, n, i) { let a; if ((0, w.Z)(this, r), a = t.call(this), !0 === e)a.alpha = n.alpha, a.inputs = n.inputs, a.kernelType = n.kernelType, a.kernelOptions = n.kernelOptions, a.kernel = new (hk())(n.kernelType, n.kernelOptions); else { e = Uw.checkMatrix(e), i = { ...fk, ...i }; const o = new (hk())(i.kernelType, i.kernelOptions); const s = o.compute(e); const u = e.rows; s.add(Uw.eye(u, u).mul(i.lambda)), a.alpha = qw(s, n), a.inputs = e, a.kernelType = i.kernelType, a.kernelOptions = i.kernelOptions, a.kernel = o; } return a; } return (0, b.Z)(r, [{ key: '_predict', value(e) { return this.kernel.compute([e], this.inputs).mmul(this.alpha).getRow(0); } }, {
        key: 'toJSON',
        value() {
          return {
            name: 'kernelRidgeRegression', alpha: this.alpha, inputs: this.inputs, kernelType: this.kernelType, kernelOptions: this.kernelOptions,
          };
        },
      }], [{ key: 'load', value(e) { if (e.name !== 'kernelRidgeRegression') throw new TypeError('not a KRR model'); return new r(!0, e); } }]), r;
    }(lk)); function pk(e, t, r) { for (var n = new dk(e, t, r), i = new Array(this.size), a = 0; a < this.width; a++) for (let o = 0; o < this.height; o++)i[o * this.width + a] = [a, o]; for (var s = n.predict(i), u = mS.createFrom(this), l = 0; l < this.size; l++)u.data[l] = Math.min(this.maxValue, Math.max(0, s[l][0])); return u; } function mk() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.kernel; const r = void 0 === t ? [[1, 1, 1], [1, 1, 1], [1, 1, 1]] : t; const n = e.iterations; const i = void 0 === n ? 1 : n; if (this.checkProcessable('dilate', { bitDepth: [1, 8, 16], components: 1, alpha: 0 }), r.columns % 2 === 0 || r.rows % 2 === 0) throw new TypeError('dilate: The number of rows and columns of the kernel must be odd'); let a; let o = !0; const s = N(r); try { e:for (s.s(); !(a = s.n()).done;) { var u; const l = N(a.value); try { for (l.s(); !(u = l.n()).done;) { if (u.value !== 1) { o = !1; break e; } } } catch (Rv) { l.e(Rv); } finally { l.f(); } } } catch (Rv) { s.e(Rv); } finally { s.f(); } for (var c = this, h = 0; h < i; h++) if (this.bitDepth === 1) if (o) { const f = c.clone(); c = bk(c, f, r.length, r[0].length); } else { c = yk(c, mS.createFrom(c), r); } else if (o) { c = gk(c, mS.createFrom(c), r.length, r[0].length); } else { c = vk(c, mS.createFrom(c), r); } return c; } function vk(e, t, r) { for (let n = r.length, i = r[0].length, a = (n - 1) / 2, o = (i - 1) / 2, s = 0; s < e.height; s++) for (let u = 0; u < e.width; u++) { for (var l = 0, c = 0; c < i; c++) for (let h = 0; h < n; h++) if (r[h][c] === 1) { const f = h - a + u; const d = c - o + s; if (!(f < 0 || d < 0 || f >= e.width || d >= e.height)) { const p = e.getValueXY(f, d, 0); p > l && (l = p); } }t.setValueXY(u, s, 0, l); } return t; } function gk(e, t, r, n) { for (var i = (r - 1) / 2, a = (n - 1) / 2, o = [], s = 0; s < e.width; s++)o.push(0); for (let u = 0; u < e.height; u++) { for (let l = 0; l < e.width; l++) { for (var c = 0, h = Math.max(0, u - a); h < Math.min(e.height, u + a + 1); h++) { const f = e.getValueXY(l, h, 0); f > c && (c = f); }o[l] = c; } for (let d = 0; d < e.width; d++) { for (var p = 0, m = Math.max(0, d - i); m < Math.min(e.width, d + i + 1); m++)o[m] > p && (p = o[m]); t.setValueXY(d, u, 0, p); } } return t; } function yk(e, t, r) { for (let n = r.length, i = r[0].length, a = (n - 1) / 2, o = (i - 1) / 2, s = 0; s < e.height; s++) for (let u = 0; u < e.width; u++) { let l = 0; e:for (let c = 0; c < i; c++) for (let h = 0; h < n; h++) if (r[h][c] === 1) { const f = h - a + u; const d = c - o + s; if (!(d < 0 || f < 0 || f >= e.width || d >= e.height)) if (e.getBitXY(f, d) === 1) { l = 1; break e; } }l === 1 && t.setBitXY(u, s); } return t; } function bk(e, t, r, n) { for (var i = (r - 1) / 2, a = (n - 1) / 2, o = [], s = 0; s < e.width; s++)o.push(1); for (let u = 0; u < e.height; u++) { for (let l = 0; l < e.width; l++) { o[l] = 0; for (let c = Math.max(0, u - a); c < Math.min(e.height, u + a + 1); c++) if (e.getBitXY(l, c) === 1) { o[l] = 1; break; } } for (let h = 0; h < e.width; h++) if (t.getBitXY(h, u) !== 1) for (let f = Math.max(0, h - i); f < Math.min(e.width, h + i + 1); f++) if (o[f] === 1) { t.setBitXY(h, u); break; } } return t; } function wk() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.kernel; const r = void 0 === t ? [[1, 1, 1], [1, 1, 1], [1, 1, 1]] : t; const n = e.iterations; const i = void 0 === n ? 1 : n; if (this.checkProcessable('erode', { bitDepth: [1, 8, 16], components: 1, alpha: 0 }), r.columns % 2 === 0 || r.rows % 2 === 0) throw new TypeError('erode: The number of rows and columns of the kernel must be odd'); let a; let o = !0; const s = N(r); try { e:for (s.s(); !(a = s.n()).done;) { var u; const l = N(a.value); try { for (l.s(); !(u = l.n()).done;) { if (u.value !== 1) { o = !1; break e; } } } catch (Rv) { l.e(Rv); } finally { l.f(); } } } catch (Rv) { s.e(Rv); } finally { s.f(); } for (var c = this, h = 0; h < i; h++) if (this.bitDepth === 1) if (o) { const f = c.clone(); c = Sk(c, f, r.length, r[0].length); } else { c = _k(c, mS.createFrom(c), r); } else if (o) { c = xk(c, mS.createFrom(c), r.length, r[0].length); } else { c = kk(c, mS.createFrom(c), r); } return c; } function kk(e, t, r) { for (let n = r.length, i = r[0].length, a = (n - 1) / 2, o = (i - 1) / 2, s = 0; s < e.height; s++) for (let u = 0; u < e.width; u++) { for (var l = e.maxValue, c = 0; c < i; c++) for (let h = 0; h < n; h++) if (r[h][c] === 1) { const f = h - a + u; const d = c - o + s; if (!(f < 0 || d < 0 || f >= e.width || d >= e.height)) { const p = e.getValueXY(f, d, 0); p < l && (l = p); } }t.setValueXY(u, s, 0, l); } return t; } function xk(e, t, r, n) { for (var i = (r - 1) / 2, a = (n - 1) / 2, o = [], s = 0; s < e.width; s++)o.push(0); for (let u = 0; u < e.height; u++) { for (let l = 0; l < e.width; l++) { for (var c = e.maxValue, h = Math.max(0, u - a); h < Math.min(e.height, u + a + 1); h++) { const f = e.getValueXY(l, h, 0); f < c && (c = f); }o[l] = c; } for (let d = 0; d < e.width; d++) { for (var p = e.maxValue, m = Math.max(0, d - i); m < Math.min(e.width, d + i + 1); m++)o[m] < p && (p = o[m]); t.setValueXY(d, u, 0, p); } } return t; } function _k(e, t, r) { for (let n = r.length, i = r[0].length, a = (n - 1) / 2, o = (i - 1) / 2, s = 0; s < e.height; s++) for (let u = 0; u < e.width; u++) { let l = 1; e:for (let c = 0; c < i; c++) for (let h = 0; h < n; h++) if (r[h][c] === 1) { const f = h - a + u; const d = c - o + s; if (!(d < 0 || f < 0 || f >= e.width || d >= e.height)) if (e.getBitXY(f, d) === 0) { l = 0; break e; } }l === 1 && t.setBitXY(u, s); } return t; } function Sk(e, t, r, n) { for (var i = (r - 1) / 2, a = (n - 1) / 2, o = [], s = 0; s < e.width; s++)o.push(0); for (let u = 0; u < e.height; u++) { for (let l = 0; l < e.width; l++) { o[l] = 1; for (let c = Math.max(0, u - a); c < Math.min(e.height, u + a + 1); c++) if (e.getBitXY(l, c) === 0) { o[l] = 0; break; } } for (let h = 0; h < e.width; h++) if (t.getBitXY(h, u) !== 0) for (let f = Math.max(0, h - i); f < Math.min(e.width, h + i + 1); f++) if (o[f] === 0) { t.clearBitXY(h, u); break; } } return t; } function Mk() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.kernel; const r = void 0 === t ? [[1, 1, 1], [1, 1, 1], [1, 1, 1]] : t; const n = e.iterations; const i = void 0 === n ? 1 : n; if (this.checkProcessable('open', { bitDepth: [8, 16], components: 1, alpha: 0 }), r.columns % 2 === 0 || r.rows % 2 === 0) throw new TypeError('open: The number of rows and columns of the kernel must be odd'); for (var a = this, o = 0; o < i; o++)a = (a = a.erode({ kernel: r })).dilate({ kernel: r }); return a; } function Ek() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.kernel; const r = void 0 === t ? [[1, 1, 1], [1, 1, 1], [1, 1, 1]] : t; const n = e.iterations; const i = void 0 === n ? 1 : n; if (this.checkProcessable('close', { bitDepth: [1, 8, 16], components: 1, alpha: 0 }), r.columns % 2 === 0 || r.rows % 2 === 0) throw new TypeError('close: The number of rows and columns of the kernel must be odd'); for (var a = this, o = 0; o < i; o++)a = a.dilate({ kernel: r }).erode({ kernel: r }); return a; } function Ck() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.kernel; const r = void 0 === t ? [[1, 1, 1], [1, 1, 1], [1, 1, 1]] : t; const n = e.iterations; const i = void 0 === n ? 1 : n; if (this.checkProcessable('topHat', { bitDepth: [8, 16], components: 1, alpha: 0 }), r.length % 2 === 0 || r[0].length % 2 === 0) throw new TypeError('topHat: The number of rows and columns of the kernel must be odd'); for (var a = this, o = 0; o < i; o++) { const s = a.open({ kernel: r }); a = s.subtractImage(a, { absolute: !0 }); } return a; } function Pk() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.kernel; const r = void 0 === t ? [[1, 1, 1], [1, 1, 1], [1, 1, 1]] : t; const n = e.iterations; const i = void 0 === n ? 1 : n; if (this.checkProcessable('blackHat', { bitDepth: [8, 16], components: 1, alpha: 0 }), r.columns % 2 === 0 || r.rows % 2 === 0) throw new TypeError('blackHat: The number of rows and columns of the kernel must be odd'); for (var a = this, o = 0; o < i; o++) { const s = a.close({ kernel: r }); a = s.subtractImage(a, { absolute: !0 }); } return a; } function Ak() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.kernel; const r = void 0 === t ? [[1, 1, 1], [1, 1, 1], [1, 1, 1]] : t; const n = e.iterations; const i = void 0 === n ? 1 : n; if (this.checkProcessable('morphologicalGradient', { bitDepth: [8, 16], components: 1, alpha: 0 }), r.columns % 2 === 0 || r.rows % 2 === 0) throw new TypeError('morphologicalGradient: The number of rows and columns of the kernel must be odd'); for (var a = this, o = 0; o < i; o++) { const s = a.dilate({ kernel: r }); const u = a.erode({ kernel: r }); a = s.subtractImage(u, { absolute: !0 }); } return a; } function Tk(e, t) { return Math.sqrt((e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2); } function Rk(e, t) { return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]]; } function Ik(e, t) { return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]; } function Ok(e, t, r, n, i, a, o, s, u, l, c, h) { const f = (r * e + n * t + i) / (u * e + l * t + 1); const d = (a * e + o * t + s) / (u * e + l * t + 1); return c.getValueXY(Math.floor(f), Math.floor(d), h); } function Dk(e) { const t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).calculateRatio; const r = void 0 === t || t; if (e.length !== 4) throw new Error('The array pts must have four elements, which are the four corners. Currently, pts have '.concat(e.length, ' elements')); let n; let i; const a = d(e, 4); const o = (function (e) { for (var t = 0, r = 0, n = 0, i = 0, a = e[0][0], o = 0, s = 1; s < e.length; s++)e[s][0] < a && (a = e[s][0], o = s); for (var u = e[(o + 1) % e.length][0], l = (o + 1) % e.length, c = 1; c < e.length; c++)e[c][0] < u && c !== o && (u = e[c][0], l = c); return e[l][1] < e[o][1] ? (t = e[l], i = e[o], o !== (l + 1) % 4 ? (r = e[(l + 1) % 4], n = e[(l + 2) % 4]) : (r = e[(l + 2) % 4], n = e[(l + 3) % 4])) : (i = e[l], t = e[o], l !== (o + 1) % 4 ? (r = e[(o + 1) % 4], n = e[(o + 2) % 4]) : (r = e[(o + 2) % 4], n = e[(o + 3) % 4])), [t, r, n, i]; }([a[0], a[1], a[2], a[3]])); const s = d(o, 4); const u = s[0]; const l = s[1]; const c = s[2]; const h = s[3]; if (r) { const f = (function (e, t, r, n, i, a) { const o = Math.max(Tk(e, t), Tk(n, r)); const s = Math.max(Tk(e, n), Tk(t, r)); let u = 0; let l = 0; const c = Math.ceil(i / 2); const h = Math.ceil(a / 2); const f = o / s; const d = [e[0], e[1], 1]; const p = [t[0], t[1], 1]; const m = [n[0], n[1], 1]; const v = [r[0], r[1], 1]; const g = Ik(Rk(d, v), m) / Ik(Rk(p, v), m); const y = Ik(Rk(d, v), p) / Ik(Rk(m, v), p); const b = [g * p[0] - d[0], g * p[1] - d[1], g * p[2] - d[2]]; const w = [y * m[0] - d[0], y * m[1] - d[1], y * m[2] - d[2]]; const k = b[0]; const x = b[1]; const _ = b[2]; const S = w[0]; const M = w[1]; const E = w[2]; let C = 1 / (_ * E) * (k * S - (k * E + _ * S) * c + _ * E * c * c + (x * M - (x * E + _ * M) * h + _ * E * h * h)); C = C >= 0 ? Math.sqrt(C) : Math.sqrt(-C); const P = new Uw([[C, 0, c], [0, C, h], [0, 0, 1]]); const A = P.transpose(); const T = Hw(A); const R = Hw(P); const I = Uw.rowVector(b); const O = Uw.rowVector(w); const D = Math.sqrt(Ik(I.mmul(T).mmul(R).to1DArray(), b) / Ik(O.mmul(T).mmul(R).to1DArray(), w)); return D === 0 || f === 0 ? (u = Math.ceil(o), l = Math.ceil(s)) : D < f ? (u = Math.ceil(o), l = Math.ceil(u / D)) : (l = Math.ceil(s), u = Math.ceil(D * l)), [u, l]; }(u, l, c, h, this.width, this.height)); const p = d(f, 2); n = p[0], i = p[1]; } else n = Math.ceil(Math.max(Tk(u, l), Tk(h, c))), i = Math.ceil(Math.max(Tk(u, h), Tk(l, c))); for (var m = mS.createFrom(this, { width: n, height: i }), v = d(u, 2), g = v[0], y = v[1], b = d(l, 2), w = b[0], k = b[1], x = d(c, 2), _ = x[0], S = x[1], M = d(h, 2), E = M[0], C = M[1], P = n - 1, A = i - 1, T = n - 1, R = i - 1, I = new Uw([[0, 0, 1, 0, 0, 0, -0 * g, -0 * g], [0, P, 1, 0, 0, 0, -0 * w, -P * w], [A, T, 1, 0, 0, 0, -A * _, -0 * _], [R, 0, 1, 0, 0, 0, -R * E, -0 * E], [0, 0, 0, 0, 0, 1, -0 * y, -0 * y], [0, 0, 0, 0, P, 1, -0 * k, -P * k], [0, 0, 0, A, T, 1, -A * S, -T * S], [0, 0, 0, R, 0, 1, -R * C, -0 * C]]), O = Uw.columnVector([g, w, _, E, y, k, S, C]), D = d(new Yw(I).solve(O).to1DArray(), 8), z = D[0], N = D[1], L = D[2], j = D[3], F = D[4], B = D[5], U = D[6], V = D[7], Y = new Uw(i, n), H = 0; H < this.channels; H++) { for (let q = 0; q < i; q++) for (let W = 0; W < n; W++)Y.set(q, W, Ok(q, W, z, N, L, j, F, B, U, V, this, H)); m.setMatrix(Y, { channel: H }); } return m; } function zk() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.x; let r = void 0 === t ? 0 : t; const n = e.y; let i = void 0 === n ? 0 : n; const a = e.width; let o = void 0 === a ? this.width - r : a; const s = e.height; let u = void 0 === s ? this.height - i : s; if (this.checkProcessable('crop', { bitDepth: [1, 8, 16] }), r = Math.round(r), i = Math.round(i), o = Math.round(o), u = Math.round(u), r > this.width - 1 || i > this.height - 1) throw new RangeError('crop: origin (x:'.concat(r, ', y:').concat(i, ') out of range (').concat(this.width - 1, '; ').concat(this.height - 1, ')')); if (o <= 0 || u <= 0) throw new RangeError('crop: width and height (width:'.concat(o, '; height:').concat(u, ') must be positive numbers')); if (r < 0 || i < 0) throw new RangeError('crop: x and y (x:'.concat(r, ', y:').concat(i, ') must be positive numbers')); if (o > this.width - r || u > this.height - i) throw new RangeError('crop: (x: '.concat(r, ', y:').concat(i, ', width:').concat(o, ', height:').concat(u, ') size is out of range')); let l = this; this.bitDepth === 1 ? l = (function (e, t, r, n, i, a) { for (let o = i * e.channels, s = n + a, u = 0, l = r * e.channels, c = n; c < s; c++) for (let h = c * e.width * e.channels + l, f = h + o; h < f; h++)e.getBit(h) && t.setBit(u), ++u; return t; }(this, new mS(o, u, { kind: 'BINARY', parent: this }), r, i, o, u)) : l = (function (e, t, r, n, i, a) { for (let o = i * e.channels, s = n + a, u = 0, l = r * e.channels, c = n; c < s; c++) for (let h = c * e.width * e.channels + l, f = h + o; h < f; h++)t.data[u++] = e.data[h]; return t; }(this, mS.createFrom(this, { width: o, height: u, position: [r, i] }), r, i, o, u)); return l; } function Nk() {
      const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.checkProcessable('cropAlpha', { alpha: 1 }); const t = e.threshold; const r = void 0 === t ? this.maxValue : t; const n = (function (e, t, r) { for (let n = 0; n < e.width; n++) for (let i = 0; i < e.height; i++) if (e.getValueXY(n, i, r) >= t) return n; return -1; }(this, r, this.components)); if (n === -1) throw new Error('Could not find new dimensions. Threshold may be too high.'); const i = (function (e, t, r, n) { for (let i = 0; i < e.height; i++) for (let a = n; a < e.width; a++) if (e.getValueXY(a, i, r) >= t) return i; return -1; }(this, r, this.components, n)); const a = (function (e, t, r, n) { for (let i = e.height - 1; i >= 0; i--) for (let a = n; a < e.width; a++) if (e.getValueXY(a, i, r) >= t) return i; return -1; }(this, r, this.components, n)); const o = (function (e, t, r, n, i, a) { for (let o = e.width - 1; o >= n; o--) for (let s = i; s <= a; s++) if (e.getValueXY(o, s, r) >= t) return o; return -1; }(this, r, this.components, n, i, a)); return this.crop({
        x: n, y: i, width: o - n + 1, height: a - i + 1,
      });
    } function Lk(e, t, r) { e = (function (e) { if (typeof e === 'string') { const t = e[e.length - 1]; e = parseFloat(e), t === '%' && (e /= 100); } return e; }(e)); let n = Math.round(e * t); let i = Math.round(e * r); return n <= 0 && (n = 1), i <= 0 && (i = 1), { width: n, height: i }; } function jk(e, t) { if (t < 0 || t >= e.channels) throw new RangeError('channel must be included between 0 and '.concat(e.channels - 1, '. Current value: ').concat(t)); } const Fk = { nearestneighbor: 'nearestNeighbor', nearestneighbour: 'nearestNeighbor', bilinear: 'bilinear' }; function Bk(e) { if (typeof e !== 'string') throw new TypeError('interpolation must be a string'); if (e = e.toLowerCase(), !Fk[e]) throw new RangeError('invalid interpolation algorithm: '.concat(e)); return Fk[e]; } function Uk(e, t, r) { const n = this.width / t; const i = this.height / r; if (this.bitDepth > 1) for (let a = 0; a < t; a++) for (let o = Math.floor((a + 0.5) * n), s = 0; s < r; s++) for (let u = Math.floor((s + 0.5) * i), l = 0; l < this.channels; l++)e.setValueXY(a, s, l, this.getValueXY(o, u, l)); else for (let c = 0; c < t; c++) for (let h = Math.floor((c + 0.5) * n), f = 0; f < r; f++) { const d = Math.floor((f + 0.5) * i); this.getBitXY(h, d) && e.setBitXY(c, f); } } function Vk() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.factor; const r = void 0 === t ? 1 : t; const n = e.interpolation; const i = void 0 === n ? Fk.nearestneighbor : n; const a = e.preserveAspectRatio; const o = void 0 === a || a; const s = Bk(i); let u = e.width; let l = e.height; u || (u = l && o ? Math.round(l * (this.width / this.height)) : this.width), l || (l = o ? Math.round(u * (this.height / this.width)) : this.height); const c = Lk(r, u, l); if (u = c.width, l = c.height, u === this.width && l === this.height) { const h = this.clone(); return h.position = [0, 0], h; } const f = Math.round((this.width - u) / 2); const d = Math.round((this.height - l) / 2); const p = mS.createFrom(this, { width: u, height: l, position: [f, d] }); if (s !== Fk.nearestneighbor) throw new Error('unsupported resize interpolation: '.concat(s)); return Uk.call(this, p, u, l), p; } function Yk() { this.checkProcessable('hsv', { bitDepth: [8, 16], alpha: [0, 1], colorModel: [mb] }); for (var e = mS.createFrom(this, { colorModel: gb }), t = 0, r = this.data, n = 0; n < r.length; n += this.channels) { const i = r[n]; const a = r[n + 1]; const o = r[n + 2]; const s = Math.min(i, a, o); const u = Math.max(i, a, o); const l = u - s; let c = 0; const h = u === 0 ? 0 : l / u; const f = u; if (u !== s) { switch (u) { case i: c = (a - o) / l + (a < o ? 6 : 0); break; case a: c = (o - i) / l + 2; break; case o: c = (i - a) / l + 4; break; default: throw new Error('unreachable'); }c /= 6; }e.data[t++] = c * this.maxValue, e.data[t++] = h * this.maxValue, e.data[t++] = f, this.alpha && (e.data[t++] = r[n + 3]); } return e; } function Hk() { this.checkProcessable('hsl', { bitDepth: [8, 16], alpha: [0, 1], colorModel: [mb] }); for (var e = mS.createFrom(this, { colorModel: vb }), t = Math.floor(this.maxValue / 2), r = 0, n = this.data, i = 0; i < n.length; i += this.channels) { const a = n[i]; const o = n[i + 1]; const s = n[i + 2]; const u = Math.max(a, o, s); const l = Math.min(a, o, s); let c = 0; let h = 0; const f = (u + l) / 2; if (u !== l) { const d = u - l; switch (h = f > t ? d / (2 - u - l) : d / (u + l), u) { case a: c = (o - s) / d + (o < s ? 6 : 0); break; case o: c = (s - a) / d + 2; break; case s: c = (a - o) / d + 4; break; default: throw new Error('unreachable'); }c /= 6; }e.data[r++] = c * this.maxValue, e.data[r++] = h * this.maxValue, e.data[r++] = f, this.alpha && (e.data[r++] = n[i + 3]); } return e; } function qk() { this.checkProcessable('cmyk', { bitDepth: [8, 16], alpha: [0, 1], colorModel: [mb] }); for (var e = mS.createFrom(this, { components: 4, colorModel: yb }), t = 0, r = this.data, n = 0; n < r.length; n += this.channels) { const i = r[n]; const a = r[n + 1]; const o = r[n + 2]; const s = Math.min(this.maxValue - i, this.maxValue - a, this.maxValue - o); const u = (this.maxValue - i - s) / (1 - s / this.maxValue); const l = (this.maxValue - a - s) / (1 - s / this.maxValue); const c = (this.maxValue - o - s) / (1 - s / this.maxValue); e.data[t++] = Math.round(u), e.data[t++] = Math.round(l), e.data[t++] = Math.round(c), e.data[t++] = Math.round(s), this.alpha && (e.data[t++] = r[n + 3]); } return e; } function Wk() { return new mS(this.width, this.height, this.getRGBAData(), { kind: 'RGBA', parent: this }); } var Xk = {
      luma709(e, t, r) { return 6966 * e + 23436 * t + 2366 * r >> 15; }, luma601(e, t, r) { return 9798 * e + 19235 * t + 3735 * r >> 15; }, maximum(e, t, r) { return Math.max(e, t, r); }, minimum(e, t, r) { return Math.min(e, t, r); }, average(e, t, r) { return (e + t + r) / 3 >> 0; }, minmax(e, t, r) { return (Math.max(e, t, r) + Math.min(e, t, r)) / 2; }, red(e) { return e; }, green(e, t) { return t; }, blue(e, t, r) { return r; }, cyan(e, t, r, n) { const i = Xk.black(e, t, r, n); return (n.maxValue - e - i) / (1 - i / n.maxValue) >> 0; }, magenta(e, t, r, n) { const i = Xk.black(e, t, r, n); return (n.maxValue - t - i) / (1 - i / n.maxValue) >> 0; }, yellow(e, t, r, n) { const i = Xk.black(e, t, r, n); return (n.maxValue - r - i) / (1 - i / n.maxValue) >> 0; }, black(e, t, r, n) { return Math.min(n.maxValue - e, n.maxValue - t, n.maxValue - r); }, hue(e, t, r, n) { const i = Xk.min(e, t, r); const a = Xk.max(e, t, r); if (a === i) return 0; let o = 0; const s = a - i; switch (a) { case e: o = (t - r) / s + (t < r ? 6 : 0); break; case t: o = (r - e) / s + 2; break; case r: o = (e - t) / s + 4; break; default: throw new Error('unreachable'); } return o / 6 * n.maxValue >> 0; }, saturation(e, t, r, n) { const i = Xk.min(e, t, r); const a = Xk.max(e, t, r); return a === 0 ? 0 : (a - i) / a * n.maxValue; }, lightness(e, t, r) { const n = Xk.min(e, t, r); return (Xk.max(e, t, r) + n) / 2; },
    }; Object.defineProperty(Xk, 'luminosity', { enumerable: !1, value: Xk.lightness }), Object.defineProperty(Xk, 'luminance', { enumerable: !1, value: Xk.lightness }), Object.defineProperty(Xk, 'min', { enumerable: !1, value: Xk.minimum }), Object.defineProperty(Xk, 'max', { enumerable: !1, value: Xk.maximum }), Object.defineProperty(Xk, 'brightness', { enumerable: !1, value: Xk.maximum }); const Gk = {}; function $k() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.algorithm; let r = void 0 === t ? 'luma709' : t; const n = e.keepAlpha; let i = void 0 !== n && n; const a = e.mergeAlpha; let o = void 0 === a || a; if (typeof r !== 'string' && typeof r !== 'function') throw new TypeError('algorithm must be a string or a function'); this.checkProcessable('grey', { bitDepth: [8, 16], alpha: [0, 1] }), this.components === 1 && (r = 'red'), i &= this.alpha, o &= this.alpha, i && (o = !1); let s; const u = gw(this, e, { components: 1, alpha: i, colorModel: pb }); if (typeof r === 'function')s = r; else if (!(s = Xk[r.toLowerCase()])) throw new Error('unsupported grey algorithm: '.concat(r)); for (let l = 0, c = 0; c < this.data.length; c += this.channels)o ? u.data[l++] = Lw(s(this.data[c], this.data[c + 1], this.data[c + 2], this) * this.data[c + this.components] / this.maxValue, this) : (u.data[l++] = Lw(s(this.data[c], this.data[c + 1], this.data[c + 2], this), this), u.alpha && (u.data[l++] = this.data[c + this.components])); return u; } function Zk(e) { for (var t = !1, r = 0, n = 1; n < e.length - 1; n++) if (e[n - 1] < e[n] && e[n + 1] < e[n] && ++r > 2) return !1; return r === 2 && (t = !0), t; } function Kk(e, t) { for (var r = 0, n = 0; n <= t; n++)r += e[n]; return r; } function Qk(e, t) { for (var r = 0, n = 0; n <= t; n++)r += n * e[n]; return r; } function Jk(e, t) { for (var r = 0, n = 0; n <= t; n++)r += n * n * e[n]; return r; } function ex(e) { for (var t = new Array(e.length), r = 1; r < e.length - 1; r++)t[r] = (e[r - 1] + e[r] + e[r + 1]) / 3; return t[0] = (e[0] + e[1]) / 3, t[e.length - 1] = (e[e.length - 2] + e[e.length - 1]) / 3, t; } function tx(e) { for (var t = e.length, r = !1, n = 0, i = 1; i < t - 1; i++) if (e[i - 1] < e[i] && e[i + 1] < e[i] && ++n > 2) return !1; return n === 2 && (r = !0), r; } function rx(e, t) { for (var r = 0, n = 0; n <= t; n++)r += e[n]; return r; }Object.keys(Xk).forEach(((e) => { Gk[e] = e; })); const nx = {
      huang(e) { for (var t = 0, r = 0; r < e.length; r++) if (e[r] !== 0) { t = r; break; } for (var n = e.length - 1, i = e.length - 1; i >= t; i--) if (e[i] !== 0) { n = i; break; } for (var a = 1 / (n - t), o = new Array(e.length), s = 0, u = 0, l = t; l < e.length; l++)s += l * e[l], u += e[l], o[l] = s / u; const c = new Array(e.length); s = u = 0; for (let h = n; h > 0; h--)s += h * e[h], u += e[h], c[h - 1] = s / u; for (var f = -1, d = Number.MAX_VALUE, p = 0; p < e.length; p++) { for (var m = 0, v = void 0, g = 0; g <= p; g++)(v = 1 / (1 + a * Math.abs(g - o[p]))) < 1e-6 || v > 0.999999 || (m += e[g] * (-v * Math.log(v) - (1 - v) * Math.log(1 - v))); for (let y = p + 1; y < e.length; y++)(v = 1 / (1 + a * Math.abs(y - c[p]))) < 1e-6 || v > 0.999999 || (m += e[y] * (-v * Math.log(v) - (1 - v) * Math.log(1 - v))); m < d && (d = m, f = p); } return f; }, intermodes(e) { for (var t = e.slice(), r = 0; !Zk(t);) { for (var n = 0, i = 0, a = t[0], o = 0; o < e.length - 1; o++)n = i, i = a, a = t[o + 1], t[o] = (n + i + a) / 3; if (t[e.length - 1] = (i + a) / 3, ++r > 1e4) throw new Error('Intermodes Threshold not found after 10000 iterations'); } for (var s = 0, u = 1; u < e.length - 1; u++)t[u - 1] < t[u] && t[u + 1] < t[u] && (s += u); return Math.floor(s / 2); }, isodata(e) { for (var t, r, n, i, a = 0, o = 1; o < e.length; o++) if (e[o] > 0) { a = o + 1; break; } for (;;) { t = 0, n = 0; for (let s = 0; s < a; s++)n += e[s], t += e[s] * s; i = 0, r = 0; for (let u = a + 1; u < e.length; u++)r += e[u], i += e[u] * u; if (n > 0 && r > 0 && (t /= n, i /= r, a === Math.round((t + i) / 2))) break; if (++a > e.length - 2) throw new Error('Threshold not found'); } return a; }, li(e, t) { let r; let n; let i; let a; let o; let s; let u; let l; let c; let h; let f; h = 0; for (let d = 0; d < e.length; d++)h += d * e[d]; u = h /= t; do { r = (s = u) + 0.5 | 0, n = 0, a = 0; for (let p = 0; p <= r; p++)n += p * e[p], a += e[p]; l = a === 0 ? 0 : n / a, i = 0, o = 0; for (let m = r + 1; m < e.length; m++)i += m * e[m], o += e[m]; u = (f = (l - (c = o === 0 ? 0 : i / o)) / (Math.log(l) - Math.log(c))) < -Number.EPSILON ? f - 0.5 | 0 : f + 0.5 | 0; } while (Math.abs(u - s) > 0.5); return r; }, maxentropy(e, t) { for (var r = new Array(e.length), n = 0; n < e.length; n++)r[n] = e[n] / t; const i = new Array(e.length); const a = new Array(e.length); i[0] = r[0], a[0] = 1 - i[0]; for (let o = 1; o < e.length; o++)i[o] = i[o - 1] + r[o], a[o] = 1 - i[o]; for (var s = 0, u = 0; u < e.length; u++) if (Math.abs(i[u]) >= Number.EPSILON) { s = u; break; } for (var l = e.length - 1, c = e.length - 1; c >= s; c--) if (Math.abs(a[c]) >= Number.EPSILON) { l = c; break; } for (var h, f, d, p = -1, m = Number.MIN_VALUE, v = s; v <= l; v++) { f = 0; for (let g = 0; g <= v; g++)e[g] !== 0 && (f -= r[g] / i[v] * Math.log(r[g] / i[v])); d = 0; for (let y = v + 1; y < e.length; y++)e[y] !== 0 && (d -= r[y] / a[v] * Math.log(r[y] / a[v])); m < (h = f + d) && (m = h, p = v); } return p; }, mean(e, t) { for (var r = 0, n = 0; n < e.length; n++)r += n * e[n]; return Math.floor(r / t); }, minerror(e, t) { for (var r, n, i, a, o, s, u, l, c, h, f, d = -2, p = 0, m = 0; m < e.length; m++)p += m * e[m]; for (r = p /= t; r !== d;) { const v = Kk(e, r); const g = Kk(e, e.length - 1); const y = Qk(e, r); const b = Qk(e, e.length - 1); const w = Jk(e, r); if (a = v / g, o = (g - v) / g, (h = (c = (n = y / v) / (s = w / v - n * n) - (i = (b - y) / (g - v)) / (u = (Jk(e, e.length - 1) - w) / (g - v) - i * i)) * c - (l = 1 / s - 1 / u) * (n * n / s - i * i / u + Math.log10(s * (o * o) / (u * (a * a))))) < 0) return r; d = r, f = (c + Math.sqrt(h)) / l, r = isNaN(f) ? d : Math.floor(f); } return r; }, minimum(e) { if (e.length < 2) return 0; for (var t = 0, r = -1, n = -1, i = new Array(e.length), a = 0; a < e.length; a++)i[a] = e[a], e[a] > 0 && (n = a); for (;!tx(i);) if (i = ex(i), ++t > 1e4) return r; return r = (function (e, t) { for (var r, n = 1; n < t; n++) if (e[n - 1] > e[n] && e[n + 1] >= e[n]) { r = n; break; } return r; }(i, n)), r; }, moments(e, t) { for (var r, n, i, a, o, s, u = 0, l = 0, c = 0, h = 0, f = -1, d = e.length, p = new Array(d), m = 0; m < d; m++)p[m] = e[m] / t; for (let v = 0; v < d; v++)u += v * p[v], l += v * v * p[v], c += v * v * v * p[v]; i = (-l * l + u * c) / (n = 1 * l - u * u), o = 0.5 * (-(a = (1 * -c + l * u) / n) - Math.sqrt(a * a - 4 * i)), r = ((s = 0.5 * (-a + Math.sqrt(a * a - 4 * i))) - u) / (s - o); for (let g = 0; g < d; g++) if ((h += p[g]) > r) { f = g; break; } return f; }, otsu(e, t) { for (var r = 0, n = 0, i = 0, a = 0, o = 0, s = 0; s < e.length; s++)o += s * e[s]; for (let u = 0; u < e.length; u++) { const l = t - (n += e[u]); if (n !== 0 && l !== 0) { const c = (o - (r += u * e[u])) / l; const h = n * l * (r / n - c) * (r / n - c); h >= i && (a = u, i = h); } } return a; }, percentile(e) { for (var t = -1, r = new Array(e.length), n = rx(e, e.length - 1), i = 1, a = 0; a < e.length; a++)r[a] = Math.abs(rx(e, a) / n - 0.5), r[a] < i && (i = r[a], t = a); return t; }, renyientropy(e, t) { for (var r, n, i = new Array(e.length), a = new Array(e.length), o = new Array(e.length), s = 0, u = 0, l = 0, c = 0, h = 0, f = 0, d = 0; d < e.length; d++)i[d] = e[d] / t; a[0] = i[0], o[0] = 1 - a[0]; for (let p = 1; p < e.length; p++)a[p] = a[p - 1] + i[p], o[p] = 1 - a[p]; r = 0; for (let m = 0; m < e.length; m++) if (Math.abs(a[m]) >= Number.EPSILON) { r = m; break; }n = e.length - 1; for (let v = e.length - 1; v >= r; v--) if (Math.abs(o[v]) >= Number.EPSILON) { n = v; break; } for (let g = r; g <= n; g++) { for (var y = 0, b = 0, w = 0, k = 0; k <= g; k++)e[k] !== 0 && (y -= i[k] / a[g] * Math.log(i[k] / a[g])), b += Math.sqrt(i[k] / a[g]), w += i[k] * i[k] / (a[g] * a[g]); for (var x = 0, _ = 0, S = 0, M = g + 1; M < e.length; M++)e[M] !== 0 && (x -= i[M] / o[g] * Math.log(i[M] / o[g])), _ += Math.sqrt(i[M] / o[g]), S += i[M] * i[M] / (o[g] * o[g]); const E = y + x; const C = 2 * (b * _ > 0 ? Math.log(b * _) : 0); const P = -1 * (w * S > 0 ? Math.log(w * S) : 0); E > c && (c = E, s = g), C > h && (h = C, u = g), P > f && (f = P, l = g); } let A; const T = [s, u, l]; T.sort(((e, t) => e - t)), A = Math.abs(T[0] - T[1]) <= 5 ? Math.abs(T[1] - T[2]) <= 5 ? [1, 2, 1] : [0, 1, 3] : Math.abs(T[1] - T[2]) <= 5 ? [3, 1, 0] : [1, 2, 1]; const R = a[T[2]] - a[T[0]]; return Math.round(T[0] * (a[T[0]] + 0.25 * R * A[0]) + 0.25 * T[1] * R * A[1] + T[2] * (o[T[2]] + 0.25 * R * A[2])); }, shanbhag(e, t) { for (var r = new Array(e.length), n = 0; n < e.length; n++)r[n] = e[n] / t; const i = new Array(e.length); const a = new Array(e.length); i[0] = r[0], a[0] = 1 - i[0]; for (let o = 1; o < e.length; o++)i[o] = i[o - 1] + r[o], a[o] = 1 - i[o]; for (var s = 0, u = 0; u < e.length; u++) if (Math.abs(i[u]) >= Number.EPSILON) { s = u; break; } for (var l = e.length - 1, c = e.length - 1; c >= s; c--) if (Math.abs(a[c]) >= Number.EPSILON) { l = c; break; } for (var h, f, d, p, m = -1, v = Number.MAX_VALUE, g = s; g <= l; g++) { d = 0, h = 0.5 / i[g]; for (let y = 1; y <= g; y++)d -= r[y] * Math.log(1 - h * i[y - 1]); d *= h, p = 0, h = 0.5 / a[g]; for (let b = g + 1; b < e.length; b++)p -= r[b] * Math.log(1 - h * a[b]); p *= h, (f = Math.abs(d - p)) < v && (v = f, m = g); } return m; }, triangle(e) { for (var t = 0, r = 0, n = 0, i = 0, a = 0; a < e.length; a++) if (e[a] > 0) { t = a; break; }t > 0 && t--; for (let o = e.length - 1; o > 0; o--) if (e[o] > 0) { i = o; break; }i < e.length - 1 && i++; for (let s = 0; s < e.length; s++)e[s] > r && (n = s, r = e[s]); let u; let l; let c; let h = !1; if (n - t < i - n) { h = !0; for (let f = 0, d = e.length - 1; f < d;) { const p = e[f]; e[f] = e[d], e[d] = p, f++, d--; }t = e.length - 1 - i, n = e.length - 1 - n; } if (t === n) return t; u = e[n], l = t - n, c = (u /= c = Math.sqrt(u * u + l * l)) * t + (l /= c) * e[t]; for (var m = t, v = 0, g = t + 1; g <= n; g++) { const y = u * g + l * e[g] - c; y > v && (m = g, v = y); } if (m--, h) { for (let b = 0, w = e.length - 1; b < w;) { const k = e[b]; e[b] = e[w], e[w] = k, b++, w--; } return e.length - 1 - m; } return m; }, yen(e, t) { for (var r = new Array(e.length), n = 0; n < e.length; n++)r[n] = e[n] / t; const i = new Array(e.length); i[0] = r[0]; for (let a = 1; a < e.length; a++)i[a] = i[a - 1] + r[a]; const o = new Array(e.length); o[0] = r[0] * r[0]; for (let s = 1; s < e.length; s++)o[s] = o[s - 1] + r[s] * r[s]; const u = new Array(e.length); u[e.length - 1] = 0; for (let l = e.length - 2; l >= 0; l--)u[l] = u[l + 1] + r[l + 1] * r[l + 1]; for (var c, h = -1, f = Number.MIN_VALUE, d = 0; d < e.length; d++)(c = -1 * (o[d] * u[d] > 0 ? Math.log(o[d] * u[d]) : 0) + 2 * (i[d] * (1 - i[d]) > 0 ? Math.log(i[d] * (1 - i[d])) : 0)) > f && (f = c, h = d); return h; },
    }; const ix = {}; function ax() { const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).algorithm; const t = void 0 === e ? ix.otsu : e; this.checkProcessable('getThreshold', { components: 1, bitDepth: [8, 16] }); const r = nx[t.toLowerCase()]; if (r) return r(this.getHistogram(), this.size); throw new Error('unknown thresholding algorithm: '.concat(t)); }Object.keys(nx).forEach(((e) => { ix[e] = e; })); const ox = 'threshold'; function sx() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.algorithm; const r = void 0 === t ? ox : t; const n = e.threshold; let i = void 0 === n ? 0.5 : n; const a = e.useAlpha; const o = void 0 === a || a; const s = e.invert; const u = void 0 !== s && s; this.checkProcessable('mask', { components: 1, bitDepth: [8, 16] }), i = r === ox ? (function (e, t) { if (!t) throw Error('getThreshold : the maxValue should be specified'); if (typeof e === 'string') { if (e[e.length - 1] !== '%') throw Error('getThreshold : if the value is a string it must finish by %'); return parseFloat(e) / 100 * t; } if (typeof e === 'number') return e < 1 ? e * t : e; throw Error('getThreshold : the value is not valid'); }(i, this.maxValue)) : ax.call(this, e); const l = new mS(this.width, this.height, { kind: 'BINARY', parent: this }); let c = 0; if (this.alpha && o) for (let h = 0; h < this.data.length; h += this.channels) { const f = this.data[h] + (this.maxValue - this.data[h]) * (this.maxValue - this.data[h + 1]) / this.maxValue; (u && f <= i || !u && f >= i) && l.setBit(c), c++; } else for (let d = 0; d < this.data.length; d += this.channels)(u && this.data[d] <= i || !u && this.data[d] >= i) && l.setBit(c), c++; return l; } function ux() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.size; let r = void 0 === t ? 0 : t; const n = e.algorithm; const i = void 0 === n ? 'copy' : n; let a = e.color; if (this.checkProcessable('pad', { bitDepth: [8, 16] }), i === 'set') { if (a.length !== this.channels) throw new Error('pad: the color array must have the same length as the number of channels. Here: '.concat(this.channels)); for (let o = 0; o < a.length; o++)a[o] === 0 && (a[o] = 0.001); } else a = Kw()(this.channels, null); Array.isArray(r) || (r = [r, r]); const s = this.width + 2 * r[0]; const u = this.height + 2 * r[1]; const l = this.channels; const c = mS.createFrom(this, { width: s, height: u }); !(function (e, t, r, n) { for (let i = e.width, a = e.height, o = t.width, s = e.channels, u = 0; u < i; u++) for (let l = 0; l < a; l++) for (let c = 0; c < s; c++) { const h = (l * i + u) * s + c; const f = ((n + l) * o + r + u) * s + c; t.data[f] = e.data[h]; } }(this, c, r[0], r[1])); for (let h = r[0]; h < s - r[0]; h++) for (let f = 0; f < l; f++) { for (var d = a[f] || c.data[(r[1] * s + h) * l + f], p = 0; p < r[1]; p++)c.data[(p * s + h) * l + f] = d; d = a[f] || c.data[((u - r[1] - 1) * s + h) * l + f]; for (let m = u - r[1]; m < u; m++)c.data[(m * s + h) * l + f] = d; } for (let v = 0; v < u; v++) for (let g = 0; g < l; g++) { for (var y = a[g] || c.data[(v * s + r[0]) * l + g], b = 0; b < r[0]; b++)c.data[(v * s + b) * l + g] = y; y = a[g] || c.data[(v * s + s - r[0] - 1) * l + g]; for (let w = s - r[0]; w < s; w++)c.data[(v * s + w) * l + g] = y; } return c; } function lx() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8; if (this.checkProcessable('colorDepth', { bitDepth: [1, 8, 16] }), ![8, 16].includes(e)) throw Error('You need to specify the new colorDepth as 8 or 16'); if (this.bitDepth === e) return this.clone(); const t = mS.createFrom(this, { bitDepth: e }); switch (e) { case 8: if (this.bitDepth === 1) for (let r = 0; r < this.size; r++) this.getBit(r) && (t.data[r] = 255); else for (let n = 0; n < this.data.length; n++)t.data[n] = this.data[n] >> 8; break; case 16: if (this.bitDepth === 1) for (let i = 0; i < this.size; i++) this.getBit(i) && (t.data[i] = 65535); else for (let a = 0; a < this.data.length; a++)t.data[a] = this.data[a] << 8 | this.data[a]; break; default: throw new Error('colorDepth conversion unexpected case'); } return t; } function cx(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.interpolation; const n = void 0 === r ? Fk.nearestneighbor : r; const i = t.width; const a = void 0 === i ? this.width : i; const o = t.height; const s = void 0 === o ? this.height : o; if (typeof e !== 'number') throw new TypeError('degrees must be a number'); const u = Bk(n); const l = e * Math.PI / 180; const c = Math.floor(Math.abs(a * Math.cos(l)) + Math.abs(s * Math.sin(l))); const h = Math.floor(Math.abs(s * Math.cos(l)) + Math.abs(a * Math.sin(l))); const f = Math.cos(-l); const d = Math.sin(-l); let p = c / 2; let m = h / 2; c % 2 === 0 ? (p -= 0.5, h % 2 === 0 ? m -= 0.5 : m = Math.floor(m)) : (p = Math.floor(p), h % 2 === 0 ? m -= 0.5 : m = Math.floor(m)); const v = Math.floor(a / 2 - p); const g = Math.floor(s / 2 - m); if (this.bitDepth === 1) { const y = new mS(c, h, { kind: 'BINARY', parent: this }); switch (u) { case Fk.nearestneighbor: return (function (e, t, r, n, i, a, o, s) { for (let u = 0; u < t.width; u += 1) for (let l = 0; l < t.height; l += 1) { const c = Math.round((u - i) * o - (l - a) * s + i) + r; const h = Math.round((l - a) * o + (u - i) * s + a) + n; (c < 0 || c >= e.width || h < 0 || h >= e.height || e.getBitXY(c, h)) && t.setBitXY(u, l); } return t; }(this, y, v, g, p, m, f, d)); case Fk.bilinear: return (function (e, t, r, n, i, a, o, s) { for (let u = e.width, l = 0; l < t.height; l++) for (let c = 0; c < t.width; c++) { const h = (c - i) * o - (l - a) * s + i + r; const f = (l - a) * o + (c - i) * s + a + n; const d = 0 | h; const p = 0 | f; const m = h - d; const v = f - p; if (h < 0 || h >= e.width || f < 0 || f >= e.height)t.setBitXY(c, l); else { const g = p * e.width + d; const y = e.getBit(g); const b = e.getBit(g + 1); const w = e.getBit(g + u); (y | m & b - y | v & w - y | m & v & y - b - w + e.getBit(g + 1 + u)) > 0 && t.setBitXY(c, l); } } return t; }(this, y, v, g, p, m, f, d)); default: throw new Error('unsupported rotate interpolation: '.concat(u)); } } else { const b = mS.createFrom(this, { width: c, height: h }); switch (u) { case Fk.nearestneighbor: return (function (e, t, r, n, i, a, o, s) { for (let u = 0; u < t.width; u += 1) for (let l = 0; l < t.height; l += 1) for (let c = 0; c < e.channels; c++) { const h = Math.round((u - i) * o - (l - a) * s + i) + r; const f = Math.round((l - a) * o + (u - i) * s + a) + n; h < 0 || h >= e.width || f < 0 || f >= e.height ? e.alpha === 1 && c === e.channels - 1 ? t.setValueXY(u, l, c, 0) : t.setValueXY(u, l, c, e.maxValue) : t.setValueXY(u, l, c, e.getValueXY(h, f, c)); } return t; }(this, b, v, g, p, m, f, d)); case Fk.bilinear: return (function (e, t, r, n, i, a, o, s) { for (let u = e.width * e.channels, l = 0; l < t.height; l++) for (let c = 0; c < t.width; c++) for (let h = (c - i) * o - (l - a) * s + i + r, f = (l - a) * o + (c - i) * s + a + n, d = 0 | h, p = 0 | f, m = h - d, v = f - p, g = 0; g < e.channels; g++) if (h < 0 || h >= e.width || f < 0 || f >= e.height)e.alpha === 1 && g === e.channels - 1 ? t.setValueXY(c, l, g, 0) : t.setValueXY(c, l, g, e.maxValue); else { const y = (p * e.width + d) * e.channels + g; const b = e.data[y]; const w = e.data[y + e.channels]; const k = e.data[y + u]; const x = b + m * (w - b) + v * (k - b) + m * v * (b - w - k + e.data[y + u + e.channels]) | 0; t.setValueXY(c, l, g, x); } return t; }(this, b, v, g, p, m, f, d)); default: throw new Error('unsupported rotate interpolation: '.concat(u)); } } } function hx(e, t) { if (this.checkProcessable('rotate', { bitDepth: [1, 8, 16] }), typeof e !== 'number') throw new TypeError('angle must be a number'); switch (e < 0 && (e = 360 * Math.ceil(-e / 360) + e), e % 360) { case 0: return this.clone(); case 90: return dx.call(this); case 180: return px.call(this); case 270: return fx.call(this); default: return cx.call(this, e, t); } } function fx() { if (this.bitDepth === 1) { for (var e = new mS(this.height, this.width, { kind: 'BINARY', parent: this }), t = e.height - 1, r = 0; r < this.height; r++) for (let n = 0; n < this.width; n++) this.getBitXY(n, r) && e.setBitXY(r, t - n); return e; } for (var i = mS.createFrom(this, { width: this.height, height: this.width }), a = i.height - 1, o = 0; o < this.height; o++) for (let s = 0; s < this.width; s++) for (let u = 0; u < this.channels; u++)i.setValueXY(o, a - s, u, this.getValueXY(s, o, u)); return i; } function dx() { if (this.bitDepth === 1) { for (var e = new mS(this.height, this.width, { kind: 'BINARY', parent: this }), t = e.width - 1, r = 0; r < this.height; r++) for (let n = 0; n < this.width; n++) this.getBitXY(n, r) && e.setBitXY(t - r, n); return e; } for (var i = mS.createFrom(this, { width: this.height, height: this.width }), a = i.width - 1, o = 0; o < this.height; o++) for (let s = 0; s < this.width; s++) for (let u = 0; u < this.channels; u++)i.setValueXY(a - o, s, u, this.getValueXY(s, o, u)); return i; } function px() { if (this.bitDepth === 1) { for (var e = new mS(this.width, this.height, { kind: 'BINARY', parent: this }), t = e.width - 1, r = e.height - 1, n = 0; n < this.height; n++) for (let i = 0; i < this.width; i++) this.getBitXY(i, n) && e.setBitXY(t - i, r - n); return e; } for (var a = mS.createFrom(this), o = a.width - 1, s = a.height - 1, u = 0; u < this.height; u++) for (let l = 0; l < this.width; l++) for (let c = 0; c < this.channels; c++)a.setValueXY(o - l, s - u, c, this.getValueXY(l, u, c)); return a; } function mx(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = vw(e); this.checkProcessable('insert', r); const n = t.x; const i = void 0 === n ? 0 : n; const a = t.y; const o = void 0 === a ? 0 : a; const s = yw(this, t, { copy: !0 }); const u = Math.min(s.height, o + e.height); const l = Math.min(s.width, i + e.width); if (s.bitDepth === 1) for (let c = o; c < u; c++) for (let h = i; h < l; h++) { e.getBitXY(h - i, c - o) ? s.setBitXY(h, c) : s.clearBitXY(h, c); } else for (let f = o; f < u; f++) for (let d = i; d < l; d++)s.setPixelXY(d, f, e.getPixelXY(d - i, f - o)); return s; } function vx() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.size; let r = void 0 === t ? 0 : t; const n = e.algorithm; const i = void 0 === n ? 'copy' : n; let a = e.color; if (this.checkProcessable('setBorder', { bitDepth: [8, 16, 32, 64] }), i === 'set') { if (a.length !== this.channels) throw new Error('setBorder: the color array must have the same length as the number of channels. Here: '.concat(this.channels)); for (let o = 0; o < a.length; o++)a[o] === 0 && (a[o] = 0.001); } else a = Kw()(this.channels, null); Array.isArray(r) || (r = [r, r]); for (var s = r[0], u = r[1], l = this.channels, c = s; c < this.width - s; c++) for (let h = 0; h < l; h++) { for (var f = a[h] || this.data[(c + this.width * u) * l + h], d = 0; d < u; d++) this.data[(d * this.width + c) * l + h] = f; f = a[h] || this.data[(c + this.width * (this.height - u - 1)) * l + h]; for (let p = this.height - u; p < this.height; p++) this.data[(p * this.width + c) * l + h] = f; } for (let m = 0; m < this.height; m++) for (let v = 0; v < l; v++) { for (var g = a[v] || this.data[(m * this.width + s) * l + v], y = 0; y < s; y++) this.data[(m * this.width + y) * l + v] = g; g = a[v] || this.data[(m * this.width + this.width - s - 1) * l + v]; for (let b = this.width - s; b < this.width; b++) this.data[(m * this.width + b) * l + v] = g; } return this; } function gx() {
      const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).preserveAlpha; const t = void 0 === e || e; if (this.checkProcessable('split', { bitDepth: [8, 16] }), this.components === 1) return new lw([this.clone()]); const r = new lw(); const
        n = this.data; if (this.alpha && t) for (let i = 0; i < this.components; i++) { for (var a = mS.createFrom(this, { components: 1, alpha: !0, colorModel: pb }), o = 0, s = 0; s < n.length; s += this.channels)a.data[o++] = n[s + i], a.data[o++] = n[s + this.components]; r.push(a); } else for (let u = 0; u < this.channels; u++) { for (var l = mS.createFrom(this, { components: 1, alpha: !1, colorModel: pb }), c = 0, h = 0; h < n.length; h += this.channels)l.data[c++] = n[h + u]; r.push(l); } return r;
    } function yx(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.keepAlpha; let n = void 0 !== r && r; const i = t.mergeAlpha; let a = void 0 !== i && i; n &= this.alpha, a &= this.alpha, this.checkProcessable('getChannel', { bitDepth: [8, 16] }), e = Cw(this, e); for (var o = mS.createFrom(this, { components: 1, alpha: n, colorModel: pb }), s = 0, u = 0; u < this.data.length; u += this.channels)a ? o.data[s++] = this.data[u + e] * this.data[u + this.components] / this.maxValue : (o.data[s++] = this.data[u + e], n && (o.data[s++] = this.data[u + this.components])); return o; } function bx() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wx; const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.mergeAlpha; let n = void 0 !== r && r; const i = t.keepAlpha; let a = void 0 !== i && i; n &= this.alpha, a &= this.alpha, this.checkProcessable('combineChannels', { bitDepth: [8, 16] }); for (var o = mS.createFrom(this, { components: 1, alpha: a, colorModel: pb }), s = 0, u = 0; u < this.size; u++) { const l = e(this.getPixel(u)); n ? o.data[s++] = l * this.data[u * this.channels + this.components] / this.maxValue : (o.data[s++] = l, a && (o.data[s++] = this.data[u * this.channels + this.components])); } return o; } function wx(e) { return (e[0] + e[1] + e[2]) / 3; } function kx(e, t) { if (this.checkProcessable('setChannel', { bitDepth: [8, 16] }), t.checkProcessable('setChannel (image parameter check)', { bitDepth: [this.bitDepth], alpha: [0], components: [1] }), t.width !== this.width || t.height !== this.height) throw new Error('Images must have exactly the same width and height'); for (let r = e = Cw(this, e), n = 0; n < t.data.length; n++) this.data[r] = t.data[n], r += this.channels; return this; } function xx(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.shift; const n = void 0 === r ? [0, 0] : r; let i = t.average; let a = t.channels; const o = t.defaultAlpha; const s = t.normalize; const u = t.border; let l = void 0 === u ? [0, 0] : u; if (this.checkProcessable('getSimilarity', { bitDepth: [8, 16] }), Array.isArray(l) || (l = [l, l]), a = Ew(this, { channels: a, defaultAlpha: o }), this.bitDepth !== e.bitDepth) throw new Error('Both images must have the same bitDepth'); if (this.channels !== e.channels) throw new Error('Both images must have the same number of channels'); if (this.colorModel !== e.colorModel) throw new Error('Both images must have the same colorModel'); typeof i === 'undefined' && (i = !0); for (var c = Math.max(l[0], -n[0]), h = Math.min(this.width - l[0], this.width - n[0]), f = Math.max(l[1], -n[1]), d = Math.min(this.height - l[1], this.height - n[1]), p = Kw()(a.length, 0), m = 0; m < a.length; m++) { const v = a[m]; const g = s ? this.sum[v] : Math.max(this.sum[v], e.sum[v]); const y = s ? e.sum[v] : Math.max(this.sum[v], e.sum[v]); if (g !== 0 && y !== 0) for (let b = c; b < h; b++) for (let w = f; w < d; w++) { const k = b * this.multiplierX + w * this.multiplierY + v; const x = k + n[0] * this.multiplierX + n[1] * this.multiplierY; p[m] += Math.min(this.data[k] / g, e.data[x] / y); } } return i ? p.reduce(((e, t) => e + t)) / p.length : p; } function _x() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.sampling; let r = void 0 === t ? [10, 10] : t; const n = e.painted; const i = void 0 !== n && n; const a = e.mask; this.checkProcessable('getPixelsGrid', { bitDepth: [8, 16], channels: 1 }), Array.isArray(r) || (r = [r, r]); for (var o = r[0], s = r[1], u = [], l = [], c = this.width / o, h = this.height / s, f = Math.floor(c / 2), d = 0; d < o; d++) { for (let p = Math.floor(h / 2), m = 0; m < s; m++) { const v = Math.round(f); const g = Math.round(p); a && !a.getBitXY(v, g) || (u.push([v, g]), l.push(this.getPixelXY(v, g))), p += h; }f += c; } const y = { xyS: u, zS: l }; return i && (y.painted = this.rgba8().paintPoints(u)), y; } function Sx(e, t, r) { for (var n = new Array(e), i = 0; i < e; i++)n[i] = new Array(t); if (r) for (let a = 0; a < e; a++) for (let o = 0; o < t; o++)n[a][o] = r; return n.width = e, n.height = t, Object.setPrototypeOf(n, Sx.prototype), n; } function Mx(e) { const t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).border; if (this.checkProcessable('getChannel', { bitDepth: [8, 16] }), this.bitDepth !== e.bitDepth) throw new Error('Both images must have the same bitDepth'); if (this.channels !== e.channels) throw new Error('Both images must have the same number of channels'); if (this.colorModel !== e.colorModel) throw new Error('Both images must have the same colorModel'); for (var r = new Sx(e.width, e.height, -1 / 0), n = Math.floor(e.width / 2), i = Math.floor(e.height / 2), a = n, o = i, s = !1; !s;) { for (let u = r.localSearch(n, i, -1 / 0), l = 0; l < u.length; l++) { const c = u[l]; const h = this.getSimilarity(e, { border: t, shift: [a - c[0], o - c[1]] }); r[c[0]][c[1]] = h; } const f = r.localMax(n, i); f.position[0] !== n || f.position[1] !== i ? (n = f.position[0], i = f.position[1]) : s = !0; } return [n - a, i - o]; } function Ex(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; this.checkProcessable('getRow', { bitDepth: [8, 16] }), (function (e, t) { if (t < 0 || t >= e.height) throw new RangeError('row must be included between 0 and '.concat(e.height - 1, '. Current value: ').concat(t)); }(this, e)), jk(this, t); for (var r = new Array(this.width), n = 0, i = e * this.width * this.channels + t, a = i + this.width * this.channels, o = i; o < a; o += this.channels)r[n++] = this.data[o]; return r; } function Cx(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; this.checkProcessable('getColumn', { bitDepth: [8, 16] }), (function (e, t) { if (t < 0 || t >= e.width) throw new RangeError('column must be included between 0 and '.concat(e.width - 1, '. Current value: ').concat(t)); }(this, e)), jk(this, t); for (var r = new Array(this.height), n = 0, i = this.width * this.channels, a = t + e * this.channels; a < this.data.length; a += i)r[n++] = this.data[a]; return r; } function Px() { let e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).channel; if (this.checkProcessable('getMatrix', { bitDepth: [8, 16] }), void 0 === e) { if (this.components > 1) throw new RangeError('You need to define the channel for an image that contains more than one channel'); e = 0; } for (var t = new Uw(this.height, this.width), r = 0; r < this.height; r++) for (let n = 0; n < this.width; n++)t.set(r, n, this.getValueXY(n, r, e)); return t; } function Ax(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; e = new Uw(e); let r = t.channel; if (this.checkProcessable('getMatrix', { bitDepth: [8, 16] }), void 0 === r) { if (this.components > 1) throw new RangeError('You need to define the channel for an image that contains more than one channel'); r = 0; } if (this.width !== e.columns || this.height !== e.rows) throw new RangeError('The size of the matrix must be equal to the size of the image'); for (let n = 0; n < this.height; n++) for (let i = 0; i < this.width; i++) this.setValueXY(i, n, r, e.get(n, i)); return this; } function Tx() { this.checkProcessable('getPixelsArray', { bitDepth: [8, 16, 32] }); for (var e = new Array(this.size), t = 0, r = 0; r < this.data.length; r += this.channels) { for (var n = new Array(this.components), i = 0; i < this.components; i++)n[i] = this.data[r + i]; e[t++] = n; } return e; } function Rx(e) { for (var t = this, r = t.getClosestCommonParent(e), n = t.getRelativePosition(r, { defaultFurther: !0 }), i = Ix(t, n), a = e.getRelativePosition(r, { defaultFurther: !0 }), o = Ix(e, a), s = (function (e, t) { let r = 0; let n = 0; const i = []; for (;r < e.length && n < t.length;)e[r][0] === t[n][0] && e[r][1] === t[n][1] ? (i.push(e[r]), r++, n++) : e[r][0] < t[n][0] || e[r][0] === t[n][0] && e[r][1] < t[n][1] ? r++ : n++; return i; }(i, o)), u = { whitePixelsMask1: [], whitePixelsMask2: [], commonWhitePixels: [] }, l = 0; l < s.length; l++) { const c = s[l]; const h = [c[0] - n[0], c[1] - n[1]]; const f = [c[0] - a[0], c[1] - a[1]]; const d = t.getBitXY(h[0], h[1]); const p = e.getBitXY(f[0], f[1]); d === 1 && p === 1 && u.commonWhitePixels.push(c); } for (let m = 0; m < i.length; m++) { let v = void 0; let g = void 0; m !== 0 && (v = Math.floor(m / t.width), g = m % t.width), t.getBitXY(v, g) === 1 && u.whitePixelsMask1.push(i[m]); } for (let y = 0; y < o.length; y++) { let b = 0; let w = 0; y !== 0 && (b = Math.floor(y / e.width), w = y % e.width), e.getBitXY(b, w) === 1 && u.whitePixelsMask2.push(o[y]); } return u; } function Ix(e, t) { for (var r = [], n = 0; n < e.height; n++) for (let i = 0; i < e.width; i++) { const a = [n, i]; r.push([a[0] + t[0], a[1] + t[1]]); } return r; } function Ox(e) { let t; let r = Dx(this); let n = Dx(e); if (t = r >= n ? zx(this, r) : zx(e, n), r === 0 || n === 0) return t; for (var i = this, a = e; r !== n;) if (r > n) { if ((i = i.parent) === null) return t; r -= 1; } else { if ((a = a.parent) === null) return t; n -= 1; } for (;i !== a && i !== null && a !== null;) if (i = i.parent, a = a.parent, i === null || a === null) return t; return i !== a ? t : i; } function Dx(e) { for (var t = 0, r = e; r.parent != null;)r = r.parent, t++; return t; } function zx(e, t) { for (var r = e; t > 0;)r = r.parent, t -= 1; return r; }Sx.prototype.localMin = function (e, t) { for (var r = this[e][t], n = [e, t], i = Math.max(0, e - 1); i < Math.min(this.length, e + 2); i++) for (let a = Math.max(0, t - 1); a < Math.min(this[0].length, t + 2); a++) this[i][a] < r && (r = this[i][a], n = [i, a]); return { position: n, value: r }; }, Sx.prototype.localMax = function (e, t) { for (var r = this[e][t], n = [e, t], i = Math.max(0, e - 1); i < Math.min(this.length, e + 2); i++) for (let a = Math.max(0, t - 1); a < Math.min(this[0].length, t + 2); a++) this[i][a] > r && (r = this[i][a], n = [i, a]); return { position: n, value: r }; }, Sx.prototype.localSearch = function (e, t, r) { for (var n = [], i = Math.max(0, e - 1); i < Math.min(this.length, e + 2); i++) for (let a = Math.max(0, t - 1); a < Math.min(this[0].length, t + 2); a++) this[i][a] === r && n.push([i, a]); return n; }; const Nx = { lowThreshold: 10, highThreshold: 30, gaussianBlur: 1.1 }; const Lx = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]; const jx = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]]; const Fx = { bitDepth: 32, mode: 'periodic' }; function Bx(e) { return (function (e, t) { e.checkProcessable('Canny edge detector', { bitDepth: 8, channels: 1, components: 1 }), t = { ...Nx, ...t }; for (var r = e.width, n = e.height, i = e.maxValue, a = { sigma: t.gaussianBlur, radius: 3 }, o = e.gaussianFilter(a), s = o.convolution(jx, Fx), u = o.convolution(Lx, Fx), l = u.hypotenuse(s), c = e.constructor, h = new c(r, n, { kind: 'GREY', bitDepth: 32 }), f = new c(r, n, { kind: 'GREY', bitDepth: 32 }), d = new c(r, n, { kind: 'GREY' }), p = 1; p < r - 1; p++) for (var m = 1; m < n - 1; m++) { const v = (Math.round(Math.atan2(u.getValueXY(p, m, 0), s.getValueXY(p, m, 0)) * (5 / Math.PI)) + 5) % 5; v === 0 && (l.getValueXY(p, m, 0) <= l.getValueXY(p, m - 1, 0) || l.getValueXY(p, m, 0) <= l.getValueXY(p, m + 1, 0)) || v === 1 && (l.getValueXY(p, m, 0) <= l.getValueXY(p - 1, m + 1, 0) || l.getValueXY(p, m, 0) <= l.getValueXY(p + 1, m - 1, 0)) || v === 2 && (l.getValueXY(p, m, 0) <= l.getValueXY(p - 1, m, 0) || l.getValueXY(p, m, 0) <= l.getValueXY(p + 1, m, 0)) || v === 3 && (l.getValueXY(p, m, 0) <= l.getValueXY(p - 1, m - 1, 0) || l.getValueXY(p, m, 0) <= l.getValueXY(p + 1, m + 1, 0)) || h.setValueXY(p, m, 0, l.getValueXY(p, m, 0)); } for (p = 0; p < r * n; ++p) { const g = h.data[p]; let y = 0; g > t.highThreshold && (y++, d.data[p] = i), g > t.lowThreshold && y++, f.data[p] = y; } let b = []; for (p = 1; p < r - 1; ++p) for (m = 1; m < n - 1; ++m) if (f.getValueXY(p, m, 0) === 1)e:for (var w = p - 1; w < p + 2; ++w) for (let k = m - 1; k < m + 2; ++k) if (f.getValueXY(w, k, 0) === 2) { b.push([p, m]), d.setValueXY(p, m, 0, i); break e; } for (;b.length > 0;) { const x = []; for (p = 0; p < b.length; ++p) for (m = -1; m < 2; ++m) for (w = -1; w < 2; ++w) if (m !== 0 || w !== 0) { const _ = b[p][0] + m; const S = b[p][1] + w; f.getValueXY(_, S, 0) === 1 && d.getValueXY(_, S, 0) === 0 && (x.push([_, S]), d.setValueXY(_, S, 0, i)); }b = x; } return d; }(this, e)); } function Ux(e) {
      let t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).position; if (this.checkProcessable('extract', { bitDepth: [1, 8, 16] }), !t && !(t = e.getRelativePosition(this))) throw new Error('extract : can not extract an image because the relative position can not be determined, try to specify manually the position as an array of 2 elements [x,y].'); if (this.bitDepth > 1) {
        for (var r = mS.createFrom(this, {
            width: e.width, height: e.height, alpha: 1, position: t, parent: this,
          }), n = 0; n < e.width; n++) for (let i = 0; i < e.height; i++) { for (let a = 0; a < this.channels; a++) { const o = this.getValueXY(n + t[0], i + t[1], a); r.setValueXY(n, i, a, o); }e.getBitXY(n, i) || r.setValueXY(n, i, this.components, 0); } return r;
      } for (var s = mS.createFrom(this, {
          width: e.width, height: e.height, position: t, parent: this,
        }), u = 0; u < e.height; u++) for (let l = 0; l < e.width; l++)e.getBitXY(l, u) && this.getBitXY(l + t[0], u + t[1]) && s.setBitXY(l, u); return s;
    } const Vx = __webpack_require__(2847); const Yx = __webpack_require__.n(Vx); function Hx() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.x; const r = void 0 === t ? 0 : t; const n = e.y; const i = void 0 === n ? 0 : n; const a = e.inPlace; const o = void 0 === a || a ? this : mS.createFrom(this); if (this.checkProcessable('floodFill', { bitDepth: 1 }), this.getBitXY(r, i)) return o; const s = new (Yx())(); for (s.push(new qx(r, i)); s.length > 0;) { const u = s.shift(); o.setBitXY(u.x, u.y); for (let l = u.x + 1; l < this.width && (!o.getBitXY(l, u.y) && !this.getBitXY(l, u.y)); l++)o.setBitXY(l, u.y), u.y + 1 < this.height && !this.getBitXY(l, u.y + 1) && s.push(new qx(l, u.y + 1)), u.y - 1 >= 0 && !this.getBitXY(l, u.y - 1) && s.push(new qx(l, u.y - 1)); for (let c = u.x - 1; c >= 0 && (!o.getBitXY(c, u.y) && !this.getBitXY(c, u.y)); c++)o.setBitXY(c, u.y), u.y + 1 < this.height && !this.getBitXY(c, u.y + 1) && s.push(new qx(c, u.y + 1)), u.y - 1 >= 0 && !this.getBitXY(c, u.y - 1) && s.push(new qx(c, u.y - 1)); } return o; } function qx(e, t) { this.x = e, this.y = t; } function Wx(e, t, r) { let n = []; const i = (r /= 100) * (t /= 100); const a = e / 60; const o = i * (1 - Math.abs(a % 2 - 1)); const s = r - i; return n = a >= 0 && a < 1 ? [i, o, 0] : a >= 1 && a < 2 ? [o, i, 0] : a >= 2 && a < 3 ? [0, i, o] : e >= 3 && a < 4 ? [0, o, i] : e >= 4 && a < 5 ? [o, 0, i] : e >= 5 && a <= 6 ? [i, 0, o] : [0, 0, 0], { r: Math.round(255 * (n[0] + s)), g: Math.round(255 * (n[1] + s)), b: Math.round(255 * (n[2] + s)) }; } function Xx(e, t, r) { const n = (function (e, t, r) { return { h: e, s: 2 * (t *= (r < 50 ? r : 100 - r) / 100) / (r + t) * 100, v: r + t }; }(e, t, r)); return Wx(n.h, n.s, n.v); } const Gx = {
      aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 132, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 255, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 203], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [119, 128, 144], slategrey: [119, 128, 144], snow: [255, 255, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 5],
    }; function $x(e) {
      return (function (e) {
        const t = Gx[e.toLowerCase()]; if (!t) return; return {
          r: t[0], g: t[1], b: t[2], a: 100,
        };
      }(e)) || (function (e) {
        if (e[0] === '#' && e.length === 4) {
          return {
            r: parseInt(e[1] + e[1], 16), g: parseInt(e[2] + e[2], 16), b: parseInt(e[3] + e[3], 16), a: 100,
          };
        }
      }(e)) || (function (e) {
        if (e[0] === '#' && e.length === 7) {
          return {
            r: parseInt(e.slice(1, 3), 16), g: parseInt(e.slice(3, 5), 16), b: parseInt(e.slice(5, 7), 16), a: 100,
          };
        }
      }(e)) || (function (e) {
        const t = e.match(/rgb\(([^)]+)\)/); if (t) {
          const r = t[1].split(/ *, */).map(Number); return {
            r: r[0], g: r[1], b: r[2], a: 100,
          };
        }
      }(e)) || (function (e) {
        const t = e.match(/rgba\(([^)]+)\)/); if (t) {
          const r = t[1].split(/ *, */).map(Number); return {
            r: r[0], g: r[1], b: r[2], a: 100 * r[3],
          };
        }
      }(e)) || (function (e) { const t = e.match(/hsl\(([^)]+)\)/); if (t) { const r = t[1].split(/ *, */); return Tn({}, Xx(parseInt(r[0], 10), parseInt(r[1], 10), parseInt(r[2], 10)), { a: 100 }); } }(e)) || (function (e) { const t = e.match(/hsla\(([^)]+)\)/); if (t) { const r = t[1].split(/ *, */); const n = parseInt(r[0], 10); const i = parseInt(r[1], 10); const a = parseInt(r[2], 10); const o = parseInt(100 * parseFloat(r[3]), 10); return Tn({}, Xx(n, i, a), { a: o }); } }(e));
    } function Zx(e) { const t = $x(e); return [t.r, t.g, t.b, Math.round(255 * t.a / 100)]; } function Kx(e, t, r) { return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + 6 * (t - e) * r : r < 0.5 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e; } function Qx(e, t, r) { let n; let i; let a; let o; let s; let u; return r /= 100, (t /= 100) === 0 ? o = s = u = 255 * r : (o = Kx(n = 2 * r - (i = r <= 0.5 ? r * (t + 1) : r + t - r * t), i, (a = e / 360) + 1 / 3), s = Kx(n, i, a), u = Kx(n, i, a - 1 / 3)), { r: o, g: s, b: u }; } function Jx(e) { let t = e.color; let r = e.colors; const n = e.randomColors; const i = e.numberColors; const a = void 0 === i ? 50 : i; if (t && !Array.isArray(t) && (t = Zx(t)), t) return [t]; if (r) return r = r.map(((e) => (Array.isArray(e) ? e : Zx(e)))), r; if (n) { r = new Array(a); for (let o = 0; o < a; o++)r[o] = [Math.floor(256 * Math.random()), Math.floor(256 * Math.random()), Math.floor(256 * Math.random())]; } return (function (e) { for (var t = new Array(e), r = 0, n = 0; n < 360; n += 360 / e) { const i = Qx(n, 100, 30 + ++r % 4 * 15); t[r - 1] = [Math.round(255 * i.r), Math.round(255 * i.g), Math.round(255 * i.b)]; } return t; }(a)); } function e_(e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const n = r.color; let i = void 0 === n ? 'blue' : n; let a = r.colors; const o = r.font; let s = void 0 === o ? '12px Helvetica' : o; const u = r.rotate; let l = void 0 === u ? 0 : u; if (this.checkProcessable('paintMasks', { channels: [3, 4], bitDepth: [8, 16], colorModel: mb }), !Array.isArray(e)) throw Error('paintLabels: labels must be an array'); if (!Array.isArray(t)) throw Error('paintLabels: positions must be an array'); if (i && !Array.isArray(i) && (i = Zx(i)), a = a ? a.map(((e) => (Array.isArray(e) ? e : Zx(e)))) : [i], e.length !== t.length) throw Error('paintLabels: positions and labels must be arrays from the same size'); Array.isArray(s) || (s = [s]), Array.isArray(l) || (l = [l]); for (var c = this.getCanvas().getContext('2d'), h = 0; h < e.length; h++) { c.save(); const f = a[h % a.length]; c.fillStyle = 'rgba('.concat(f[0], ',').concat(f[1], ',').concat(f[2], ',').concat(f[3] / this.maxValue, ')'), c.font = s[h % s.length]; const d = t[h]; c.translate(d[0], d[1]), c.rotate(l[h % l.length] / 180 * Math.PI), c.fillText(e[h], 0, 0), c.restore(); } return this.data = Uint8Array.from(c.getImageData(0, 0, this.width, this.height).data), this; } function t_(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.alpha; const n = void 0 === r ? 255 : r; const i = t.labels; const a = void 0 === i ? [] : i; const o = t.labelsPosition; const s = void 0 === o ? [] : o; const u = t.labelColor; const l = void 0 === u ? 'blue' : u; const c = t.labelFont; const h = void 0 === c ? '12px Helvetica' : c; this.checkProcessable('paintMasks', { channels: [3, 4], bitDepth: [8, 16], colorModel: mb }); const f = Jx({ ...t, numberColors: e.length }); Array.isArray(e) || (e = [e]); for (let d = 0; d < e.length; d++) for (let p = e[d], m = f[d % f.length], v = 0; v < p.width; v++) for (let g = 0; g < p.height; g++) if (p.getBitXY(v, g)) for (let y = 0; y < Math.min(this.components, m.length); y++) if (n === 255) this.setValueXY(v + p.position[0], g + p.position[1], y, m[y]); else { let b = this.getValueXY(v + p.position[0], g + p.position[1], y); b = Math.round((b * (255 - n) + m[y] * n) / 255), this.setValueXY(v + p.position[0], g + p.position[1], y, b); } if (Array.isArray(a) && a.length > 0) { const w = this.getCanvas().getContext('2d'); w.fillStyle = l, w.font = h; for (let k = 0; k < Math.min(e.length, a.length); k++) { const x = s[k] ? s[k] : e[k].position; w.fillText(a[k], x[0], x[1]); } this.data = Uint8Array.from(w.getImageData(0, 0, this.width, this.height).data); } return this; } function r_(e, t) { for (var r = new Array(e), n = 0; n < e; n++)r[n] = new Array(t).fill(0); return r; } const n_ = [[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]]; const i_ = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]; const a_ = (function () { function e() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; (0, w.Z)(this, e); const r = t.kind; const n = void 0 === r ? 'cross' : r; const i = t.shape; const a = t.size; let o = t.width; let s = t.height; const u = t.filled; const l = void 0 === u || u; if (a && (o = a, s = a), i) switch (i.toLowerCase()) { case 'square': case 'rectangle': this.matrix = (function (e, t, r) { const n = r_(t, e); if (r.filled) for (let i = 0; i < t; i++) for (let a = 0; a < e; a++)n[i][a] = 1; else { for (let o = 0, s = [0, t - 1]; o < s.length; o++) for (let u = s[o], l = 0; l < e; l++)n[u][l] = 1; for (let c = 0; c < t; c++) for (let h = 0, f = [0, e - 1]; h < f.length; h++) { const d = f[h]; n[c][d] = 1; } } return n; }(o, s, { filled: l })); break; case 'circle': case 'ellipse': this.matrix = (function (e, t, r) { const n = r_(t, e); const i = 1 - t % 2; const a = 1 - e % 2; const o = Math.floor((e - 1) / 2); const s = Math.floor((t - 1) / 2); const u = o * o; const l = s * s; if (r.filled) for (let c = 0; c <= s; c++) for (let h = o - Math.floor(Math.sqrt(u - u * c * c / l)); h <= o; h++)n[s - c][h] = 1, n[s + c + i][h] = 1, n[s - c][e - h - 1] = 1, n[s + c + i][e - h - 1] = 1; else { for (let f = 0; f <= s; f++) { const d = o - Math.floor(Math.sqrt(u - u * f * f / l)); n[s - f][d] = 1, n[s + f + i][d] = 1, n[s - f][e - d - 1] = 1, n[s + f + i][e - d - 1] = 1; } for (let p = 0; p <= o; p++) { const m = s - Math.floor(Math.sqrt(l - l * p * p / u)); n[m][o - p] = 1, n[m][o + p + a] = 1, n[t - m - 1][o - p] = 1, n[t - m - 1][o + p + a] = 1; } } return n; }(o, s, { filled: l })); break; case 'triangle': this.matrix = (function (e, t, r) { if (!r.filled) throw new Error('Non filled triangle is not implemented'); for (var n = r_(t, e), i = 0; i < t; i++) for (let a = Math.floor((1 - i / t) * e / 2), o = a; o < e - a; o++)n[i][o] = 1; return n; }(o, s, { filled: l })); break; default: throw new Error('Shape: unexpected shape: '.concat(i)); } else { if (!n) throw new Error('Shape: expected a kind or a shape option'); switch (n.toLowerCase()) { case 'cross': this.matrix = n_; break; case 'smallcross': this.matrix = i_; break; default: throw new Error('Shape: unexpected kind: '.concat(n)); } } this.height = this.matrix.length, this.width = this.matrix[0].length, this.halfHeight = this.height / 2 >> 0, this.halfWidth = this.width / 2 >> 0; } return (0, b.Z)(e, [{ key: 'getPoints', value() { for (var e = this.matrix, t = [], r = 0; r < e.length; r++) for (let n = 0; n < e[0].length; n++)e[r][n] && t.push([n - this.halfWidth, r - this.halfHeight]); return t; } }, { key: 'getMask', value() { for (var e = new mS(this.width, this.height, { kind: bb }), t = 0; t < this.matrix.length; t++) for (let r = 0; r < this.matrix[0].length; r++) this.matrix[t][r] && e.setBitXY(r, t); return e; } }]), e; }()); function o_(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.shape; this.checkProcessable('paintPoints', { bitDepth: [8, 16] }); for (let n = Jx({ ...t, numberColors: e.length }), i = new a_(r).getPoints(), a = Math.min(this.channels, n[0].length), o = 0; o < e.length; o++) for (let s = n[o % n.length], u = e[o][0], l = e[o][1], c = 0; c < i.length; c++) { const h = i[c][0]; const f = i[c][1]; if (u + h >= 0 && l + f >= 0 && u + h < this.width && l + f < this.height) for (let d = (u + h + (l + f) * this.width) * this.channels, p = 0; p < a; p++) this.data[d + p] = s[p]; } return this; } function s_(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.color; const n = void 0 === r ? [this.maxValue, 0, 0] : r; const i = t.closed; const a = void 0 !== i && i; this.checkProcessable('paintPoints', { bitDepth: [1, 8, 16] }); for (let o = Math.min(this.channels, n.length), s = 0; s < e.length - 1 + a; s++) for (let u = e[s], l = e[(s + 1) % e.length], c = l[0] - u[0], h = l[1] - u[1], f = Math.max(Math.abs(c), Math.abs(h)), d = c / f, p = h / f, m = u[0], v = u[1], g = 0; g <= f; g++) { const y = Math.round(m); const b = Math.round(v); if (y >= 0 && b >= 0 && y < this.width && b < this.height) if (this.bitDepth === 1) this.setBitXY(y, b); else for (let w = (y + b * this.width) * this.channels, k = 0; k < o; k++) this.data[w + k] = n[k]; m += d, v += p; } return this; } function u_(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = { ...t }; this.checkProcessable('paintPolylines', { bitDepth: [8, 16] }); for (let n = Jx({ ...t, numberColors: e.length }), i = 0; i < e.length; i++)r.color = n[i % n.length], this.paintPolyline(e[i], r); return this; } function l_(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.color; const n = void 0 === r ? [this.maxValue, 0, 0] : r; const i = t.filled; const a = void 0 !== i && i; this.checkProcessable('paintPoints', { bitDepth: [1, 8, 16] }), t.closed = !0; const o = (function (e) { for (var t = [], r = 0; r < e.length; r++)e[r][0] === e[(r + 1) % e.length][0] && e[r][1] === e[(r + 1) % e.length][1] || e[r][0] === e[(r - 1 + e.length) % e.length][0] && e[r][1] === e[(r - 1 + e.length) % e.length][1] || e[(r + 1) % e.length][0] === e[(r - 1 + e.length) % e.length][0] && e[(r - 1 + e.length) % e.length][1] === e[(r + 1) % e.length][1] || t.push(e[r]); return t; }(e)); if (!1 === a) return this.paintPolyline(e, t); for (var s = Array(this.height), u = 0; u < this.height; u++) { s[u] = []; for (let l = 0; l < this.width; l++)s[u].push(0); } for (let c = 0; c < o.length; c++) for (let h = c_(o[c], o[(c + 1) % o.length]), f = 0; f < this.height; f++) for (let d = 0; d < this.width; d++)h_(d, f, h, this.height) && (s[f][d] = s[f][d] === 0 ? 1 : 0); for (let p = 0; p < this.height; p++) for (let m = 0; m < this.width; m++) if (s[p][m] === 1) if (this.bitDepth === 1) this.setBitXY(m, p); else for (let v = Math.min(this.channels, n.length), g = (m + p * this.width) * this.channels, y = 0; y < v; y++) this.data[g + y] = n[y]; return this.paintPolyline(e, t); } function c_(e, t) { if (e[0] === t[0]) return { a: 0, b: e[0], vertical: !0 }; const r = (t[1] - e[1]) / (t[0] - e[0]); return { a: r, b: e[1] - r * e[0], vertical: !1 }; } function h_(e, t, r, n) { if (!0 === r.vertical) return r.b <= e; if (r.a === 0) return !1; const i = (t - r.b) / r.a; return i < e && i >= 0 && i <= n; } function f_(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = { ...t }; this.checkProcessable('paintPolygons', { bitDepth: [8, 16] }); for (let n = Jx({ ...t, numberColors: e.length }), i = 0; i < e.length; i++)r.color = n[i % n.length], this.paintPolygon(e[i], r); return this; } function d_() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.maxSlots; const r = void 0 === t ? 256 : t; let n = e.channel; const i = e.useAlpha; const a = void 0 === i || i; if (this.checkProcessable('getHistogram', { bitDepth: [1, 8, 16] }), void 0 === n) { if (this.components > 1) throw new RangeError('You need to define the channel for an image that contains more than one channel'); n = 0; } return m_.call(this, n, { useAlpha: a, maxSlots: r }); } function p_() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.maxSlots; const r = void 0 === t ? 256 : t; const n = e.useAlpha; const i = void 0 === n || n; this.checkProcessable('getHistograms', { bitDepth: [8, 16] }); for (var a = new Array(i ? this.components : this.channels), o = 0; o < a.length; o++)a[o] = m_.call(this, o, { useAlpha: i, maxSlots: r }); return a; } function m_(e, t) { const r = t.useAlpha; const n = t.maxSlots; if (this.bitDepth === 1) { for (var i = [0, 0], a = 0; a < this.height; a++) for (let o = 0; o < this.width; o++) { const s = this.getBitXY(a, o); s === 0 ? i[0] += 1 : s === 1 && (i[1] += 1); } return i; } const u = Math.log2(n); if (!Nw()(u)) throw new RangeError('maxSlots must be a power of 2, for example: 64, 256, 1024'); let l = 0; this.bitDepth > u && (l = this.bitDepth - u); const c = this.data; const h = Kw()(2 ** Math.min(this.bitDepth, u), 0); if (r && this.alpha) for (let f = this.channels - e - 1, d = e; d < c.length; d += this.channels)h[c[d] >> l] += c[d + f] / this.maxValue; else for (let p = e; p < c.length; p += this.channels)h[c[p] >> l]++; return h; } function v_() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.useAlpha; const r = void 0 === t || t; const n = e.nbSlots; const i = void 0 === n ? 512 : n; this.checkProcessable('getColorHistogram', { bitDepth: [8, 16], components: [3] }); const a = Math.log(i) / Math.log(8); if (a !== Math.floor(a)) throw new RangeError('nbSlots must be a power of 8. Usually 8, 64, 512 or 4096'); for (var o = this.bitDepth - a, s = this.data, u = Kw()(8 ** a, 0), l = 2 ** (2 * a), c = 2 ** a, h = 0; h < s.length; h += this.channels) { const f = (s[h] >> o) * l + (s[h + 1] >> o) * c + (s[h + 2] >> o); r && this.alpha ? u[f] += s[h + this.channels - 1] / this.maxValue : u[f]++; } return u; } function g_() { this.checkProcessable('min', { bitDepth: [8, 16, 32] }); for (var e = Kw()(this.channels, 1 / 0), t = 0; t < this.data.length; t += this.channels) for (let r = 0; r < this.channels; r++) this.data[t + r] < e[r] && (e[r] = this.data[t + r]); return e; } function y_() { this.checkProcessable('max', { bitDepth: [8, 16, 32] }); for (var e = Kw()(this.channels, -1 / 0), t = 0; t < this.data.length; t += this.channels) for (let r = 0; r < this.channels; r++) this.data[t + r] > e[r] && (e[r] = this.data[t + r]); return e; } function b_() { this.checkProcessable('sum', { bitDepth: [8, 16] }); for (var e = Kw()(this.channels, 0), t = 0; t < this.data.length; t += this.channels) for (let r = 0; r < this.channels; r++)e[r] += this.data[t + r]; return e; } function w_() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; this.checkProcessable('getMoment', { bitDepth: [1] }); for (var r = 0, n = 0; n < this.width; n++) for (let i = 0; i < this.height; i++) this.getBitXY(n, i) === 1 && (r += n ** e * i ** t); return r; } function k_() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.mask; const r = e.region; let n = void 0 === r ? 3 : r; const i = e.removeClosePoints; const a = void 0 === i ? 0 : i; const o = e.invert; const s = void 0 !== o && o; const u = e.maxEquals; const l = void 0 === u ? 2 : u; const c = this; this.checkProcessable('localMaxima', { bitDepth: [8, 16], components: 1 }); for (var h = s ? 0 : 1, f = [1, 0, -1, 0, 1, 1, -1, -1, 2, 0, -2, 0, 2, 2, -2, -2], d = [0, 1, 0, -1, 1, -1, 1, -1, 0, 2, 0, -2, 2, -2, 2, -2], p = (n *= 4) <= 8 ? 1 : 2, m = [], v = p; v < c.height - p; v++) for (let g = p; g < c.width - p; g++) if (!t || t.getBitXY(g, v) === h) { for (var y = 0, b = 0, w = c.data[g + v * c.width], k = 0; k < n; k++)s ? c.data[g + f[k] + (v + d[k]) * c.width] > w && y++ : c.data[g + f[k] + (v + d[k]) * c.width] < w && y++, c.data[g + f[k] + (v + d[k]) * c.width] === w && b++; y + b === n && b <= l && m.push([g, v]); } if (a > 0) for (let x = 0; x < m.length; x++) for (let _ = x + 1; _ < m.length; _++)Math.sqrt((m[x][0] - m[_][0]) ** 2 + (m[x][1] - m[_][1]) ** 2) < a && (m[x][0] = m[x][0] + m[_][0] >> 1, m[x][1] = m[x][1] + m[_][1] >> 1, m.splice(_, 1), _--); return m; } function x_() { for (var e = this.getHistograms({ maxSlots: this.maxValue + 1 }), t = new Array(e.length), r = 0; r < e.length; r++) { const n = e[r]; t[r] = tw(n); } return t; } function __() { for (var e = this.getHistograms({ maxSlots: this.maxValue + 1 }), t = new Array(e.length), r = 0; r < e.length; r++) { const n = e[r]; t[r] = ew(n); } return t; } function S_() { this.checkProcessable('points', { bitDepth: [1] }); for (var e = [], t = 0; t < this.width; t++) for (let r = 0; r < this.height; r++) this.getBitXY(t, r) === 1 && e.push([t, r]); return e; } function M_() { this.checkProcessable('extendedPoints', { bitDepth: [1] }); for (var e = [], t = 0; t < this.height; t++) for (let r = 0; r < this.width; r++) if (this.getBitXY(r, t) === 1) for (e.push([r, t]), this.getBitXY(r + 1, t) !== 1 ? (e.push([r + 1, t]), e.push([r + 1, t + 1]), this.getBitXY(r, t + 1) !== 1 && e.push([r, t + 1])) : this.getBitXY(r, t + 1) !== 1 && (e.push([r, t + 1]), e.push([r + 1, t + 1])); r < this.width - 2 && this.getBitXY(r + 1, t) === 1 && this.getBitXY(r + 2, t) === 1;)r++; return e; } function E_(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (this === e) return [0, 0]; for (var r = [0, 0], n = this; n;) { if (n === e) return r; n.position && (r[0] += n.position[0], r[1] += n.position[1]), n = n.parent; } return !!t.defaultFurther && r; } function C_() { const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).alpha; const t = void 0 === e ? 1 : e; this.checkProcessable('countAlphaPixels', { bitDepth: [8, 16], alpha: 1 }); let r = 0; if (void 0 !== t) { for (let n = this.components; n < this.data.length; n += this.channels) this.data[n] === t && r++; return r; } return this.size; } function P_(e) { (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).sorted || (e = e.slice().sort(T_)); for (var t = e.length, r = new Array(2 * t), n = 0, i = 0; i < t; i++) { for (var a = e[i]; n >= 2 && A_(r[n - 2], r[n - 1], a) <= 0;)n--; r[n++] = a; } for (let o = n + 1, s = t - 2; s >= 0; s--) { for (var u = e[s]; n >= o && A_(r[n - 2], r[n - 1], u) <= 0;)n--; r[n++] = u; } return r.slice(0, n - 1); } function A_(e, t, r) { return (t[1] - e[1]) * (r[0] - e[0]) - (t[0] - e[0]) * (r[1] - e[1]); } function T_(e, t) { return e[0] === t[0] ? e[1] - t[1] : e[0] - t[0]; } function R_() { return P_(this.extendedPoints, { sorted: !1 }); } function I_(e, t) { return [e[0] - t[0], e[1] - t[1]]; } function O_(e) { const t = Math.sqrt(e[0] ** 2 + e[1] ** 2); return [e[0] / t, e[1] / t]; } function D_(e, t, r) { void 0 === r && (r = new Array(t.length)); for (let n = Math.cos(e), i = Math.sin(e), a = 0; a < r.length; ++a)r[a] = [n * t[a][0] - i * t[a][1], i * t[a][0] + n * t[a][1]]; return r; } function z_(e) { for (var t = 0, r = 0; r < e.length; r++) { const n = e[r][0]; const i = e[r][1]; const a = e[r === e.length - 1 ? 0 : r + 1][0]; const o = e[r === e.length - 1 ? 0 : r + 1][1]; t += Math.sqrt((a - n) ** 2 + (o - i) ** 2); } return t; } function N_(e) { for (var t = 0, r = 0; r < e.length; r++) { t += e[r][0] * e[r === e.length - 1 ? 0 : r + 1][1] * 0.5, t -= e[r === e.length - 1 ? 0 : r + 1][0] * e[r][1] * 0.5; } return Math.abs(t); } function L_(e) { for (var t = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0, a = 0; a < e.length; a++)e[a][0] < t && (t = e[a][0]), e[a][0] > n && (n = e[a][0]), e[a][1] < r && (r = e[a][1]), e[a][1] > i && (i = e[a][1]); return [[t, r], [n, i]]; } function j_() { const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).originalPoints; const t = void 0 === e ? R_.call(this) : e; if (t.length === 0) return []; if (t.length === 1) return [t[0], t[0], t[0], t[0]]; for (var r, n = new Array(t.length), i = 1 / 0, a = 0, o = 0; o < n.length; o++) { const s = F_(t[o], t[(o + 1) % n.length]); D_(-s, t, n); for (var u = n[o][0], l = n[o][1], c = n[(o + 1) % n.length][0], h = n[(o + 1) % n.length][1], f = !0, d = 0, p = 0, m = 0, v = 0; v < n.length; v++) { const g = (n[v][0] - u) / (c - u); !0 === f ? (f = !1, d = g, p = g) : (g < d && (d = g), g > p && (p = g)); const y = (-(c - u) * n[v][1] + c * l - h * u) / (c - u); Math.abs(y) > Math.abs(m) && (m = y); } const b = [u + d * (c - u), l]; const w = [u + p * (c - u), l]; const k = Math.abs(m * (d - p) * (c - u)); k < i && (a = s, i = k, r = [b, w, [w[0], w[1] - m], [b[0], b[1] - m]]); } return D_(a, r, r), r; } function F_(e, t) { const r = O_(I_(t, e)); const n = Math.acos(r[0]); return r[1] < 0 ? -n : n; } const B_ = __webpack_require__(2428); const U_ = __webpack_require__.n(B_); const V_ = __webpack_require__(9689); const Y_ = __webpack_require__.n(V_); function H_(e, t) { const r = O_(I_(t, e)); const n = Math.acos(r[0]); return r[1] < 0 ? -n : n; } const q_ = (function () {
      function e(t, r) { (0, w.Z)(this, e), this.map = t, this.id = r, this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY, this.meanX = 0, this.meanY = 0, this.surface = 0, this.computed = {}; } return (0, b.Z)(e, [{ key: 'getMask', value() { let e; const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const r = t.scale; const n = void 0 === r ? 1 : r; const i = t.kind; switch (void 0 === i ? '' : i) { case 'contour': e = this.contourMask; break; case 'box': e = this.boxMask; break; case 'filled': e = this.filledMask; break; case 'center': e = this.centerMask; break; case 'mbr': e = this.mbrFilledMask; break; case 'hull': e = this.convexHullFilledMask; break; case 'hullContour': e = this.convexHullMask; break; case 'mbrContour': e = this.mbrMask; break; case 'feret': e = this.feretMask; break; default: e = this.mask; } return n < 1 && ((e = e.resize({ factor: n })).parent = this.mask.parent, e.position[0] += this.minX, e.position[1] += this.minY), e; } }, { key: 'mean', get() { throw new Error('Roi mean not implemented yet'); } }, { key: 'center', get() { return this.computed.center || (this.computed.center = [this.width / 2 >> 0, this.height / 2 >> 0]), this.computed.center; } }, { key: 'ratio', get() { return this.width / this.height; } }, { key: 'width', get() { return this.maxX - this.minX + 1; } }, { key: 'height', get() { return this.maxY - this.minY + 1; } }, { key: '_computExternalIDs', value() { const e = this.borderIDs; const t = this.borderLengths; this.computed.externalIDs = [], this.computed.externalLengths = []; for (let r = this.internalIDs, n = 0; n < e.length; n++)r.includes(e[n]) || (this.computed.externalIDs.push(e[n]), this.computed.externalLengths.push(t[n])); } }, { key: 'externalIDs', get() { return this.computed.externalIDs || this._computExternalIDs(), this.computed.externalIDs; } }, { key: 'externalLengths', get() { return this.computed.externalLengths || this._computExternalIDs(), this.computed.externalLengths; } }, { key: '_computeBorderIDs', value() { const e = (function (e) { for (var t = e.map, r = t.data, n = new Set(), i = new Map(), a = new Set(), o = [1, 0, -1, 0], s = [0, 1, 0, -1], u = e.minX; u <= e.maxX; u++) for (let l = e.minY; l <= e.maxY; l++) { if (r[u + l * t.width] === e.id) for (let c = 0; c < 4; c++) { const h = u + o[c]; const f = l + s[c]; if (h >= 0 && f >= 0 && h < t.width && f < t.height) { const d = h + f * t.width; if (r[d] !== e.id && !a.has(d)) { a.add(d), n.add(r[d]); let p = i.get(r[d]); p ? i.set(r[d], ++p) : i.set(r[d], 1); } } } } const m = Array.from(n); const v = m.map(((e) => i.get(e))); return { ids: m, lengths: v }; }(this)); this.computed.borderIDs = e.ids, this.computed.borderLengths = e.lengths; } }, { key: 'borderIDs', get() { return this.computed.borderIDs || this._computeBorderIDs(), this.computed.borderIDs; } }, { key: 'borderLengths', get() { return this.computed.borderLengths || this._computeBorderIDs(), this.computed.borderLengths; } }, { key: 'boxIDs', get() { return this.computed.boxIDs || (this.computed.boxIDs = (function (e) { for (var t = new Set(), r = e.map, n = r.data, i = 0, a = [0, e.height - 1]; i < a.length; i++) for (let o = a[i], s = 0; s < e.width; s++) { const u = (o + e.minY) * r.width + s + e.minX; if (s - e.minX > 0 && n[u] === e.id && n[u - 1] !== e.id) { const l = n[u - 1]; t.add(l); } if (r.width - s - e.minX > 1 && n[u] === e.id && n[u + 1] !== e.id) { const c = n[u + 1]; t.add(c); } } for (let h = 0, f = [0, e.width - 1]; h < f.length; h++) for (let d = f[h], p = 0; p < e.height; p++) { const m = (p + e.minY) * r.width + d + e.minX; if (p - e.minY > 0 && n[m] === e.id && n[m - r.width] !== e.id) { const v = n[m - r.width]; t.add(v); } if (r.height - p - e.minY > 1 && n[m] === e.id && n[m + r.width] !== e.id) { const g = n[m + r.width]; t.add(g); } } return Array.from(t); }(this))), this.computed.boxIDs; } }, { key: 'internalIDs', get() { return this.computed.internalIDs || (this.computed.internalIDs = (function (e) { const t = [e.id]; const r = e.map; const n = r.data; if (e.height > 2) for (let i = 0; i < e.width; i++) { const a = e.minY * r.width + i + e.minX; if (t.includes(n[a])) { const o = n[a + r.width]; t.includes(o) || e.boxIDs.includes(o) || t.push(o); } } for (let s = new Array(4), u = 1; u < e.width - 1; u++) for (let l = 1; l < e.height - 1; l++) { const c = (l + e.minY) * r.width + u + e.minX; if (t.includes(n[c])) { s[0] = n[c - 1], s[1] = n[c + 1], s[2] = n[c - r.width], s[3] = n[c + r.width]; for (let h = 0; h < 4; h++) { const f = s[h]; t.includes(f) || e.boxIDs.includes(f) || t.push(f); } } } return t; }(this))), this.computed.internalIDs; } }, { key: 'box', get() { return this.computed.box || (this.computed.box = (function (e) { let t = 0; const r = e.map; const n = r.data; const i = [0]; e.height > 1 && (i[1] = e.height - 1); for (let a = 0, o = i; a < o.length; a++) for (let s = o[a], u = 1; u < e.width - 1; u++) { n[(s + e.minY) * r.width + u + e.minX] === e.id && t++; } const l = [0]; e.width > 1 && (l[1] = e.width - 1); for (let c = 0, h = l; c < h.length; c++) for (let f = h[c], d = 0; d < e.height; d++) { n[(d + e.minY) * r.width + f + e.minX] === e.id && t++; } return t; }(this))), this.computed.box; } }, { key: 'external', get() { return this.computed.external || (this.computed.external = (function (e) { for (var t = 0, r = e.map, n = r.data, i = 1; i < e.width - 1; i++) for (let a = 1; a < e.height - 1; a++) { const o = (a + e.minY) * r.width + i + e.minX; n[o] === e.id && (e.externalIDs.includes(n[o - 1]) || e.externalIDs.includes(n[o + 1]) || e.externalIDs.includes(n[o - r.width]) || e.externalIDs.includes(n[o + r.width])) && t++; } return t + e.box; }(this))), this.computed.external; } }, { key: 'holesInfo', get() { return this.computed.holesInfo || (this.computed.holesInfo = (function (e) { for (var t = 0, r = e.map.width, n = e.map.data, i = 1; i < e.width - 1; i++) for (let a = 1; a < e.height - 1; a++) { const o = (a + e.minY) * r + i + e.minX; e.internalIDs.includes(n[o]) && n[o] !== e.id && t++; } return { number: e.internalIDs.length - 1, surface: t }; }(this))), this.computed.holesInfo; } }, { key: 'border', get() { return this.computed.border || (this.computed.border = (function (e) { for (var t = 0, r = e.map, n = r.data, i = 1; i < e.width - 1; i++) for (let a = 1; a < e.height - 1; a++) { const o = (a + e.minY) * r.width + i + e.minX; n[o] === e.id && (n[o - 1] === e.id && n[o + 1] === e.id && n[o - r.width] === e.id && n[o + r.width] === e.id || t++); } return t + e.box; }(this))), this.computed.border; } }, { key: 'contourMask', get() { if (!this.computed.contourMask) { for (var e = new mS(this.width, this.height, { kind: bb, position: [this.minX, this.minY], parent: this.map.parent }), t = 0; t < this.width; t++) for (let r = 0; r < this.height; r++) this.map.data[t + this.minX + (r + this.minY) * this.map.width] === this.id && (t > 0 && t < this.width - 1 && r > 0 && r < this.height - 1 && this.map.data[t - 1 + this.minX + (r + this.minY) * this.map.width] === this.id && this.map.data[t + 1 + this.minX + (r + this.minY) * this.map.width] === this.id && this.map.data[t + this.minX + (r - 1 + this.minY) * this.map.width] === this.id && this.map.data[t + this.minX + (r + 1 + this.minY) * this.map.width] === this.id || e.setBitXY(t, r)); this.computed.contourMask = e; } return this.computed.contourMask; } }, { key: 'boxMask', get() { if (!this.computed.boxMask) { for (var e = new mS(this.width, this.height, { kind: bb, position: [this.minX, this.minY], parent: this.map.parent }), t = 0; t < this.width; t++)e.setBitXY(t, 0), e.setBitXY(t, this.height - 1); for (let r = 0; r < this.height; r++)e.setBitXY(0, r), e.setBitXY(this.width - 1, r); this.computed.boxMask = e; } return this.computed.boxMask; } }, { key: 'mask', get() { if (!this.computed.mask) { for (var e = new mS(this.width, this.height, { kind: bb, position: [this.minX, this.minY], parent: this.map.parent }), t = 0; t < this.width; t++) for (let r = 0; r < this.height; r++) this.map.data[t + this.minX + (r + this.minY) * this.map.width] === this.id && e.setBitXY(t, r); this.computed.mask = e; } return this.computed.mask; } }, { key: 'filledMask', get() { if (!this.computed.filledMask) { for (var e = new mS(this.width, this.height, { kind: bb, position: [this.minX, this.minY], parent: this.map.parent }), t = 0; t < this.width; t++) for (let r = 0; r < this.height; r++) { const n = t + this.minX + (r + this.minY) * this.map.width; this.internalIDs.includes(this.map.data[n]) && e.setBitXY(t, r); } this.computed.filledMask = e; } return this.computed.filledMask; } }, { key: 'centerMask', get() { if (!this.computed.centerMask) { const e = new a_({ kind: 'smallCross' }).getMask(); e.parent = this.map.parent, e.position = [this.minX + this.center[0] - 1, this.minY + this.center[1] - 1], this.computed.centerMask = e; } return this.computed.centerMask; } }, { key: 'convexHull', get() { if (!this.computed.convexHull) { for (var e = [], t = 0; t < this.width; t++) for (let r = 0; r < this.height; r++) this.map.data[t + this.minX + (r + this.minY) * this.map.width] === this.id && (t > 0 && t < this.width - 1 && r > 0 && r < this.height - 1 && this.map.data[t - 1 + this.minX + (r + this.minY) * this.map.width] === this.id && this.map.data[t + 1 + this.minX + (r + this.minY) * this.map.width] === this.id && this.map.data[t + this.minX + (r - 1 + this.minY) * this.map.width] === this.id && this.map.data[t + this.minX + (r + 1 + this.minY) * this.map.width] === this.id || (e.push([t, r]), e.push([t + 1, r]), e.push([t, r + 1]), e.push([t + 1, r + 1]))); const n = P_(e); this.computed.convexHull = { polyline: n, surface: N_(n), perimeter: z_(n) }; } return this.computed.convexHull; } }, { key: 'convexHullMask', get() { if (!this.computed.convexHullMask) { const e = this.convexHull; const t = new mS(this.width + 1, this.height + 1, { kind: bb, position: [this.minX, this.minY], parent: this.map.parent }); t.paintPolyline(e.polyline, { closed: !0 }), this.computed.convexHullMask = t; } return this.computed.convexHullMask; } }, { key: 'convexHullFilledMask', get() { if (!this.computed.convexHullFilledMask) { for (var e = this.convexHull, t = new mS(this.width, this.height, { kind: bb, position: [this.minX, this.minY], parent: this.map.parent }), r = 0; r < this.width; r++) for (let n = 0; n < this.height; n++)Y_()(e.polyline, [r, n]) !== 1 && t.setBitXY(r, n); this.computed.convexHullFilledMask = t; } return this.computed.convexHullFilledMask; } }, {
        key: 'mbr',
        get() {
          if (!this.computed.mbr) {
            const e = j_({ originalPoints: this.convexHull.polyline }); if (e.length === 0) {
              this.computed.mbr = {
                width: 0, height: 0, surface: 0, perimeter: 0, rectangle: e,
              };
            } else {
              const t = e[0]; const r = e[1]; const n = e[2]; const i = Math.sqrt((t[0] - r[0]) ** 2 + (t[1] - r[1]) ** 2); const a = Math.sqrt((n[0] - r[0]) ** 2 + (n[1] - r[1]) ** 2); this.computed.mbr = {
                width: i, height: a, elongation: 1 - i / a, aspectRatio: i / a, surface: i * a, perimeter: 2 * (i + a), rectangle: e,
              };
            }
          } return this.computed.mbr;
        },
      }, { key: 'fillRatio', get() { return this.surface / (this.surface + this.holesInfo.surface); } }, {
        key: 'feretDiameters',
        get() {
          return this.computed.feretDiameters || (this.computed.feretDiameters = (function () {
            const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).originalPoints; const t = void 0 === e ? R_.call(this) : e; if (t.length === 0) {
 return {
              min: 0, max: 0, minLine: [], maxLine: [], aspectRatio: 1,
            }; 
} if (t.length === 1) {
 return {
              min: 1, max: 1, minLine: [t[0], t[0]], maxLine: [t[0], t[0]], aspectRatio: 1,
            }; 
} for (var r = new Array(t.length), n = 1 / 0, i = 0, a = [], o = 0; o < t.length; o++) { const s = H_(t[o], t[(o + 1) % t.length]); D_(-s, t, r); for (var u = 0, l = [], c = 0; c < t.length; c++) { const h = Math.abs(r[o][1] - r[c][1]); h > u && (u = h, (l = []).push([r[c][0], r[o][1]], [r[c][0], r[c][1]])); }u < n && (n = u, i = s, a = l); }D_(i, a, a); for (var f = 0, d = [], p = 0, m = 0; m < t.length - 1; m++) for (let v = m + 1; v < t.length; v++) { const g = (t[m][0] - t[v][0]) ** 2 + (t[m][1] - t[v][1]) ** 2; g > p && (p = g, f = Math.sqrt(g), d = [t[m], t[v]]); } return {
              min: n, minLine: a, max: f, maxLine: d, aspectRatio: n / f,
            };
          }({ originalPoints: this.convexHull.polyline }))), this.computed.feretDiameters;
        },
      }, { key: 'eqpc', get() { return this.computed.eqpc || (this.computed.eqpc = 2 * Math.sqrt(this.surface / Math.PI)), this.computed.eqpc; } }, {
        key: 'perimeterInfo',
        get() {
          return this.computed.perimeterInfo || (this.computed.perimeterInfo = (function (e) {
            for (var t = e.map, r = t.data, n = 0, i = 0, a = 0, o = 0, s = 0; s < e.width; s++) for (let u = 0; u < e.height; u++) { const l = (u + e.minY) * t.width + s + e.minX; if (r[l] === e.id) { let c = 0; switch ((s === 0 || e.externalIDs.includes(r[l - 1])) && c++, (s === e.width - 1 || e.externalIDs.includes(r[l + 1])) && c++, (u === 0 || e.externalIDs.includes(r[l - t.width])) && c++, (u === e.height - 1 || e.externalIDs.includes(r[l + t.width])) && c++, c) { case 1: n++; break; case 2: i++; break; case 3: a++; break; case 4: o++; } } } return {
              one: n, two: i, three: a, four: o,
            };
          }(this))), this.computed.perimeterInfo;
        },
      }, { key: 'perimeter', get() { const e = this.perimeterInfo; const t = 2 - Math.sqrt(2); return e.one + 2 * e.two + 3 * e.three + 4 * e.four - t * (e.two + 2 * e.three + e.four); } }, { key: 'ped', get() { return this.computed.ped || (this.computed.ped = this.perimeter / Math.PI), this.computed.ped; } }, { key: 'feretMask', get() { if (!this.computed.feretMask) { const e = new mS(this.width + 1, this.height + 1, { kind: bb, position: [this.minX, this.minY], parent: this.map.parent }); e.paintPolyline(this.feretDiameters.minLine), e.paintPolyline(this.feretDiameters.maxLine), this.computed.feretMask = e; } return this.computed.feretMask; } }, { key: 'mbrMask', get() { if (!this.computed.mbrMask) { let e = (function (e) { for (let t = 0; t < e.length; t++)e[t][0] = Math.round(e[t][0]), e[t][1] = Math.round(e[t][1]); return e; }(this.mbr.rectangle)); if (e.length > 0) { const t = L_(e); const r = new mS(t[1][0] - t[0][0] + 1, t[1][1] - t[0][1] + 1, { kind: bb, position: [this.minX + t[0][0], this.minY + t[0][1]], parent: this.map.parent }); e = (function (e, t) { void 0 === t && (t = new Array(e.length).fill(0).map((() => []))); for (let r = L_(e), n = r[0][0], i = r[0][1], a = 0; a < e.length; a++)t[a][0] = e[a][0] - n, t[a][1] = e[a][1] - i; return t; }(e)), r.paintPolyline(e, { closed: !0 }), this.computed.mbrMask = r; } else this.computed.mbrMask = new mS(1, 1, { kind: bb, position: [this.minX, this.minY], parent: this.map.parent }); } return this.computed.mbrMask; } }, { key: 'mbrFilledMask', get() { if (!this.computed.mbrFilledMask) { for (var e = new mS(this.width, this.height, { kind: bb, position: [this.minX, this.minY], parent: this.map.parent }), t = this.mask.minimalBoundingRectangle(), r = 0; r < this.width; r++) for (let n = 0; n < this.height; n++)Y_()(t, [r, n]) !== 1 && e.setBitXY(r, n); this.computed.mbrFilledMask = e; } return this.computed.mbrFilledMask; } }, { key: 'points', get() { if (!this.computed.points) { for (var e = [], t = 0; t < this.height; t++) for (let r = 0; r < this.width; r++) { const n = (t + this.minY) * this.map.width + r + this.minX; this.map.data[n] === this.id && e.push([r, t]); } this.computed.points = e; } return this.computed.points; } }, { key: 'maxLengthPoints', get() { if (!this.computed.maxLengthPoints) { for (var e, t = 0, r = this.points, n = 0; n < r.length; n++) for (let i = n + 1; i < r.length; i++) { const a = (r[n][0] - r[i][0]) ** 2 + (r[n][1] - r[i][1]) ** 2; a >= t && (t = a, e = [r[n], r[i]]); } this.computed.maxLengthPoints = e; } return this.computed.maxLengthPoints; } }, { key: 'maxLength', get() { if (!this.computed.maxLength) { const e = Math.sqrt((this.maxLengthPoints[0][0] - this.maxLengthPoints[1][0]) ** 2 + (this.maxLengthPoints[0][1] - this.maxLengthPoints[1][1]) ** 2); this.computed.maxLength = e; } return this.computed.maxLength; } }, { key: 'roundness', get() { return 4 * this.surface / (Math.PI * this.feretDiameters.max ** 2); } }, { key: 'sphericity', get() { return 2 * Math.sqrt(this.surface * Math.PI) / this.perimeter; } }, { key: 'solidity', get() { return this.surface / this.convexHull.surface; } }, { key: 'angle', get() { if (!this.computed.angle) { const e = this.maxLengthPoints; const t = 180 * -Math.atan2(e[0][1] - e[1][1], e[0][0] - e[1][0]) / Math.PI; this.computed.angle = t; } return this.computed.angle; } }, {
        key: 'toJSON',
        value() {
          return {
            id: this.id, minX: this.minX, maxX: this.maxX, minY: this.minY, maxY: this.maxY, meanX: this.meanX, meanY: this.meanY, height: this.height, width: this.width, surface: this.surface, mbrWidth: this.mbr.width, mbrHeight: this.mbr.height, mbrSurface: this.mbr.surface, eqpc: this.eqpc, ped: this.ped, feretDiameterMin: this.feretDiameters.min, feretDiameterMax: this.feretDiameters.max, aspectRatio: this.feretDiameters.aspectRatio, fillRatio: this.fillRatio, sphericity: this.sphericity, roundness: this.roundness, solidity: this.solidity, perimeter: this.perimeter,
          };
        },
      }]), e;
    }()); const W_ = (function () { function e(t, r) { (0, w.Z)(this, e), this.roiMap = t, this.options = r, this.roi = this.createRoi(); } return (0, b.Z)(e, [{ key: 'createRoi', value() { const e = this.roiMap.data; const t = {}; this.roiMap.positive = 0, this.roiMap.negative = 0; for (let r = 0; r < e.length; r++)e[r] && !t[e[r]] && (t[e[r]] = !0, e[r] > 0 ? this.roiMap.positive++ : this.roiMap.negative++); const n = {}; for (const i in t)n[i] = new q_(this.roiMap, 1 * i); for (let a = this.roiMap.width, o = this.roiMap.height, s = 0; s < o; s++) for (let u = 0; u < a; u++) { const l = s * a + u; if (e[l] !== 0) { const c = n[e[l]]; u < c.minX && (c.minX = u), u > c.maxX && (c.maxX = u), s < c.minY && (c.minY = s), s > c.maxY && (c.maxY = s), c.meanX += u, c.meanY += s, c.surface++; } } const h = []; for (const f in t)n[f].meanX /= n[f].surface, n[f].meanY /= n[f].surface, h.push(n[f]); return h; } }]), e; }()); function X_() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.algorithm; const r = void 0 === t ? 'commonBorderLength' : t; const n = e.minCommonBorderLength; const i = void 0 === n ? 5 : n; const a = e.maxCommonBorderLength; const o = void 0 === a ? 100 : a; const s = e.minCommonBorderRatio; const u = void 0 === s ? 0.3 : s; const l = e.maxCommonBorderRatio; const c = void 0 === l ? 1 : l; let h = function (e, t, r) { return e[r] >= i && e[r] <= o; }; typeof r === 'function' && (h = r), r.toLowerCase() === 'commonborderratio' && (h = function (e, t, r) { const n = Math.min(e[r] / e[t], 1); return n >= u && n <= c; }); for (var f = this, d = f.commonBorderLength, p = {}, m = {}, v = 0, g = Object.keys(d); v < g.length; v++) for (let y = g[v], b = d[y], w = 0, k = Object.keys(b); w < k.length; w++) { const x = k[w]; if (x !== y && h(b, y, x)) { let _ = x; m[x] && (_ = m[x]); let S = y; if (m[y] && (S = m[y]), Number(_) !== S) { const M = Math.min(_, S); const E = Math.max(_, S); if (p[M] || (p[M] = {}), p[M][E] = !0, m[E] = M, p[E]) { for (let C = 0, P = Object.keys(p[E]); C < P.length; C++) { const A = P[C]; p[M][A] = !0, m[A] = M; } delete p[E]; } } } } for (var T = f.minMax, R = -T.min, I = T.max + R, O = new Array(I + 1).fill(0), D = 0, z = Object.keys(m); D < z.length; D++) { const N = z[D]; O[Number(N) + R] = m[N]; } for (let L = f.data, j = 0; j < L.length; j++) { const F = L[j]; if (F !== 0) { const B = O[F + R]; B !== 0 && (L[j] = B); } } return f.computed = {}, f; } const G_ = (function () {
      function e(t, r) { (0, w.Z)(this, e), this.parent = t, this.width = t.width, this.height = t.height, this.data = r, this.negative = 0, this.positive = 0; } return (0, b.Z)(e, [{ key: 'total', get() { return this.negative + this.positive; } }, { key: 'minMax', get() { for (var e = Number.MAX_SAFE_INTEGER, t = Number.MIN_SAFE_INTEGER, r = 0; r < this.data.length; r++) this.data[r] < e && (e = this.data[r]), this.data[r] > t && (t = this.data[r]); return { min: e, max: t }; } }, { key: 'commonBorderLength', get() { return (function (e) { for (var t = e.data, r = [1, 0, -1, 0], n = [0, 1, 0, -1], i = e.minMax, a = -i.min, o = i.max + a, s = [], u = 0; u <= o; u++)s.push(Object.create(null)); for (let l = 0; l < e.width; l++) for (let c = 0; c < e.height; c++) { const h = t[l + c * e.width]; if (h !== 0) { for (var f = Object.create(null), d = !1, p = 0; p < 4; p++) { const m = l + r[p]; const v = c + n[p]; if (m >= 0 && v >= 0 && m < e.width && v < e.height) { const g = t[m + v * e.width]; h !== g && (d = !0, g !== 0 && void 0 === f[g] && (f[g] = !0, s[g + a][h] ? s[g + a][h]++ : s[g + a][h] = 1)); } else d = !0; }d && (s[h + a][h] ? s[h + a][h]++ : s[h + a][h] = 1); } } for (var y = {}, b = 0; b < s.length; b++)Object.keys(s[b]).length > 0 && (y[b - a] = s[b]); return y; }(this)); } }, { key: 'mergeRoi', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return X_.call(this, e); } }, { key: 'mergeRois', value(e) { for (let t = e[0], r = e.slice(1), n = 0; n < this.data.length; n++)r.includes(this.data[n]) && (this.data[n] = t); } }, {
        key: 'rowsInfo',
        value() {
          for (var e = new Array(this.height), t = 0, r = 0; r < this.data.length; r += this.width) {
            const n = {
              row: t, positivePixel: 0, negativePixel: 0, zeroPixel: 0, positiveRoi: 0, negativeRoi: 0, medianChange: 0,
            }; e[t++] = n; for (var i = {}, a = {}, o = [], s = this.data[r], u = 0, l = r; l < r + this.width; l++) { const c = this.data[l]; s !== c && (s = c, o.push(u), u = 0), u++, c > 0 ? (n.positivePixel++, i[c] || (i[c] = !0)) : c < 0 ? (n.negativePixel++, a[c] || (a[c] = !0)) : n.zeroPixel++; }o.push(u), n.medianChange = o.sort(((e, t) => e - t))[Math.floor(o.length / 2)], n.positiveRoiIDs = Object.keys(i), n.negativeRoiIDs = Object.keys(a), n.positiveRoi = n.positiveRoiIDs.length, n.negativeRoi = n.negativeRoiIDs.length;
          } return e;
        },
      }, {
        key: 'colsInfo',
        value() {
          for (var e = new Array(this.width), t = 0, r = 0; r < this.width; r++) {
            const n = {
              col: t, positivePixel: 0, negativePixel: 0, zeroPixel: 0, positiveRoi: 0, negativeRoi: 0, medianChange: 0,
            }; e[t++] = n; for (var i = {}, a = {}, o = [], s = this.data[r], u = 0, l = r; l < r + this.data.length; l += this.width) { const c = this.data[l]; s !== c && (s = c, o.push(u), u = 0), u++, c > 0 ? (n.positivePixel++, i[c] || (i[c] = !0)) : c < 0 ? (n.negativePixel++, a[c] || (a[c] = !0)) : n.zeroPixel++; }o.push(u), n.medianChange = o.sort(((e, t) => e - t))[Math.floor(o.length / 2)], n.positiveRoiIDs = Object.keys(i), n.negativeRoiIDs = Object.keys(a), n.positiveRoi = n.positiveRoiIDs.length, n.negativeRoi = n.negativeRoiIDs.length;
          } return e;
        },
      }]), e;
    }()); function $_(e) { for (var t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).allowCorners, r = void 0 !== t && t, n = 65535, i = new Int16Array(e.size), a = 0, o = 0, s = new Uint16Array(65536), u = new Uint16Array(65536), l = 0; l < e.width; l++) for (let c = 0; c < e.height; c++)i[c * e.width + l] === 0 && h(l, c); function h(t, l) { let c = 0; let h = 0; const f = e.getBitXY(t, l); const d = f ? ++a : --o; if (a > 32767 || o < -32768) throw new Error('Too many regions of interest'); for (s[0] = t, u[0] = l; c <= h;) { const p = s[c & n]; const m = u[c & n]; if (i[m * e.width + p] = d, p > 0 && i[m * e.width + p - 1] === 0 && e.getBitXY(p - 1, m) === f && (h++, s[h & n] = p - 1, u[h & n] = m, i[m * e.width + p - 1] = -32768), m > 0 && i[(m - 1) * e.width + p] === 0 && e.getBitXY(p, m - 1) === f && (h++, s[h & n] = p, u[h & n] = m - 1, i[(m - 1) * e.width + p] = -32768), p < e.width - 1 && i[m * e.width + p + 1] === 0 && e.getBitXY(p + 1, m) === f && (h++, s[h & n] = p + 1, u[h & n] = m, i[m * e.width + p + 1] = -32768), m < e.height - 1 && i[(m + 1) * e.width + p] === 0 && e.getBitXY(p, m + 1) === f && (h++, s[h & n] = p, u[h & n] = m + 1, i[(m + 1) * e.width + p] = -32768), r && (p > 0 && m > 0 && i[(m - 1) * e.width + p - 1] === 0 && e.getBitXY(p - 1, m - 1) === f && (h++, s[h & n] = p - 1, u[h & n] = m - 1, i[(m - 1) * e.width + p - 1] = -32768), p < e.width - 1 && m > 0 && i[(m - 1) * e.width + p + 1] === 0 && e.getBitXY(p + 1, m - 1) === f && (h++, s[h & n] = p + 1, u[h & n] = m - 1, i[(m - 1) * e.width + p + 1] = -32768), p > 0 && m < e.height - 1 && i[(m + 1) * e.width + p - 1] === 0 && e.getBitXY(p - 1, m + 1) === f && (h++, s[h & n] = p - 1, u[h & n] = m + 1, i[(m + 1) * e.width + p - 1] = -32768), p < e.width - 1 && m < e.height - 1 && i[(m + 1) * e.width + p + 1] === 0 && e.getBitXY(p + 1, m + 1) === f && (h++, s[h & n] = p + 1, u[h & n] = m + 1, i[(m + 1) * e.width + p + 1] = -32768)), h - ++c > n) throw new Error('analyseMask can not finish, the array to manage internal data is not big enough.You could improve mask by changing MAX_ARRAY'); } } return new G_(e, i); } const Z_ = __webpack_require__(6755); const K_ = __webpack_require__.n(Z_); const Q_ = [-1, 0]; const J_ = [0, -1]; const eS = [null, null]; const tS = [-1, -1, 0, 1]; const rS = [0, -1, -1, -1]; const nS = [null, null, null, null]; function iS(e) { let t; let r; let n; const i = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).allowCorners; let a = 4; if (void 0 !== i && i && (a = 8), a === 8)t = tS, r = rS, n = nS; else { if (a !== 4) throw new RangeError('unsupported neighbours count: '.concat(a)); t = Q_, r = J_, n = eS; } for (var o = e.size, s = e.width, u = e.height, l = new Array(o), c = new Uint32Array(o), h = new (K_())(), f = 1, d = 0; d < u; d++) for (let p = 0; p < s; p++) { const m = p + d * s; if (e.getBit(m)) { for (var v = null, g = 0; g < n.length; g++) { const y = p + t[g]; const b = d + r[g]; if (y >= 0 && b >= 0 && y < s && b < u) { const w = l[y + b * s]; w ? (n[g] = w, (!v || n[g].value < v.value) && (v = n[g])) : n[g] = null; } } if (v) { l[m] = v; for (let k = 0; k < n.length; k++)n[k] && n[k] !== v && h.union(v, n[k]); } else l[m] = h.add(f++); } } for (let x = 0; x < u; x++) for (let _ = 0; _ < s; _++) { const S = _ + x * s; e.getBit(S) && (c[S] = h.find(l[S]).value); } return new G_(e, c); } function aS() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.allowCorner; const r = void 0 === t || t; const n = e.onlyTop; const i = void 0 !== n && n; const a = (e.invert, this); a.checkProcessable('fromMaxima', { components: [1] }); const o = 1; const s = 2; let u = 0; let l = 0; const c = new Int16Array(a.size); const h = new Int8Array(a.size); const f = new Float32Array(a.size); const d = 1048575; const p = new Uint16Array(d + 1); const m = new Uint16Array(d + 1); let v = 0; let g = 0; const y = new Uint16Array(d + 1); const b = new Uint16Array(d + 1); let w = 0; let k = 0; for (!(function (e) { for (let t = e.maxima, n = void 0 === t || t, i = 1; i < a.height - 1; i++) for (let o = 1; o < a.width - 1; o++) { const s = o + i * a.width; if (h[s] === 0) { const f = n ? a.data[s] : -a.data[o + i * a.width]; if (a.data[i * a.width + o - 1] > f) continue; if (a.data[i * a.width + o + 1] > f) continue; if (a.data[(i - 1) * a.width + o] > f) continue; if (a.data[(i + 1) * a.width + o] > f) continue; if (r) { if (a.data[(i - 1) * a.width + o - 1] > f) continue; if (a.data[(i - 1) * a.width + o + 1] > f) continue; if (a.data[(i + 1) * a.width + o - 1] > f) continue; if (a.data[(i + 1) * a.width + o + 1] > f) continue; }c[s] = n ? ++u : --l, x(o, i) || (n ? --u : ++l); } } }(a)); v < g;) { _(p[v & d], m[v & d], s), v++; } return new G_(a, c); function x(e, t) { const r = g; w = 0, k = 1, y[0] = e, b[0] = t; for (var n = !0; w < k;) { n &= _(y[w & d], b[w & d], o), w++; } if (!n) { for (let i = 0; i < k; i++) { const s = y[i & d]; const u = b[i & d] * a.width + s; c[u] = 0; }g = r; } return n; } function _(e, t, r) { for (let n = c[t * a.width + e], u = a.data[t * a.width + e], l = t - 1; l <= t + 1; l++) for (let v = e - 1; v <= e + 1; v++) { const w = l * a.width + v; if (h[w] === 0) switch (h[w] = 1, f[w] = a.data[w] - u, r) { case o: if (f[w] === 0) { if (v === 0 || l === 0 || v === a.width - 1 || l === a.height - 1) return !1; c[w] = n, y[k & d] = v, b[k & d] = l, k++; } else { if (f[w] > 0) return !1; i || (c[w] = n, p[g & d] = v, m[g & d] = l, g++); } break; case s: f[w] <= 0 && (c[w] = n, p[g & d] = v, m[g & d] = l, g++); break; default: throw new Error('unreachable'); } } return !0; } } function oS(e) { for (var t = new a_(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}), r = new Int16Array(this.size), n = 0, i = t.getPoints(), a = 0; a < e.length; a++) { n++; for (let o = e[a][0], s = e[a][1], u = 0; u < i.length; u++) { const l = i[u][0]; const c = i[u][1]; o + l >= 0 && s + c >= 0 && o + l < this.width && s + c < this.height && (r[o + l + (s + c) * this.width] = n); } } return new G_(this, r); } const sS = __webpack_require__(28); const uS = __webpack_require__.n(sS); const lS = [1, 0, -1, 0, 1, 1, -1, -1]; const cS = [0, 1, 0, -1, 1, -1, 1, -1]; function hS() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; let t = e.points; const r = e.mask; const n = e.image; const i = e.fillMaxValue; const a = void 0 === i ? this.maxValue : i; const o = e.invert; let s = void 0 !== o && o; const u = n || this; u.checkProcessable('fromWaterShed', { bitDepth: [8, 16], components: 1 }), s = !s, t || (t = u.getLocalMaxima({ invert: s, mask: r })); for (var l = s ? 0 : 1, c = new Int16Array(u.size), h = u.width, f = u.height, d = new (uS())({ comparator(e, t) { return e[2] - t[2]; }, strategy: uS().BinaryHeapStrategy }), p = 0; p < t.length; p++) { const m = t[p][0] + t[p][1] * h; c[m] = p + 1; const v = u.data[m]; (s && v <= a || !s && v >= a) && d.queue([t[p][0], t[p][1], v]); } for (;d.length > 0;) for (let g = d.dequeue(), y = g[0] + g[1] * h, b = 0; b < 4; b++) { const w = g[0] + lS[b]; const k = g[1] + cS[b]; if (w >= 0 && k >= 0 && w < h && k < f) { const x = w + k * h; if (!r || r.getBit(x) === l) { const _ = u.data[x]; (s && _ <= a || !s && _ >= a) && c[x] === 0 && (c[x] = c[y], d.queue([g[0] + lS[b], g[1] + cS[b], _])); } } } return new G_(u, c); } const fS = (function () { function e(t) { const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; (0, w.Z)(this, e), this._image = t, this._options = r, this._options.label || (this._options.label = 'default'), this._layers = {}, this._painted = null; } return (0, b.Z)(e, [{ key: 'fromMaxima', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = { ...this._options, ...e }; const r = aS.call(this._image, e); this._layers[t.label] = new W_(r, t); } }, { key: 'fromPoints', value(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = { ...this._options, ...t }; const n = oS.call(this._image, e, t); return this._layers[r.label] = new W_(n, r), this; } }, { key: 'putMap', value(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = new G_(this._image, e); const n = { ...this._options, ...t }; return this._layers[n.label] = new W_(r, n), this; } }, { key: 'fromWaterShed', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = { ...this._options, ...e }; const r = hS.call(this._image, e); this._layers[t.label] = new W_(r, t); } }, { key: 'fromMask', value(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = { ...this._options, ...t }; const n = $_.call(this._image, e, t); return this._layers[r.label] = new W_(n, r), this; } }, { key: 'fromMaskConnectedComponentLabelingAlgorithm', value(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = { ...this._options, ...t }; const n = iS.call(this._image, e, t); return this._layers[r.label] = new W_(n, r), this; } }, { key: 'getMap', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = { ...this._options, ...e }; return this._assertLayerWithLabel(t.label), this._layers[t.label].roiMap; } }, { key: 'rowsInfo', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return this.getMap(e).rowsInfo(); } }, { key: 'colsInfo', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return this.getMap(e).rowsInfo(); } }, { key: 'getRoiIds', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = this.getRois(e); if (t) { for (var r = new Array(t.length), n = 0; n < t.length; n++)r[n] = t[n].id; return r; } throw new Error('ROIs not found'); } }, { key: 'getRois', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.label; const r = void 0 === t ? this._options.label : t; const n = e.positive; const i = void 0 === n || n; const a = e.negative; const o = void 0 === a || a; const s = e.minSurface; const u = void 0 === s ? 0 : s; const l = e.maxSurface; const c = void 0 === l ? Number.POSITIVE_INFINITY : l; const h = e.minWidth; const f = void 0 === h ? 0 : h; const d = e.maxWidth; const p = void 0 === d ? Number.POSITIVE_INFINITY : d; const m = e.minHeight; const v = void 0 === m ? 0 : m; const g = e.maxHeight; const y = void 0 === g ? Number.POSITIVE_INFINITY : g; const b = e.minRatio; const w = void 0 === b ? 0 : b; const k = e.maxRatio; const x = void 0 === k ? Number.POSITIVE_INFINITY : k; if (!this._layers[r]) throw new Error('this Roi layer ('.concat(r, ') does not exist')); let _; const S = []; const M = N(this._layers[r].roi); try { for (M.s(); !(_ = M.n()).done;) { const E = _.value; (E.id < 0 && o || E.id > 0 && i) && E.surface >= u && E.surface <= c && E.width >= f && E.width <= p && E.height >= v && E.height <= y && E.ratio >= w && E.ratio <= x && S.push(E); } } catch (Rv) { M.e(Rv); } finally { M.f(); } return S; } }, { key: 'getRoi', value(e) { const t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).label; const r = void 0 === t ? this._options.label : t; if (!this._layers[r]) throw new Error('this Roi layer ('.concat(r, ') does not exist')); const n = this._layers[r].roi.find(((t) => t.id === e)); if (!n) throw new Error('found no Roi with id '.concat(e)); return n; } }, { key: 'getMasks', value() { for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = this.getRois(e), r = new Array(t.length), n = 0; n < t.length; n++)r[n] = t[n].getMask(e); return r; } }, { key: 'getAnalysisMasks', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.analysisProperty; const r = ''.concat(t, 'Mask'); const n = this.getRois(e); return n.length !== 0 && n[0][r] ? n.map(((e) => e[r])) : []; } }, { key: 'getData', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = { ...this._options, ...e }; return this._assertLayerWithLabel(t.label), this._layers[t.label].roiMap.data; } }, { key: 'paint', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.labelProperty; const r = e.analysisProperty; this._painted || (this._painted = this._image.rgba8()); const n = this.getMasks(e); if (t) { const i = this.getRois(e); e.labels = i.map(((e) => (function (e) { let t; const r = N((arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '').split('.')); try { for (r.s(); !(t = r.n()).done;) { const n = t.value; if (void 0 === e[n]) return; e = e[n]; } } catch (Rv) { r.e(Rv); } finally { r.f(); } return e; }(e, t)))); const a = Math.max.apply(Math, P(e.labels)); let o = !1; let s = !1; if (t.includes('surface') ? o = !0 : /(?:perimeter|min|max|external|width|height|length)/.test(t) && (s = !0), isFinite(a)) { let u = ''; if (e.unit !== 'pixel' && e.pixelSize && (s || o)) { u = o ? ''.concat(e.unit, '^2') : e.unit; const l = o ? 'm^2' : 'm'; const c = o ? e.pixelSize ** 2 : e.pixelSize; const h = U_().swiftConverter(l, u); e.labels = e.labels.map(((e) => h(c * e))); }e.labels = a > 50 ? e.labels.map(((e) => Math.round(e) + u)) : a > 10 ? e.labels.map(((e) => e.toFixed(1) + u)) : e.labels.map(((e) => e.toFixed(2) + u)); }e.labelsPosition = i.map(((e) => [e.meanX, e.meanY])); } if (this._painted.paintMasks(n, e), r) { const f = this.getAnalysisMasks(e); this._painted.paintMasks(f, { color: e.analysisColor, alpha: e.analysisAlpha }); } return this._painted; } }, { key: 'getMask', value() { for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = new mS(this._image.width, this._image.height, { kind: 'BINARY' }), r = this.getMasks(e), n = 0; n < r.length; n++) for (let i = r[n], a = 0; a < i.width; a++) for (let o = 0; o < i.height; o++)i.getBitXY(a, o) && t.setBitXY(a + i.position[0], o + i.position[1]); return t; } }, { key: 'resetPainted', value() { const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).image; this._painted = e ? this.image.rgba8() : this._image.rgba8(); } }, { key: 'mergeRoi', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = this.getMap(e); return t.mergeRoi(e), this.putMap(t.data, e), this; } }, { key: 'mergeRois', value(e) { const t = this; const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!Array.isArray(e) || e.some(((e) => !Number.isInteger(e)))) throw new Error('Roi ids must be an array of integers'); if (e.length < 2) throw new Error('Roi ids must have at least two elements'); if (new Set(e).size !== e.length) throw new Error('Roi ids must be all different'); e.forEach(((e) => t.getRoi(e))); const n = this.getMap(r); return n.mergeRois(e), this.putMap(n.data, r), this; } }, { key: 'findCorrespondingRoi', value(e) { for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = this.getRois(t), n = [], i = 0; i < r.length; i++) { const a = r[i]; const o = dS(a.minX, a.minY, a.points, e, Math.sign(a.id)); n.push(o); } return n; } }, { key: '_assertLayerWithLabel', value(e) { if (!this._layers[e]) throw new Error('no layer with label '.concat(e)); } }]), e; }()); function dS(e, t, r, n, i) {
      for (var a = {
          id: [], surface: [], roiSurfaceCovered: [], same: 0, opposite: 0, total: 0,
        }, o = 0; o < r.length; o++) { const s = r[o]; const u = s[0] + e + (s[1] + t) * n.width; const l = n.data[u]; (l > 0 || l < 0) && (a.id.includes(l) ? a.surface[a.id.indexOf(l)] += 1 : (a.id.push(l), a.surface.push(1))); } for (let c = 0; c < a.id.length; c++) { Math.sign(a.id[c]) === i ? a.same += a.surface[c] : a.opposite += a.surface[c], a.roiSurfaceCovered[c] = a.surface[c] / r.length; } return a.total = a.opposite + a.same, a;
    } const pS = Object.prototype.toString; var mS = (function (t) {
      function r(t, n, i, a) {
        if ((0, w.Z)(this, r), arguments.length === 1) { const o = a = t; t = o.width, n = o.height, i = o.data; } else if (i && !i.length) { i = (a = i).data; } if (void 0 === t && (t = 1), void 0 === n && (n = 1), void 0 === a && (a = {}), typeof a !== 'object' || a === null) throw new TypeError('options must be an object'); if (!Number.isInteger(t) || t <= 0) throw new RangeError('width must be a positive integer'); if (!Number.isInteger(n) || n <= 0) throw new RangeError('height must be a positive integer'); const s = a.kind; const u = void 0 === s ? wb : s; if (typeof u !== 'string') throw new TypeError('kind must be a string'); const l = (function (e) { const t = kb[e]; if (!t) throw new RangeError('invalid image kind: '.concat(e)); return t; }(u)); const c = { ...a }; for (const h in l) void 0 === c[h] && (c[h] = l[h]); !(function (t) { const r = t.components; const n = t.alpha; const i = t.bitDepth; const a = t.colorModel; if (!Number.isInteger(r) || r <= 0) throw new RangeError('invalid components: '.concat(r, '. Must be a positive integer')); if (n !== 0 && n !== 1 && typeof n !== 'boolean') throw new TypeError('invalid alpha: '.concat(n, ': must be a boolean, 0 or 1')); if (!xb.includes(i)) throw new RangeError('invalid bitDepth: '.concat(i, '. Must be one of ').concat(xb.join(', '))); if (!e[a]) throw new RangeError('invalid colorModel: '.concat(a, '. Must be one of ').concat(Object.keys(e).join(', '))); }(c)); const f = c.components; const d = c.bitDepth; const p = c.colorModel; const m = c.alpha + 0; const v = t * n; const g = f + m; const y = d === 32 ? Number.MAX_VALUE : 2 ** d - 1; if (void 0 === i)i = (function (e, t, r, n, i, a) { let o; const s = n * e; switch (i) { case 1: o = new Uint8Array(Math.ceil(s / 8)); break; case 8: o = new Uint8Array(s); break; case 16: o = new Uint16Array(s); break; case 32: o = new Float32Array(s); break; default: throw new Error('Cannot create pixel array for bit depth '.concat(i)); } if (r) for (let u = t; u < o.length; u += n)o[u] = a; return o; }(v, f, m, g, d, y)); else { const b = (function (e, t, r) { let n = t * e; return r === 1 && (n = Math.ceil(n / 8)), n; }(v, g, d)); if (i.length !== b) throw new RangeError('incorrect data size: '.concat(i.length, '. Should be ').concat(b)); } this.width = t, this.height = n, this.data = i, this.size = v, this.components = f, this.alpha = m, this.bitDepth = d, this.maxValue = y, this.colorModel = p, this.channels = g, this.meta = a.meta || {}, Object.defineProperty(this, 'parent', {
          enumerable: !1, writable: !0, configurable: !0, value: a.parent || null,
        }), this.position = a.position || [0, 0], this.computed = null, this.sizes = [this.width, this.height], this.multiplierX = this.channels, this.multiplierY = this.channels * this.width, this.isClamped = this.bitDepth < 32, this.borderSizes = [0, 0];
      } return (0, b.Z)(r, [{ key: t, get() { return 'IJSImage'; } }, { key: 'getRoiManager', value(e) { return new fS(this, e); } }, { key: 'clone', value() { const e = this.data.slice(); return new r(this.width, this.height, e, this); } }, { key: 'apply', value(e) { for (let t = 0; t < this.height; t++) for (let r = 0; r < this.width; r++) { const n = (t * this.width + r) * this.channels; e.call(this, n); } } }], [{ key: 'isImage', value(e) { return pS.call(e) === '[object IJSImage]'; } }, { key: 'fromCanvas', value(e) { const t = e.getContext('2d').getImageData(0, 0, e.width, e.height); return new r(t.width, t.height, t.data); } }, { key: 'createFrom', value(e, t) { const n = vw(e); return Object.assign(n, { parent: e, position: [0, 0] }, t), new r(n); } }]), r;
    }(Symbol.toStringTag)); !(function (e) { for (const t in mw)e.prototype[t] = mw[t]; }(mS)), (function (e) { for (const t in rm)e.prototype[t] = rm[t]; }(mS)), (function (e) { for (const t in cb)e.prototype[t] = cb[t]; }(mS)), mS.prototype.checkProcessable = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; let r = t.bitDepth; let n = t.alpha; let i = t.colorModel; let a = t.components; let o = t.channels; if (typeof e !== 'string' || e.length === 0) throw new TypeError('processName must be a string'); if (r && (Array.isArray(r) || (r = [r]), !r.includes(this.bitDepth))) throw new TypeError('The process: '.concat(e, ' can only be applied if bit depth is in: ').concat(r)); if (n && (Array.isArray(n) || (n = [n]), !n.includes(this.alpha))) throw new TypeError('The process: '.concat(e, ' can only be applied if alpha is in: ').concat(n)); if (i && (Array.isArray(i) || (i = [i]), !i.includes(this.colorModel))) throw new TypeError('The process: '.concat(e, ' can only be applied if color model is in: ').concat(i)); if (a && (Array.isArray(a) || (a = [a]), !a.includes(this.components))) { const s = 'The process: '.concat(e, ' can only be applied if the number of components is in: ').concat(a); throw a.length === 1 && a[0] === 1 ? new TypeError(''.concat(s, '.\rYou should transform your image using "image.grey()" before applying the algorithm.')) : new TypeError(s); } if (o && (Array.isArray(o) || (o = [o]), !o.includes(this.channels))) throw new TypeError('The process: '.concat(e, ' can only be applied if the number of channels is in: ').concat(o)); }, mS.prototype.getRGBAData = function () { const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).clamped; this.checkProcessable('getRGBAData', { components: [1, 3], bitDepth: [1, 8, 16, 32] }); const t = this.width * this.height * 4; const r = e ? new Uint8ClampedArray(t) : new Uint8Array(t); return this.bitDepth === 1 ? (function (e, t) { for (let r = 0; r < e.size; r++) { const n = e.getBit(r); t[4 * r] = 255 * n, t[4 * r + 1] = 255 * n, t[4 * r + 2] = 255 * n; } }(this, r)) : this.bitDepth === 32 ? (this.checkProcessable('getRGBAData', { alpha: 0 }), this.components === 1 ? (function (e, t) { for (let r = e.min[0], n = e.max[0] - r, i = 0; i < e.size; i++) { const a = Math.floor(255 * (e.data[i] - r) / n); t[4 * i] = a, t[4 * i + 1] = a, t[4 * i + 2] = a; } }(this, r)) : this.components === 3 && (this.checkProcessable('getRGBAData', { colorModel: [mb] }), (function (e, t) { for (let r = Math.min.apply(Math, P(e.min)), n = Math.max.apply(Math, P(e.max)) - r, i = 0; i < e.size; i++) { const a = Math.floor(255 * (e.data[3 * i] - r) / n); const o = Math.floor(255 * (e.data[3 * i + 1] - r) / n); const s = Math.floor(255 * (e.data[3 * i + 2] - r) / n); t[4 * i] = a, t[4 * i + 1] = o, t[4 * i + 2] = s; } }(this, r)))) : this.components === 1 ? (function (e, t) { for (let r = 0; r < e.size; r++)t[4 * r] = e.data[r * e.channels] >>> e.bitDepth - 8, t[4 * r + 1] = e.data[r * e.channels] >>> e.bitDepth - 8, t[4 * r + 2] = e.data[r * e.channels] >>> e.bitDepth - 8; }(this, r)) : this.components === 3 && (this.checkProcessable('getRGBAData', { colorModel: [mb] }), (function (e, t) { for (let r = 0; r < e.size; r++)t[4 * r] = e.data[r * e.channels] >>> e.bitDepth - 8, t[4 * r + 1] = e.data[r * e.channels + 1] >>> e.bitDepth - 8, t[4 * r + 2] = e.data[r * e.channels + 2] >>> e.bitDepth - 8; }(this, r))), this.alpha === 1 ? (this.checkProcessable('getRGBAData', { bitDepth: [8, 16] }), (function (e, t) { for (let r = 0; r < e.size; r++)t[4 * r + 3] = e.data[r * e.channels + e.components] >> e.bitDepth - 8; }(this, r))) : (function (e, t) { for (let r = 0; r < e.size; r++)t[4 * r + 3] = 255; }(this, r)), r; }, mS.load = function (e, t) { if (typeof e === 'string') return (function (e, t) { let r; const n = e.slice(0, 64).match(cw); r = n !== null ? Promise.resolve(function (e) { let t; let r; let n; let i; let a = 0.75 * e.length; const o = e.length; let s = 0; e[e.length - 1] === '=' && (a--, e[e.length - 2] === '=' && a--); for (var u = new Uint8Array(a), l = 0; l < o; l += 4)t = rb[e.charCodeAt(l)], r = rb[e.charCodeAt(l + 1)], n = rb[e.charCodeAt(l + 2)], i = rb[e.charCodeAt(l + 3)], u[s++] = t << 2 | r >> 4, u[s++] = (15 & r) << 4 | n >> 2, u[s++] = (3 & n) << 6 | 63 & i; return u; }(e.slice(n[0].length))) : (function (e) { const t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).withCredentials; const r = void 0 !== t && t; return new Promise(((t, n) => { const i = new self.XMLHttpRequest(); i.open('GET', e, !0), i.responseType = 'arraybuffer', i.withCredentials = r, i.onload = function (e) { this.status !== 200 ? n(e) : t(this.response); }, i.onerror = n, i.send(); })); }(e, t)); return r.then(((r) => hw(new Uint8Array(r), n ? e : void 0, t && t.ignorePalette))); }(e, t)); if (e instanceof ArrayBuffer) return Promise.resolve(hw(new Uint8Array(e), void 0, t && t.ignorePalette)); if (e.buffer) return Promise.resolve(hw(e, void 0, t && t.ignorePalette)); throw new Error('argument to "load" must be a string or buffer.'); }, mS.extendMethod = function (e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const n = r.inPlace; const i = void 0 !== n && n; const a = r.returnThis; const o = void 0 === a || a; const s = r.partialArgs; const u = void 0 === s ? [] : s; return mS.prototype[e] = i ? function () { this.computed = null; for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)r[n] = arguments[n]; const i = t.apply(this, [].concat(P(u), r)); return o ? this : i; } : function () { for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)r[n] = arguments[n]; return t.apply(this, [].concat(P(u), r)); }, mS; }, mS.extendProperty = function (e, t) { const r = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).partialArgs; const n = void 0 === r ? [] : r; return db.get = function () { if (this.computed === null) this.computed = {}; else if (fb()(e, this.computed)) return this.computed[e]; const r = t.apply(this, n); return this.computed[e] = r, r; }, Object.defineProperty(mS.prototype, e, db), mS; }, (function (e) { const t = { inPlace: !0 }; e.extendMethod('invert', ww), e.extendMethod('abs', bw), e.extendMethod('level', Qw, t), e.extendMethod('add', rk, t), e.extendMethod('subtract', nk, t), e.extendMethod('subtractImage', ik), e.extendMethod('multiply', ok, t), e.extendMethod('divide', sk, t), e.extendMethod('hypotenuse', ak), e.extendMethod('background', pk), e.extendMethod('flipX', kw), e.extendMethod('flipY', xw), e.extendMethod('blurFilter', _w), e.extendMethod('medianFilter', Pw), e.extendMethod('gaussianFilter', Aw), e.extendMethod('sobelFilter', Gw), e.extendMethod('gradientFilter', Xw), e.extendMethod('scharrFilter', $w), e.extendMethod('dilate', mk), e.extendMethod('erode', wk), e.extendMethod('open', Mk), e.extendMethod('close', Ek), e.extendMethod('topHat', Ck), e.extendMethod('blackHat', Pk), e.extendMethod('morphologicalGradient', Ak), e.extendMethod('warpingFourPoints', Dk), e.extendMethod('crop', zk), e.extendMethod('cropAlpha', Nk), e.extendMethod('resize', Vk).extendMethod('scale', Vk), e.extendMethod('hsv', Yk), e.extendMethod('hsl', Hk), e.extendMethod('cmyk', qk), e.extendMethod('rgba8', Wk), e.extendMethod('grey', $k).extendMethod('gray', $k), e.extendMethod('mask', sx), e.extendMethod('pad', ux), e.extendMethod('colorDepth', lx), e.extendMethod('setBorder', vx, t), e.extendMethod('rotate', hx), e.extendMethod('rotateLeft', fx), e.extendMethod('rotateRight', dx), e.extendMethod('insert', mx), e.extendMethod('getRow', Ex), e.extendMethod('getColumn', Cx), e.extendMethod('getMatrix', Px), e.extendMethod('setMatrix', Ax), e.extendMethod('getPixelsArray', Tx), e.extendMethod('getIntersection', Rx), e.extendMethod('getClosestCommonParent', Ox), e.extendMethod('getThreshold', ax), e.extendMethod('split', gx), e.extendMethod('getChannel', yx), e.extendMethod('combineChannels', bx), e.extendMethod('setChannel', kx), e.extendMethod('getSimilarity', xx), e.extendMethod('getPixelsGrid', _x), e.extendMethod('getBestMatch', Mx), e.extendMethod('cannyEdge', Bx), e.extendMethod('convolution', Ww), e.extendMethod('extract', Ux), e.extendMethod('floodFill', Hx), e.extendMethod('paintLabels', e_, t), e.extendMethod('paintMasks', t_, t), e.extendMethod('paintPoints', o_, t), e.extendMethod('paintPolyline', s_, t), e.extendMethod('paintPolylines', u_, t), e.extendMethod('paintPolygon', l_, t), e.extendMethod('paintPolygons', f_, t), e.extendMethod('countAlphaPixels', C_), e.extendMethod('monotoneChainConvexHull', R_), e.extendMethod('minimalBoundingRectangle', j_), e.extendMethod('getHistogram', d_).extendProperty('histogram', d_), e.extendMethod('getHistograms', p_).extendProperty('histograms', p_), e.extendMethod('getColorHistogram', v_).extendProperty('colorHistogram', v_), e.extendMethod('getMin', g_).extendProperty('min', g_), e.extendMethod('getMax', y_).extendProperty('max', y_), e.extendMethod('getSum', b_).extendProperty('sum', b_), e.extendMethod('getMoment', w_).extendProperty('moment', w_), e.extendMethod('getLocalMaxima', k_), e.extendMethod('getMedian', __).extendProperty('median', __), e.extendMethod('getMean', x_).extendProperty('mean', x_), e.extendMethod('getPoints', S_).extendProperty('points', S_), e.extendMethod('getExtendedPoints', M_).extendProperty('extendedPoints', M_), e.extendMethod('getRelativePosition', E_); }(mS)); const vS = __webpack_require__(2024); const gS = __webpack_require__.n(vS); const yS = {
      regression: { kernelType: 'polynomial', kernelOptions: { degree: 2, constant: 1 } }, threshold: 0.02, roi: { minSurface: 100, positive: !1 }, sampling: 20, include: [],
    }; function bS(e, t, r) { return e.post('data', [t, r]).then(((e) => { for (const t in e)e[t] = new mS(e[t]); return e; })); } const wS = { run(e, t, r) { t = { ...yS, ...t }; const n = this.manager; return Array.isArray(e) ? Promise.all(e.map(((e) => { const i = bS(n, e, t); return typeof r === 'function' && i.then(r), i; }))) : bS(n, e, t); }, work() { worker.on('data', ((e, t, r) => { t = new IJS(t); const n = {}; const i = []; const a = t.grey(); const o = a.sobelFilter(); d('sobel', o); const s = o.level().mask({ threshold: r.threshold }); d('mask', s); const u = o.getRoiManager(); u.fromMask(s); const l = u.getMask(r.roi); d('realMask', l); const c = a.getPixelsGrid({ sampling: r.sampling, mask: l }); const h = t.getBackground(c.xyS, c.zS, r.regression); d('background', h); const f = t.subtract(h); function d(e, t) { r.include.includes(e) && (n[e] = t, i.push(t.data.buffer)); }n.result = f, i.push(f.data.buffer), e(n, i); })); } }; const kS = wS; const xS = (function () { function e() { (0, w.Z)(this, e), this._url = null, this._deps = [null]; } return (0, b.Z)(e, [{ key: 'checkUrl', value() { if (this._url === null) throw new Error('image worker must be initialized with an URL'); } }, { key: 'url', get() { return this._url; }, set(e) { if (typeof e !== 'string') throw new TypeError('worker URL must be a string'); this._url = e, this._deps[0] = e; } }], [{ key: 'extendMethod', value(t, r) { let n; let i; const a = {}; function o() { let e; n || (this.checkUrl(), i = this.url, n = new (gS())(r.work, { deps: i }), a.manager = n); for (var t = arguments.length, o = new Array(t), s = 0; s < t; s++)o[s] = arguments[s]; return (e = r.run).call.apply(e, [a].concat(o)); }o.reset = function () { n && (n.terminate(), n = new (gS())(r.work, { deps: i }), a.manager = n); }, e.prototype[t] = o; } }]), e; }()); !(function (e) { e.extendMethod('background', kS); }(xS)); new xS(); let _S; let SS; let MS; let ES; let CS; const PS = ['isShowingHelp']; const AS = jf(zh)({ height: '90%', width: '100%' }); const TS = function (e) {
      const t = e.isShowingHelp; const r = (v(e, PS), An()); const n = (0, Fh.useMediaQuery)({ query: '(min-aspect-ratio: 1/1)' }); const i = (0, Fh.useMediaQuery)({ query: '(max-aspect-ratio: 21/10) and (min-aspect-ratio: 10/21)' }); console.log('hey'); let a = {}; a = n ? { height: 0.7 * r.height, width: 0.7 * r.height * 4 / 3 } : { width: 0.9 * r.width, height: 0.9 * r.width * 3 / 4 }; const o = t ? { zIndex: 1 } : {}; const s = nn({ opacity: t && i ? '0%' : '100%', config: { mass: 3, friction: 26, tension: 170 } }).opacity; return (0, Mo.jsxs)('div', {
        style: a,
        className: 'webcam-container',
        children: [(0, Mo.jsxs)(Pn.div, {
          className: 'webcam photo-box',
          style: { opacity: s },
          children: [(0, Mo.jsx)(AS, { children: (0, Mo.jsx)(cc, { size: '100%' }) }), (0, Mo.jsx)(Md, {
            sx: {
              fontSize: 'max(min(7vmin, 45px), 22px)', position: 'relative', bottom: 'max(min(7vmin, 45px), 22px)', lineHeight: 'normal', fontFamily: 'Metropolis', fontWeight: 'normal',
            },
            className: 'selected-tab',
            children: 'UPLOAD PHOTO',
          })],
        }), i && (0, Mo.jsx)('div', { className: 'stacked-container', style: o, children: (0, Mo.jsx)(jh, { isShown: t }) })],
      });
    }; const RS = Kl.div(_S || (_S = p(['\n  height: 100%;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  flex-direction: column;\n']))); const IS = Kl.div(SS || (SS = p(['\n  position: relative;\n  width: 100%;\n  max-height: calc(100% - max(48px, min(10vmin, 71px)));\n  flex: 1 0 auto;\n  display: flex;\n  justify-content: space-evenly;\n  align-items: center;\n  flex-direction: column;\n']))); const OS = Kl.div(MS || (MS = p(['\n  display: flex;\n  justify-content: space-evenly;\n  gap: 1%;\n  align-items: center;\n  flex-direction: column;\n']))); const DS = Kl.div(ES || (ES = p(['\n  display: flex;\n  justify-content: space-evenly;\n  @media (max-aspect-ratio: 21/10) {\n    flex-direction: column;\n    height: 100%;\n  }\n  @media (min-aspect-ratio: 21/10) {\n    flex-direction: row;\n    width: 100%;\n  }\n  gap: 1%;\n  align-items: center;\n  transition: opacity .5s ease-in-out;\n  opacity: ', '\n'])), ((e) => (e.selectedTab === 0 ? '1' : '0'))); const zS = Kl(Qh)(CS || (CS = p(['\n  width: 60%;\n  height: 100%;\n']))); const NS = function () {
      const e = d((0, i.useState)(null), 2); const t = e[0]; const r = e[1]; const n = d((0, i.useState)(null), 2); const a = n[0]; const o = n[1]; const s = d((0, i.useState)(null), 2); const l = s[0]; const h = s[1]; const f = d((0, i.useState)(null), 2); const p = f[0]; const m = f[1]; const v = d((0, i.useState)(!1), 2); const g = v[0]; const y = v[1]; const b = d((0, i.useState)(0), 2); const w = b[0]; const k = b[1]; const x = (0, i.useRef)(null); const _ = (0, Fh.useMediaQuery)({ query: '(max-aspect-ratio: 21/10) and (min-aspect-ratio: 10/21)' }); const S = (function () { const e = d((0, i.useState)(''), 2); const t = e[0]; const r = e[1]; return (0, i.useEffect)((() => { const e = function () { const e = navigator.userAgent.toLowerCase(); const t = /iphone|ipad|ipod|android|blackberry|windows phone/g.test(e); const n = /(ipad|tablet|playbook|silk)|(android(?!.*mobile))/g.test(e); r(t ? 'Mobile' : n ? 'Tablet' : 'Desktop'); }; return e(), window.addEventListener('resize', e), function () { window.removeEventListener('resize', e); }; }), []), t; }()); const M = (function () { const e = c(u().mark((function e(t) { let r; let n; let i; return u().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: if (t) { e.next = 2; break; } return e.abrupt('return'); case 2: return r = JSON.stringify({ image: t }), n = void 0, e.prev = 4, e.next = 7, fetch('http://localhost:8000', { method: 'post', body: r, headers: { 'Content-Type': 'application/json' } }); case 7: n = e.sent, e.next = 15; break; case 10: return e.prev = 10, e.t0 = e.catch(4), Tp.error('Something went wrong. Please try again'), m(null), e.abrupt('return'); case 15: return e.next = 17, n.json(); case 17: if (!(i = e.sent).token) { e.next = 25; break; }localStorage.setItem('token', i.token), localStorage.setItem('expirationDate', i.expirationDate), o(i.token), h(i.expirationDate), e.next = 33; break; case 25: e.t1 = i['predicted-class'], e.next = e.t1 === 'no_mask' ? 28 : e.t1 === 'incorrect' ? 30 : 32; break; case 28: return Tp.error("You don't seem to be wearing a mask - please put one on to continue"), e.abrupt('break', 33); case 30: return Tp.error('You are wearing your mask incorrectly. Please adjust the position of your mask and try again'), e.abrupt('break', 33); case 32: Tp.error('Please capture your face inside the picture'); case 33: case 'end': return e.stop(); } }), e, null, [[4, 10]]); }))); return function (t) { return e.apply(this, arguments); }; }()); (0, i.useEffect)((() => { const e = localStorage.getItem('token'); const t = localStorage.getItem('expirationDate'); e && (o(e), h(t)); }), [a, o]), (0, i.useEffect)((() => { const e = setInterval((() => { const e = Math.floor(Date.now() / 1e3); l && l < e && (E(), m(null), Tp('Your token has expired. \nPlease take a photo to generate a new one.')); }), 2e3); return function () { return clearInterval(e); }; }), [l, h, o]); var E = function () { o(null), h(null), localStorage.clear(); }; const C = (0, i.useCallback)(c(u().mark((function e() { let t; return u().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: t = x.current.getScreenshot(), m(t), y(!0); case 3: case 'end': return e.stop(); } }), e); }))), [x, m]); return (0, Mo.jsxs)(RS, {
        children: [(0, Mo.jsx)(tm, { containerStyle: { top: 85 } }), (0, Mo.jsx)(Id, { selectedTab: w, changeSelectedTab: k }), (0, Mo.jsxs)(IS, {
          children: [(0, Mo.jsxs)(DS, {
            selectedTab: w,
            children: [(0, Mo.jsxs)(OS, {
              children: [!a && S === 'Desktop' && (0, Mo.jsxs)(Mo.Fragment, {
                children: [(0, Mo.jsx)(Uh, { ref: x, isShowingHelp: t }), (0, Mo.jsxs)('div', {
                  className: 'button-container',
                  style: { minWidth: '220px', height: '8%', marginBottom: '1%' },
                  children: [(0, Mo.jsx)(zS, {
                    sx: { fontSize: 'min(3vmin, 21px)' }, variant: 'contained', onClick: C, children: 'Capture photo',
                  }), _ && (0, Mo.jsx)(Bd, { isShown: t, toggleShownUpdate: r, pathLength: 300 })],
                })],
              }), !a && (S === 'Mobile' || S === 'Tablet') && (0, Mo.jsxs)(Mo.Fragment, { children: [(0, Mo.jsx)(TS, { isShowingHelp: t }), (0, Mo.jsx)('div', { className: 'button-container', style: { minWidth: '220px', height: '8%', marginBottom: '1%' }, children: _ && (0, Mo.jsx)(Bd, { isShown: t, toggleShownUpdate: r, pathLength: 300 }) })] }), a && (0, Mo.jsx)(hd, { token: a, expirationDate: l, onRenew: E })],
            }), !_ && (0, Mo.jsx)(Dd, {})],
          }), (0, Mo.jsx)(jd, { selectedTab: w })],
        }), (0, Mo.jsx)(yf, {
          isOpen: g && !a, imageClearer() { return m(null); }, onClose() { y(!1); }, onConfirm() { M(p).then(y(!1)); }, imgSrc: p,
        })],
      });
    }; o.createRoot(document.getElementById('root')).render((0, Mo.jsx)(i.StrictMode, { children: (0, Mo.jsx)(NS, {}) }));
  }());
}());
// # sourceMappingURL=main.2356d563.js.map
